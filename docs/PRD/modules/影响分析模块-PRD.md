# 影响分析模块 - 产品需求文档

> **项目**: AI超级个体开发助手
> **版本**: v1.0
> **迭代**: Iteration 1
> **日期**: 2025-12-14
> **模块**: 影响分析模块
> **状态**: 需求已确认

---

<!--
章节ID规范说明：
- 格式：{#prd-影响分析-[章节编号]}
- 必须标注ID的章节：功能点清单、数据模型、用户故事与验收标准
-->

## 一、产品愿景

### 1.1 一句话描述

自动分析需求变更影响范围，生成修复任务链，确保变更可控。

### 1.2 核心定位

| 维度         | 定义                                    |
| ------------ | --------------------------------------- |
| **产品类型** | 分析引擎 + 任务生成器                   |
| **目标平台** | Claude AI + Git                         |
| **用户定位** | 独立开发者                              |
| **核心价值** | 将需求变更转化为可执行的修复任务链，避免遗漏受影响模块 |

### 1.3 技术定位

- **部署方式**：嵌入在Claude AI工作流中
- **集成方式**：读取state.json + 代码标注(@integration) + Git历史
- **数据持久化**：影响分析结果记录在state.json的changeHistory

---

## 二、目标用户

### 2.1 用户画像

```yaml
名称: 独立开发者（超级个体）

典型特征:
  - 需要修改已完成的需求或架构
  - 担心修改影响其他模块
  - 需要清晰的修复步骤指导
  - 希望AI自动识别受影响的代码

典型场景:
  - 测试阶段发现需求有误，需要修改PRD
  - 架构设计不合理，需要修改架构文档
  - 实现阶段发现接口定义有遗漏
  - 部署后发现性能问题，需要回滚修复

核心诉求:
  - 自动识别受影响的模块和文件
  - 清晰的修复任务顺序（自上而下）
  - 避免遗漏依赖模块的更新
  - 快速定位代码中的集成点
```

### 2.2 用户痛点

| 痛点          | 描述           | 影响           | 解决方案       |
| ------------- | -------------- | -------------- | -------------- |
| **P1: 影响范围不明** | 修改一个模块，不知道影响哪些其他模块 | 导致遗漏修复，引发级联Bug | 基于moduleDependencies + integrationPoints自动分析 |
| **P2: 根因难定位** | 测试失败时不知道是需求问题还是代码问题 | 修复方向错误，浪费时间 | 分层根因分析（测��用例 → 代码 → 架构 → 需求） |
| **P3: 修复顺序混乱** | 不清楚应该先修改需求还是先修改代码 | 导致反复返工 | 生成修复任务链（任务1:修改PRD → 任务2:修改架构 → 任务3:修改代码） |

---

## 三、功能架构

### 3.1 系统架构图

```
变更触发（需求变更、测试失败）
     ↓
读取依赖关系（state.json.moduleDependencies + integrationPoints）
     ↓
影响范围分析
  ├─ 模块级分析（基于moduleDependencies）
  └─ 代码级分析（基于@integration标注）
     ↓
根因分析（如测试失败）
  ├─ 测试用例问题？
  ├─ 代码Bug？
  ├─ 架构设计问题？
  └─ 需求问题？
     ↓
生成修复任务链
  ├─ 任务1: 修改PRD（需要人工审批）
  ├─ 任务2: 修改架构文档（需要人工审批）
  └─ 任务3: 修改代码（AI实现）
     ↓
提交人工确认回滚阶段
     ↓
执行修复任务（自上而下）
     ↓
更新state.json（记录变更历史）

完整架构设计详见：docs/architecture/iteration-1/00-系统架构总览.md
```

### 3.2 模块划分

| 模块名        | 职责               | 实现方式           |
| ------------- | ------------------ | ------------------ |
| **依赖关系读取模块** | 读取moduleDependencies和integrationPoints | 解析state.json |
| **影响范围分析模块** | 分析受影响的模块和代码位置 | 图遍历算法 + grep搜索@integration |
| **根因分析模块** | 测试失败时分层分析根本原因 | AI推理 + 机械性检查 |
| **任务生成模块** | 生成修复任务链（自上而下） | 基于根因分析结果生成任务 |
| **历史数据访问模块** | 智能判断是否需要读取state_his.json | 关键词检测 + 可配置 |

---

## 四、核心功能设计

### 4.1 功能点清单 {#prd-影响分析-功能清单}

**详细功能设计详见**：docs/architecture/iteration-1/02-命令设计.md

| 功能点                      | 描述                           | 触发时机                          |
| --------------------------- | ------------------------------ | --------------------------------- |
| 模块级影响分析               | 基于moduleDependencies分析受影响模块 | 用户修改某个模块的需求或架构 |
| 代码级影响分析               | 基于@integration标注定位代码位置 | 用户修改某个接口的定义 |
| 测试失败根因分析             | 分层分析：测试用例 → 代码 → 架构 → 需求 | 测试失败时触发 |
| 修复任务链生成               | 自上而下生成修复任务（PRD → 架构 → 代码） | 根因分析完成后 |
| 历史数据智能访问             | 自动判断是否需要读取state_his.json | 用户提及历史对比、长期趋势 |
| 集成点自动检测（架构阶段）   | AI推断模块间集成点，人工审批 | 架构设计阶段 |

### 4.2 数据模型 {#prd-影响分析-数据模型}

#### 核心数据结构（概览）

**state.json - moduleDependencies字段** - 模块间依赖关系

```json
{
  "moduleDependencies": {
    "订单模块": {
      "dependsOn": ["用户模块", "库存模块"],
      "integrationPoints": [
        {
          "targetModule": "用户模块",
          "interface": "getUserInfo",
          "purpose": "获取用户信息",
          "impactCheckpoints": [
            "检查getUserInfo返回值结构",
            "检查getUserInfo错误处理",
            "检查getUserInfo性能影响"
          ]
        }
      ]
    }
  }
}
```

**state.json - changeHistory字段** - 变更历史记录

```json
{
  "changeHistory": [
    {
      "id": "change-010",
      "timestamp": "2025-12-14T10:00:00Z",
      "iteration": "iteration-1",
      "type": "requirement_change",
      "description": "修改用户模块的getUserInfo接口签名",
      "affectedModules": ["订单模块", "报表模块"],
      "rootCause": "需求变更：需要返回用户头像URL",
      "tasks": [
        {
          "id": "task-010-1",
          "content": "修改PRD中getUserInfo的返回值定义",
          "phase": "requirements",
          "status": "pending"
        },
        {
          "id": "task-010-2",
          "content": "修改架构文档中getUserInfo的接口设计",
          "phase": "architecture",
          "status": "pending"
        },
        {
          "id": "task-010-3",
          "content": "修改代码实现（用户模块 + 订单模块 + 报表模块）",
          "phase": "implementation",
          "status": "pending"
        }
      ]
    }
  ]
}
```

**关键字段说明**：

| 字段名      | 类型     | 说明                   | 必填 |
| ----------- | -------- | ---------------------- | ---- |
| `moduleDependencies` | object | 模块间依赖关系 | 是 |
| `integrationPoints[].impactCheckpoints` | array | 影响分析检查清单 | 是 |
| `changeHistory[].affectedModules` | array | 受影响的模块列表 | 是 |
| `changeHistory[].rootCause` | string | 根本原因 | 是 |
| `changeHistory[].tasks` | array | 修复任务链 | 是 |

**完整数据模型详见**：docs/architecture/iteration-1/03-数据模型设计.md

### 4.3 核心工作流

**工作流1：模块级影响分析**

```
用户修改：用户模块的getUserInfo接口定义
  ↓
【步骤1】AI读取state.json.moduleDependencies
  → 发现"订单模块"依赖"用户模块.getUserInfo"
  → 发现"报表模块"依赖"用户模块.getUserInfo"
  ↓
【步骤2】AI生成影响分析报告
  受影响的模块：
    - 订单模块（集成点：getUserInfo）
    - 报表模块（集成点：getUserInfo）
  ↓
【步骤3】AI使用grep搜索代码标注
  grep -r "@integration 用户模块.getUserInfo" src/

  结果：
    src/order/createOrder.ts:12
    src/order/orderService.ts:45
    src/report/userReport.ts:23
  ↓
【步骤4】AI生成待办任务
  - [ ] 检查 src/order/createOrder.ts:12 的getUserInfo调用
  - [ ] 检查 src/order/orderService.ts:45 的getUserInfo调用
  - [ ] 检查 src/report/userReport.ts:23 的getUserInfo调用
  ↓
【步骤5】AI提示用户确认修复方案

完整工作流设计详见：docs/architecture/iteration-1/00-系统架构总览.md（第四节）
```

**工作流2：测试失败根因分析**

```
E2E测试失败：用户注册流程
  ↓
【步骤1】AI分层分析
  层1: 测试用例问题？
    → 检查测试用例的断言逻辑
    → 结论：测试用例正确

  层2: 代码Bug？
    → 检查代码实现是否符合架构设计
    → 结论：代码实现符合架构设计

  层3: 架构设计问题？
    → 检查架构设计中是否缺少事务管理
    → 结论：架构设计缺少事务管理机制（发送邮件失败时用户未保存，但无法回滚）

  层4: 需求问题？
    → 检查PRD中的验收标准
    → 结论：PRD验收标准正确
  ↓
【步骤2】AI生成根因分析报告
  根本原因：架构设计缺少事务管理机制
  建议回滚阶段：architecture
  ↓
【步骤3】AI生成修复任务链
  - 任务1: 修改架构文档"命令设计.md"（增加事务管理设计）→ 人工审批
  - 任务2: 修改代码实现（实现事务包裹、添加回滚逻辑）→ AI实现
  - 任务3: 重新执行测试 → AI执行
  ↓
【步骤4】AI提交人工确认
  提示："是否同意回滚到architecture阶段？"
  ↓
用户确认
  ↓
【步骤5】AI执行修复任务链（自上而下）
```

**工作流3：历史数据智能访问**

```
场景1：用户询问"修改用户模块会影响哪些模块？"
  ↓
AI判断：仅限当前迭代分析
  ↓
AI只读取 state.json
  → 完成分析

场景2：用户询问"对比iteration-1和iteration-2中用户模块的设计"
  ↓
AI判断：需要历史数据（关键词"对比"、"iteration-1"）
  ↓
AI自动读取 state.json + state_his.json
  → 完成对比分析

场景3：用户询问"哪个模块最容易出问题？"
  ↓
AI判断：需要历史数据（关键词"趋势"、"统计"）
  ↓
AI自动读取 state_his.json
  → 统计所有迭代中每个模块的变更频率
  → 完成趋势分析
```

---

## 五、用户故事与验收标准 {#prd-影响分析-验收标准}

### 5.1 用户故事清单

#### 用户视角（面向最终用户）

**故事 1：模块级影响分析**
```
作为独立开发者，我想修改某个模块的接口定义时，AI自动告诉我哪些模块会受影响，以便我不遗漏任何修改。

验收标准：
  - [ ] AI读取state.json.moduleDependencies
  - [ ] AI识别出所有依赖目标模块的模块
  - [ ] AI生成影响分析报告（受影响模块列表 + 集成点列表）
  - [ ] AI使用grep搜索@integration标注，定位代码位置
  - [ ] AI生成待办任务清单（每个受影响的代码位置一个任务）
```

**故事 2：代码级影响分析**
```
作为独立开发者，我想快速定位代码中调用某个接口的所有位置，以便修改接口后同步修改所有调用点。

验收标准：
  - [ ] AI使用grep搜索 @integration [模块名].[接口名]
  - [ ] AI返回所有匹配的文件路径和行号
  - [ ] AI读取这些代码位置的上下文，分析调用方式
  - [ ] AI生成修改建议（如参数变化需要调整调用方式）
```

**故事 3：测试失败根因分析**
```
作为独立开发者，我想在测试失败时，AI帮我分析是测试用例问题、代码Bug、架构问题还是需求问题，以便快速定位根因。

验收标准：
  - [ ] AI执行分层分析（测试用例 → 代码 → 架构 → 需求）
  - [ ] AI生成根因分析报告（包含每一层的分析结论和依据）
  - [ ] AI建议回滚到哪个阶段（requirements/architecture/implementation）
  - [ ] AI生成修复任务链（自上而下：PRD → 架构 → 代码）
  - [ ] AI提交人工确认："是否同意回滚到[阶段]？"
```

**故事 4：修复任务链生成**
```
作为独立开发者，我想在确认根因后，AI自动生成完整的修复任务链，以便我按正确顺序修复问题。

验收标准：
  - [ ] AI基于根因分析结果生成任务链
  - [ ] 任务顺序：先修改PRD → 再修改架构 → 最后修改代码
  - [ ] 每个任务标明是否需要人工审批
  - [ ] 任务链保存到state.json.changeHistory[].tasks
  - [ ] AI提示："修复任务链已生成，请确认是否执行"
```

**故事 5：历史迭代对比分析**
```
作为独立开发者，我想对比当前迭代和历史迭代中某个模块的设计差异，以便了解模块演进历史。

验收标准：
  - [ ] 用户明确提及"对比"、"iteration-X"等关键词
  - [ ] AI自动读取state.json（当前迭代）+ state_his.json（历史迭代）
  - [ ] AI对比两个迭代中的模块设计（如integrationPoints变化）
  - [ ] AI生成对比报告（新增集成点、删除集成点、修改集成点）
```

**故事 6：长期趋势分析**
```
作为独立开发者，我想知道哪些模块在历史迭代中变更最频繁，以便评估模块稳定性。

验收标准：
  - [ ] 用户明确提及"趋势"、"统计"、"过去X个迭代"等关键词
  - [ ] AI自动读取state_his.json
  - [ ] AI统计每个模块在所有迭代中的变更次数（基于changeHistory）
  - [ ] AI生成趋势报告（模块变更频率排名、变更类型分布）
```

#### 系统视角（面向功能模块）

**故事 7：集成点自动检测（架构阶段）**
```
作为系统，我需要在架构设计阶段帮助用户识别模块间的集成点，以便提前声明依赖关系。

验收标准：
  - [ ] AI读取PRD中的用户故事
  - [ ] AI读取state.json.moduleDependencies（已有依赖关系）
  - [ ] AI推断新模块可能的集成点（基于用户故事中的业务逻辑）
  - [ ] AI生成集成点建议清单（目标模块、接口名、调用目的）
  - [ ] 提交人工审批，审批通过后同步到state.json.moduleDependencies
```

**故事 8：架构先行原则检查**
```
作为系统，我需要在实现阶段检测是否存在架构中未声明的集成点，以便强制架构先行原则。

验收标准：
  - [ ] AI在实现代码时检查所有@integration标注
  - [ ] 对比标注中的集成点与state.json.integrationPoints
  - [ ] 如发现未声明的集成点，拒绝继续实现
  - [ ] 提示："发现未声明的集成点[模块.接口]，请先回滚到架构阶段补充设计"
```

**故事 9：影响分析检查清单验证**
```
作为系统，我需要在执行影响分析时，使用impactCheckpoints验证所有检查点是否覆盖。

验收标准：
  - [ ] AI读取integrationPoints[].impactCheckpoints
  - [ ] AI逐项检查每个checkpoint（如"检查getUserInfo返回值结构"）
  - [ ] AI生成检查结果报告（已检查、未检查、检查失败）
  - [ ] 如有未检查项，提示用户手动验证
```

**故事 10：历史数据访问控制**
```
作为系统，我需要根据配置和上下文智能决定是否读取state_his.json，以便节省token和时间。

验收标准：
  - [ ] AI检查settings.autoReadHistory配置（true/false）
  - [ ] 如为false，总是先提示用户："需要访问历史数据吗？"
  - [ ] 如为true，符合触发条件时自动读取（对比、趋势、明确提及历史迭代ID）
  - [ ] 默认只读当前迭代（state.json），90%场景适用
```

### 5.2 边界条件与异常处理

| 场景                 | 期望行为               | 错误处理               |
| -------------------- | ---------------------- | ---------------------- |
| **循环依赖检测**     | 检测到循环依赖时拒绝执行 | 提示"检测到循环依赖：A→B→C→A" |
| **集成点不存在**     | grep搜索@integration未找到匹配 | 警告"架构中声明的集成点在代码中未找到" |
| **根因分析失败**     | AI无法推断根本原因 | 提示"无法自动分析根因，请人工判断" |
| **历史数据损坏**     | state_his.json格式错误 | 降级到只读state.json，警告"历史数据不可用" |
| **模块依赖缺失**     | moduleDependencies中缺少某个模块 | 警告"模块[X]未在依赖关系中声明" |

---

## 六、非功能需求

### 6.1 性能要求

| 指标             | 要求                   | 备注               |
| ---------------- | ---------------------- | ------------------ |
| **影响分析响应时间** | < 5秒（模块级） | 包括读取state.json + 图遍历 |
| **代码搜索时间** | < 3秒（@integration标注搜索） | 基于grep，项目规模< 10万行代码 |
| **根因分析时间** | < 30秒 | AI推理时间，取决于Claude API响应速度 |

### 6.2 可靠性要求

- **容错性**：state.json损坏时降级到基于代码标注的分析
- **数据一致性**：integrationPoints与@integration标注的一致性检查
- **可恢复性**：影响分析失败时不影响state.json状态

### 6.3 可维护性要求

- **日志**：记录所有影响分析请求（触发时间、分析结果、生成的任务）
- **监控**：changeHistory记录所有变更和影响分析结果
- **可测试性**：提供测试数据集（模拟依赖关系、模拟代码标注）

### 6.4 准确性要求

- **影响分析准确率**：基于moduleDependencies的分析准确率100%（机械性检查）
- **根因分析准确率**：AI推理的准确率目标80%（AI作为参考，用户最终决定）
- **集成点检测准确率**：AI建议的准确率目标70%（需要人工审批）

---

## 七、技术约束与依赖

### 7.1 技术栈要求

- **状态管理**：JSON格式（state.json、state_his.json）
- **代码搜索**：grep命令（Windows/macOS/Linux兼容）
- **AI推理**：Claude API（根因分析、集成点推断）
- **版本控制**：Git（读取历史commit、diff）

### 7.2 兼容性要求

- **项目规模**：支持代码量< 10万行的项目（grep性能限制）
- **语言无关**：代码标注机制不依赖特定编程语言
- **Claude CLI版本**：兼容当前最新版本

### 7.3 依赖关系

| 依赖模块       | 依赖原因                     | 集成方式           |
| -------------- | ---------------------------- | ------------------ |
| **状态管理模块** | 读取moduleDependencies、integrationPoints | 直接读取state.json |
| **代码规范模块** | 依赖@integration标注的存在 | 代码标注规范 |
| **测试验证模块** | 测试失败时触发根因分析 | 接收测试失败事件 |
| **Git集成模块** | 读取历史commit、diff信息 | Git命令调用 |

**完整依赖关系详见**：docs/architecture/iteration-1/04-模块集成设计.md

---

## 八、迭代规划

### 8.1 Iteration 1 (MVP)

- **目标**：实现基于标注的影响分析、根因分析、任务生成
- **功能范围**：
  - 模块级影响分析（基于moduleDependencies）
  - 代码级影响分析（基于@integration标注 + grep）
  - 测试失败根因分析（分层分析 + AI推理）
  - 修复任务链生成（自上而下）
  - 历史数据智能访问（混合方案）
- **验收标准**：
  - 影响分析准确率100%（模块级）
  - 根因分析准确率≥70%（AI推理）
  - 任务链生成符合自上而下原则

### 8.2 Iteration 2（未来增强）

- **目标**：引入静态分析工具、可视化依赖关系图
- **功能范围**：
  - 静态分析工具（作为@integration标注的辅助验证）
  - 依赖关系可视化（生成模块依赖关系图）
  - 循环依赖自动检测和修复建议
  - 弱依赖支持（可选依赖）
- **验收标准**：
  - 静态分析与标注一致性≥95%
  - 依赖关系图自动生成
  - 循环依赖检测准确率100%

---

**文档版本历史**

| 版本  | 日期       | 修改内容               | 修改人 |
| ----- | ---------- | ---------------------- | ------ |
| v1.0  | 2025-12-14 | 初始版本，需求确认完成 | Claude AI |
