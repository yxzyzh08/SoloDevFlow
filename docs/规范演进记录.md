# 规范演进记录

> 记录 SoloDevFlow 2.0 规范的每次修改及其原因

---

## 演进记录

### 2024-12-17：新增核心架构元原则

**修改位置**：`SoloDevFLow2/docs/PRD.md` 新增第三节

**修改原因**：
- PRD 缺乏架构层面的根本性原则定义
- 需要明确"文档即真理源"的核心理念
- 需要明确递归总分结构的组织方式
- 需要明确横向功能的可插拔设计

**修改内容**：

新增"核心架构元原则"章节，包含：

1. **元原则1：文档即真理源（Spec First）**
   - 文档是唯一真实来源，代码是投影
   - 人类关注文档，AI管理代码
   - 测试+验收保证一致性

2. **元原则2：递归总分结构（最多3层）**
   - 产品 → 迭代 → 模块
   - 超过3层拆分为独立产品
   - 每层先总后分

3. **元原则3：横向功能可插拔**
   - 横向功能定义标准接口规范
   - 纵向模块通过接口调用
   - 接口可独立替换

4. **概念层级**
   - 元原则 > 横向功能 > 纵向模块
   - 明确三者的层级关系

**关键决策**：
- 三原则定位为"元原则"，比横向功能更高一层
- 迭代1可在规范层面落地，工具强制留给后续迭代
- 接口形态为"规范接口"（文档定义），AI按规范实现

**影响范围**：
- 章节编号调整（原三→四，原四→五，原五→六）
- 后续所有设计和实现必须遵循这三条元原则

---

### 2024-12-17：扩展元原则2为双视图结构

**修改位置**：`SoloDevFLow2/docs/PRD.md` 第三节元原则2

**修改原因**：
- 原"递归总分结构"只描述了"分解"（如何拆分）
- 缺失"集成"维度（组件如何协作）
- 软件本质是组件相互集成，树形结构只有"分"没有"合"

**问题分析**：
```
树形结构（分解视角）    vs    运行时（协作视角）
────────────────────────────────────────────────
产品                         模块A ←→ 模块B
  └── 迭代                      ↑        ↓
        └── 模块A/B/C           └── 模块C ←┘
```

**修改内容**：

元原则2 从"递归总分结构"扩展为"双视图结构（分解+集成）"：

- **视图A：树形分解（纵向）** - 描述如何拆分
  - 最多3层：产品 → 迭代 → 模块
  - 超过3层拆分为独立产品
  - 每层先总后分

- **视图B：依赖集成（横向）** - 描述如何协作
  - 每个模块显式声明依赖
  - 依赖关系记录在文档中
  - 变更前必须分析依赖影响

**关键决策**：
- 不新增第四条元原则，而是扩展元原则2
- 依赖管理是结构原则的一部分，不是横向功能
- 双视图互补：分解+集成 = 完整的结构描述

**影响范围**：
- 模块设计文档需要包含依赖声明
- 变更流程需要依赖影响分析

---

### 2024-12-17：精确化元原则1的表述

**修改位置**：`SoloDevFLow2/docs/PRD.md` 第三节元原则1

**修改原因**：
- 原表述"改需求→先改文档→再改代码"过于绝对
- 未区分"需求变更"和"Bug修复/重构"
- 未明确文档应该写什么内容

**修改内容**：

1. **定义精确化**：从"文档是真实来源"改为"文档定义行为契约"

2. **明确文档内容**：
   - 业务层：业务概念、业务实体、业务规则
   - 技术层：接口规范、依赖声明、验收标准

3. **区分变更类型**：
   | 变更类型 | 文档 | 代码 |
   |----------|------|------|
   | 需求/功能变更 | 先改 | 后改 |
   | Bug修复 | 不改 | 直接改 |
   | 内部重构 | 不改 | 直接改 |

4. **判断标准**：文档定义的内容变了吗？变了→先改文档

**关键决策**：
- 文档不是代码的1:1映射，而是行为契约
- 内部实现细节不在文档范围内
- Bug修复和重构可以直接改代码

---

### 2024-12-17：区分两类文档 + 扩展视图B为协作流程

**修改位置**：`SoloDevFLow2/docs/PRD.md` 元原则1和元原则2

**修改原因**：
- 元原则1未区分"模块文档"和"流程文档"，变更规则不完整
- 视图B只描述技术依赖，缺少业务流程维度
- 软件的本质是模块协作完成业务，不仅是调用关系

**问题分析**：

```
原视图B：依赖集成（技术视角）
  模块A ──依赖──→ 模块B
  只回答"谁调用谁"

缺失：业务协作（业务视角）
  【下单流程】
  用户下单 → 订单模块 → 库存模块 → 支付模块
  回答"一起完成什么业务"
```

**修改内容**：

1. **元原则1新增文档类型区分**：
   | 类型 | 描述 | 内容 |
   |------|------|------|
   | 模块文档 | 单个模块的契约 | 业务概念、实体、规则、接口 |
   | 流程文档 | 跨模块的协作 | 业务流程、模块职责、协作顺序 |

2. **元原则1变更规则扩展**：
   | 变更类型 | 模块文档 | 流程文档 | 代码 |
   |----------|----------|----------|------|
   | 新增/修改业务流程 | 可能改 | 先改 | 后改 |
   | 模块接口/行为变更 | 先改 | 检查影响 | 后改 |
   | Bug修复 | 不改 | 不改 | 直接改 |
   | 内部重构 | 不改 | 不改 | 直接改 |

3. **视图B从"依赖集成"扩展为"协作流程"**：
   - 包含两个层面：业务流程 + 技术依赖
   - 核心业务流程必须显式描述
   - 流程变更需先改流程文档

**关键决策**：
- 文档有两类：模块文档（纵向）和流程文档（横向）
- 视图B不仅是技术依赖，更是业务协作
- 两类文档的变更规则不同

**影响范围**：
- 需要为核心业务流程编写流程文档
- 流程变更时需先改流程文档

---

### 2024-12-17：完善文档类型的归属层级

**修改位置**：`SoloDevFLow2/docs/PRD.md` 元原则1

**修改原因**：
- 元原则1只定义了第三层（模块文档）和横向（流程文档）
- 缺少第一层（产品PRD）和第二层（迭代PRD）的定义
- 流程文档归属不清：它是产品级的，不属于任何单一迭代

**问题分析**：

```
迭代的定位：
  - 做产品中1个或少数模块
  - 快速验证方向是否正确
  - 迭代是"增量"，不是"全量"

模块文档：归属明确，属于某个迭代
流程文档：归属模糊，跨多个迭代演进

例如：
  迭代1：做订单模块
  迭代2：做库存模块
  迭代3：做支付模块
  【下单流程】随迭代渐进完善，不属于任何单一迭代
```

**修改内容**：

按归属层级重新组织文档类型：

| 归属 | 类型 | 描述 | 内容 |
|------|------|------|------|
| 产品级 | 产品PRD | 产品是什么 | 愿景、用户、价值、元原则、路线图 |
| 产品级 | 流程文档 | 如何协作 | 业务流程、模块职责、协作顺序（跨迭代演进） |
| 迭代级 | 迭代PRD | 迭代做什么 | 目标、范围、验收标准 |
| 迭代级 | 模块文档 | 模块怎么做 | 业务概念、实体、规则、接口、验收标准 |

变更规则也相应扩展为五列（产品PRD、流程文档、迭代PRD、模块文档、代码）。

**关键决策**：
- 文档分两个归属层级：产品级 vs 迭代级
- 流程文档是产品级的，跨迭代演进
- 各层级文档有不同的变更规则

**影响范围**：
- 流程文档应放在产品级目录，不在迭代目录下
- 流程文档随迭代渐进完善，可标记[待实现]部分

---

### 2024-12-17：明确流程文档内容，避免重复维护

**修改位置**：`SoloDevFLow2/docs/PRD.md` 元原则1和视图B

**修改原因**：
- 流程文档中的"模块职责"与模块文档中的"接口规范"存在重复
- 流程文档缺少模块依赖关系的描述
- 重复维护会导致不一致

**问题分析**：

```
流程文档的"模块职责"：订单模块：创建订单、更新状态
模块文档的"接口规范"：createOrder(), updateStatus()

两者本质相同，重复维护风险高
```

**修改内容**：

1. **流程文档内容调整**：
   - 业务流程：协作顺序和触发条件
   - 模块依赖：模块间的调用关系（新增）
   - 模块职责：引用模块文档，不重复定义（避免重复）

2. **视图B示例更新**：
   ```
   【业务流程名称】
   触发 → 模块A → 模块B → 模块C → 结果

   模块依赖：
     模块A → 模块B（调用原因）
     模块A → 模块C（调用原因）
   ```

**关键决策**：
- 流程文档只描述流程和依赖，职责引用模块文档
- 单一来源原则：模块职责只在模块文档中定义
- 新增模块依赖关系的显式记录

**影响范围**：
- 流程文档结构简化，依赖关系更清晰
- 避免重复维护，降低不一致风险

---

### 2024-12-17：新增"设计缺陷修复"变更类型

**修改位置**：`SoloDevFLow2/docs/PRD.md` 元原则1变更规则

**修改原因**：
- 变更规则缺少跨迭代发现问题的处理机制
- 实际开发中经常在迭代N发现迭代M（M<N）的设计问题
- 设计缺陷 ≠ Bug（Bug是代码问题，设计缺陷是文档问题）

**问题场景**：

```
迭代2开发中发现迭代1的问题：
  - 接口设计有问题
  - 业务逻辑/规则有问题
  - 需要改已完成迭代的文档和代码
```

**修改内容**：

变更规则新增一行：

| 变更类型 | 产品PRD | 流程文档 | 迭代PRD | 模块文档 | 代码 |
|----------|---------|----------|---------|----------|------|
| 设计缺陷修复 | 检查 | 检查 | 检查 | 先改 | 后改 |

并添加说明：设计缺陷修复是指在后续迭代中发现已完成模块的设计问题，需先改文档再改代码。

**关键决策**：
- 设计缺陷修复保持Spec First原则（先改文档）
- 需要检查上游文档是否受影响
- 区别于Bug修复（Bug可以直接改代码）

**影响范围**：
- 跨迭代问题有明确的处理流程
- 保持文档与代码的一致性

---

*文档创建时间：2024-12-17*
