# SoloDevFlow 1.0 经验总结

> 为 SoloDevFlow 2.0 设计提供参考

---

## 一、8个痛点

在使用 AI + 流程开发项目的实践中，总结出以下痛点：

| # | 痛点 | 本质 |
|---|------|------|
| 1 | 注意力分散 vs 灵光一闪 | 人类输入非线性，但流程需要线性 |
| 2 | 自然语言 vs 流程指令 | AI 缺乏流程感知，直接响应字面需求 |
| 3 | 变更影响感知缺失 | AI 局部思维，缺乏全局依赖视图 |
| 4 | 文档规范不执行 | 软约束靠 AI 自觉 = 不可靠 |
| 5 | 状态信息过载（人类不可读） | 状态设计没有人类可读视角 |
| 6 | 状态超出 AI 能力 | 状态设计没有考虑 AI 上下文限制 |
| 7 | AI 输出过载 + 结构混乱 | AI 输出没有人类认知友好约束 |
| 8 | 人类输入没有捕获保存 | 决策依据丢失，无法追溯 |

### 痛点详细说明

#### 痛点1：注意力分散 vs 灵光一闪

```
场景：正在开发功能A，人类突然想到功能B有问题
结果：和AI讨论B，回不到A了
矛盾：不能禁止讨论B（灵光一闪可能很重要），但讨论后A的进度丢失
```

#### 痛点2：自然语言 vs 流程指令

```
场景：人类说"我想调整一下之前的需求"
问题：AI 直接开始讨论方案/改代码
应该：先改需求文档 → 再讨论 → 再改代码
本质：AI 不知道当前阶段，直接响应字面需求
```

#### 痛点3：变更影响感知缺失

```
场景：调整需求A，实际影响需求B、C
问题：AI 只关注A，直接改A相关代码
结果：B、C 没有同步更新，产生不一致
```

#### 痛点4：文档规范不执行

```
场景：规范要求文档章节必须有ID
问题：AI 生成文档时没加ID
结果：后续无法做依赖分析
本质：规范靠 AI 自觉执行 = 不可靠
```

#### 痛点5：状态信息过载（人类）

```
场景：人类频繁变更，AI 记录每次零散变更
结果：状态文件数据爆炸，人类无法阅读
```

#### 痛点6：状态超出 AI 能力

```
场景：状态数据持续积累
结果：单文件太大，AI 无法一次读取，需要反复读取
```

#### 痛点7：AI 输出过载

```
场景：AI 设计方案/生成文档
问题：过度设计、内容太多、结构不是"总分"
结果：人类无法快速掌握要点
```

#### 痛点8：人类输入没保存

```
场景：人类在对话中输出需求、想法、决策
问题：散落在对话各处，没有汇总归纳
结果：后续无法追溯"人类当时说了什么"
```

---

## 二、解决方向

| 痛点 | 解决方向 | SoloDevFlow 2.0 机制 |
|------|----------|---------------------|
| 1 | 灵光捕获，不打断流程 | 灵光收集箱 |
| 2 | AI 流程感知，主动引导 | 流程上下文 |
| 3 | 变更前分析影响 | 影响分析 |
| 4 | 工具强制校验 | 校验工具（待实现） |
| 5, 6 | 状态分层设计 | 分层状态（摘要+详情+归档） |
| 7 | 输出结构约束 | 输出规范（总分结构） |
| 8 | 捕获人类输入 | 输入日志 |

---

## 三、SoloDevFlow 1.0 教训

### 教训1：流程设计太重

五阶段流程（Requirements → Architecture → Implementation → Testing → Deployment）对于小迭代太重，审批点太多。

**改进**：简化为 规划 → 设计 → 实现 → 验证

### 教训2：状态设计没考虑人类可读性

state.json 为 AI 设计，人类无法快速了解全局。

**改进**：分层状态（status.md 给人看，state.json 给 AI 用）

### 教训3：规范靠 AI 自觉不可靠

规范写在 CLAUDE.md 里，但 AI 经常不严格执行。

**改进**：关键规范用工具强制校验

### 教训4：没有捕获人类输入

人类的需求、决策分散在对话中，无法追溯。

**改进**：输入日志机制

### 教训5：灵光一闪会打断流程

人类的灵光一闪很重要，但会打断当前任务。

**改进**：灵光收集箱，记录但不打断

---

## 四、工具沉淀

SoloDevFlow 1.0 已实现的工具，可作为 2.0 参考：

### 4.1 状态管理模块

**位置**：`src/state-management/`

**架构**：4层架构
```
API层 (StateManager)
  ↓
Service层 (StateService)
  ↓
Repository层 (StateRepository)
  ↓
IO层 (FileIO)
```

**核心类型**（`types.ts`）：
```typescript
// 状态枚举
type IterationStatus = 'planning' | 'in_progress' | 'completed' | 'deployed';
type PhaseStatus = 'pending' | 'in_progress' | 'approved' | 'completed';
type ModuleStatus = 'pending' | 'in_progress' | 'approved' | 'completed' | ...;

// 核心数据结构
interface State {
  schema_version: string;
  project: ProjectInfo;
  currentIteration: string;
  iterations: Record<string, Iteration>;
  moduleDependencies: ModuleDependencies;
  globalTasks: GlobalTasks;
  changeHistory: Change[];
  settings: Settings;
  metadata: Metadata;
}
```

**可复用点**：
- 状态枚举定义
- 4层架构模式
- 变更历史追踪

---

### 4.2 命令体系模块

**位置**：`src/command-system/`

**核心组件**：
```
cli.ts              - CLI入口
parser.ts           - 命令解析
executor.ts         - 命令执行
registry.ts         - 命令注册
precondition-checker.ts - 前置条件检查
```

**核心类型**（`types.ts`）：
```typescript
// 命令名称
type CommandName =
  | 'init'
  | 'start-requirements'
  | 'start-architecture'
  | 'start-implementation'
  | 'start-testing'
  | 'start-deployment'
  | 'approve'
  | 'rollback'
  | 'status';

// 前置条件类型
type PreconditionType =
  | 'state_not_exists'
  | 'state_exists'
  | 'phase_completed'
  | 'phase_approved'
  | 'phase_in_progress'
  | 'modules_approved'
  | 'custom';

// 命令定义
interface CommandDefinition {
  name: CommandName;
  description: string;
  parameters: ParameterDefinition[];
  preconditions: PreconditionDefinition[];
  handler: (context: CommandContext) => Promise<CommandResult>;
}
```

**可复用点**：
- 命令注册模式
- 前置条件检查机制
- 命令解析逻辑

---

### 4.3 验证器模块

**位置**：`src/validators/`

**核心功能**：
```typescript
// 状态验证
validateStateFile(): ValidationResult
formatValidationResult(result): string

// 引用验证
validateDocumentReferences(): ReferenceValidationResult
formatReferenceValidationResult(result): string
```

**错误类型**：
```typescript
class StateFileNotFoundError extends StateError
class StateFileCorruptedError extends StateError
class StateFieldMissingError extends StateError
```

**可复用点**：
- 验证结果格式化
- 错误类型定义
- 修复建议机制

---

### 4.4 上下文加载器

**位置**：`src/context/`

**核心接口**：
```typescript
// 阶段级上下文
getContextForPhase(phase: Phase): ContextResult

// 模块级上下文
getContextForModule(module: string, phase: Phase): ContextResult

interface ContextResult {
  success: boolean;
  files: string[];           // 需要加载的文件
  templates: string[];       // 需要加载的模板
  stateFields: string[];     // 需要读取的state字段
  description: string;       // 上下文描述
  warnings?: string[];       // 警告
  error?: string;            // 错误
}
```

**可复用点**：
- 按需加载思路
- 上下文裁剪机制

---

## 五、设计决策记录

### 决策1：为什么选择"手动调整"而非"自动学习"

**问题**：自进化机制如何实现？

**选项**：
- A：使用者手动调整规范/工具，系统记录并应用
- B：系统自动学习使用者习惯

**决策**：选择 A

**理由**：
- 自动学习需要大量数据和复杂算法
- 手动调整更可控，不会产生意外行为
- 迭代1聚焦"核心流程可用"，自动学习是后续增强

---

### 决策2：为什么选择分层状态

**问题**：状态如何设计才能人类可读又AI可用？

**决策**：三层结构
- status.md：摘要层（人类看）
- state.json：详情层（AI用）
- history/：归档层（历史）

**理由**：
- 人类和AI的需求不同
- 分层可以各自优化，互不干扰
- 归档层解决数据膨胀问题

---

### 决策3：为什么用"灵光收集箱"而非"禁止打断"

**问题**：如何处理灵光一闪？

**选项**：
- A：禁止讨论与当前任务无关的话题
- B：记录灵光，稍后处理

**决策**：选择 B

**理由**：
- 灵光一闪可能很重要，不能丢失
- 禁止打断会限制人类的创造力
- 记录但不打断是最佳平衡

---

## 六、Decspec 项目经验借鉴

> 来源：Decspec - 自进化的AI结对编程环境（Ouroboros）

### 6.1 核心理念对比

| 理念 | Decspec 实践 | 可借鉴点 |
|------|-------------|----------|
| **Spec First** | YAML规范是真理源，代码是投影 | 强化文档驱动开发 |
| **Serial Flow** | 串行对话流，避免并行任务混乱 | 简化工作流，聚焦当前任务 |
| **Layered Knowledge** | L-1→L0→L1→L2知识层级 | 分层状态设计的理论支撑 |
| **Recursive Evolution** | 用自己开发自己（Ouroboros） | 自举机制的验证 |

---

### 6.2 Meta-Schema 驱动验证

**Decspec的做法**：

```
sub_meta_schema.yaml（宪法）
  ↓ 定义规则
YAML规范文件（产品/领域/功能/组件）
  ↓ 驱动生成
Python代码
  ↓ 持续验证
meta_schema_validator.py
```

**关键机制**：
- `sub_meta_schema.yaml` 定义 YAML 必须遵循的结构
- 所有 YAML 文件生成前必须经过 meta-schema 验证
- 验证失败阻断生成流程

**可借鉴点**：
- SoloDevFlow 2.0 可以引入 `state-meta-schema.json`
- 定义 state.json 必须遵循的结构规则
- 工具强制校验，避免规范靠 AI 自觉

---

### 6.3 四层知识架构

**Decspec的层级设计**：

```
L-1: Product Layer（产品愿景）
  ├─ 产品定位、核心价值、演进路线图
  └─ 文件：product_spec.yaml

L0: Domain Layer（领域架构）
  ├─ 领域划分、模块职责、技术选型
  └─ 文件：6个领域的 domain_spec.yaml

L1: Feature Layer（功能设计）
  ├─ 功能需求、用户故事、验收标准
  └─ 文件：feature_spec.yaml

L2: Component Layer（组件实现）
  ├─ 接口定义、实现细节、测试用例
  └─ 文件：component_spec.yaml
```

**对应关系**：

| Decspec 层级 | SoloDevFlow 阶段 |
|--------------|------------------|
| L-1 Product | 产品PRD |
| L0 Domain | 系统架构总览 |
| L1 Feature | 模块PRD |
| L2 Component | 模块架构 + 实现 |

**可借鉴点**：
- 明确四层的职责边界
- L-1 和 L0 是全局视角，L1 和 L2 是局部视角
- 上层变更必须追溯到下层影响（影响分析机制）

---

### 6.4 Design vs Substrate 分离

**Decspec的哲学**：

```
Design（设计层）
  - Why：为什么要做
  - What：做什么
  - 文件：*_design_*.yaml

Substrate（基础设施层）
  - How：怎么做
  - Constraints：约束条件
  - 文件：*_substrate_*.yaml
```

**实践案例**：
```yaml
# feature_design_xxx.yaml
why: "用户需要快速查看项目状态"
what: "提供一个简洁的状态仪表板"

# feature_substrate_xxx.yaml
how: "使用Markdown表格 + Git历史分析"
constraints:
  - token_limit: "单次加载不超过5000 tokens"
  - update_frequency: "每次状态变更后同步更新"
```

**可借鉴点**：
- SoloDevFlow 的 PRD 可以分为 Design 和 Substrate
- PRD-Design：业务需求、用户故事
- PRD-Substrate：技术约束、实现路径

---

### 6.5 五阶段对话式需求收集

**Decspec的流程**：

```
阶段1：产品愿景澄清
  - AI提问：产品定位？目标用户？核心价值？
  - 人类回答 → 生成 product_spec.yaml

阶段2：领域拆分澄清
  - AI提问：有哪些领域？每个领域职责？
  - 人类回答 → 生成 domain_spec.yaml

阶段3：功能需求澄清
  - AI提问：每个领域有哪些功能？用户故事？
  - 人类回答 → 生成 feature_spec.yaml

阶段4：组件设计澄清
  - AI提问：每个功能如何实现？接口定义？
  - 人类回答 → 生成 component_spec.yaml

阶段5：依赖关系澄清
  - AI分析：组件间依赖、跨域集成
  - 人类确认 → 更新 dependencies
```

**对话规则**：
- AI 严格按阶段提问，不跳过
- 人类回答不完整时，AI 追问直到澄清
- 每个阶段结束生成对应 YAML，等待审批

**可借鉴点**：
- SoloDevFlow 2.0 的 Requirements 阶段可以细化为多个子阶段
- 强化 AI 的提问能力，不要被动等待
- 每个子阶段有明确的产物（文档）

---

### 6.6 Token 优化策略

**Decspec的实践**：

```
优化前：
  - 每次会话加载全部 YAML（~25000 tokens）
  - AI 需要读取所有层级才能工作

优化后：
  - 按需加载上下文（L-1 → L0 → L1 → L2）
  - 只加载当前任务相关的层级
  - Token消耗减少 55%

实现方式：
  - context_loader.py：按层级加载
  - query_graph.py：知识图谱查询
  - 缓存机制：同一会话内复用加载结果
```

**对应到 SoloDevFlow**：

| Decspec | SoloDevFlow 等价物 | 加载策略 |
|---------|-------------------|----------|
| L-1 Product | 产品PRD | 项目启动时加载 |
| L0 Domain | 系统架构总览 | 架构阶段加载 |
| L1 Feature | 模块PRD | 实现该模块时加载 |
| L2 Component | 模块架构 | 实现该模块时加载 |

**可借鉴点**：
- SoloDevFlow 已有上下文加载器（context:phase / context:module）
- 可以进一步细化为 L-1 到 L2 的层级加载
- 引入缓存机制，避免重复读取

---

### 6.7 持续验证与可视化仪表板

**Decspec的做法**：

```
PRODUCT_DASHBOARD.md（自动生成）
  ├─ 项目状态概览
  ├─ 各层级完成度（L-1 ~ L2）
  ├─ 验证结果（通过/失败）
  ├─ 最近变更历史
  └─ 下一步建议

生成时机：
  - 每次 YAML 文件变更后
  - 每次 Git commit 后
  - 手动执行 validate:all 后
```

**验证维度**：
- Meta-schema 验证：YAML 结构是否符合规范
- 引用验证：跨文件引用是否有效
- 依赖验证：组件依赖关系是否完整
- 测试验证：测试覆盖率是否达标

**可借鉴点**：
- SoloDevFlow 2.0 可以生成 `.flow/dashboard.md`
- 整合 status.md 的摘要层 + state.json 的详情层
- 添加验证结果可视化
- 提供"下一步建议"（基于当前状态）

---

### 6.8 Decspec 遇到的痛点与解决方案

#### 痛点1：YAML 文件过多，人类难以定位

**问题**：238,580 行代码，数百个 YAML 文件

**解决方案**：
- 引入知识图谱（query_graph.py）
- 提供 AI 查询接口（`query_component("用户认证")`）
- 自动生成索引文件（index.yaml）

#### 痛点2：AI 生成 YAML 格式不一致

**问题**：AI 自由发挥，导致 YAML 风格混乱

**解决方案**：
- 定义严格的 YAML 生成规范（yaml_generation_standards.md）
- 强制要求：缩进、引号、注释格式
- 生成后立即验证，不合规则重新生成

#### 痛点3：规范文档与代码不同步

**问题**：代码改了，YAML 没更新

**解决方案**：
- Spec First：YAML 是真理源，代码是投影
- 禁止直接改代码，必须先改 YAML
- Git hook 强制检查：代码变更必须关联 YAML commit

#### 痛点4：串行对话流被打断

**问题**：人类在阶段2时突然想讨论阶段4的问题

**解决方案**：
- AI 识别"跨阶段提问"
- 记录到 spark_box（灵光收集箱）
- 告知人类："已记录，当前继续阶段2"

---

### 6.9 可直接借鉴的模式

| Decspec 模式 | SoloDevFlow 2.0 应用 |
|--------------|---------------------|
| **Meta-schema 验证** | 定义 state-meta-schema.json，验证 state.json |
| **四层知识架构** | 明确 PRD/架构/实现/测试 的层级关系 |
| **Design vs Substrate** | PRD 分为 Design 和 Substrate 两部分 |
| **对话式需求收集** | Requirements 阶段细化为多轮提问 |
| **按需加载上下文** | 细化为 L-1~L2 层级加载 |
| **持续验证仪表板** | 生成 `.flow/dashboard.md` |
| **灵光收集箱** | 已在迭代1-PRD中定义，直接复用 Decspec 实践 |
| **Spec First 哲学** | 强化文档驱动，代码是投影 |

---

### 6.10 不建议借鉴的点

| Decspec 做法 | 原因 | SoloDevFlow 替代方案 |
|--------------|------|---------------------|
| **YAML 作为规范格式** | 对人类不够友好，嵌套复杂 | 使用 Markdown（人类可读） + JSON（机器可读） |
| **过度细化的层级** | L-1~L2 四层可能过重 | 简化为两层（全局/模块） |
| **Python 代码生成** | 需要额外的代码生成器 | 直接编写代码，AI 辅助生成 |

---

*文档版本：v1.0*
*创建时间：2024-12-16*
*最后更新：2024-12-16（新增第六节 Decspec 经验）*
