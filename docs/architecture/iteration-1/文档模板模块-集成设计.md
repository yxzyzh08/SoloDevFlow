# 文档模板模块 - 集成设计

<!--
章节ID规范说明：
- 格式：{#arch-文档模板-[章节标识]}
- 必须标注ID的章节：接口定义、集成点
- 示例：{#arch-文档模板-集成接口} 表示文档模板模块集成设计的集成接口章节
-->

> **项目**: AI超级个体开发助手
> **版本**: v1.0.0
> **迭代**: Iteration 1
> **模块**: 文档模板模块
> **日期**: 2025-12-15

---

## 一、集成概述

### 1.1 模块依赖关系

```
                    ┌─────────────────────┐
                    │    核心流程模型      │
                    │  (Core Process)     │
                    └──────────┬──────────┘
                               │ 阶段定义
                               ↓
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  ┌─────────────┐        ┌─────────────────────┐        │
│  │ 状态管理模块 │←─读取─→│    文档模板模块      │        │
│  │  (State)    │ 变量值  │  (Document Template) │        │
│  └─────────────┘        └──────────┬──────────┘        │
│                                    │                    │
│                    ┌───────────────┼───────────────┐   │
│                    ↓               ↓               ↓   │
│  ┌─────────────┐   ┌─────────────┐ ┌─────────────┐    │
│  │ 命令体系模块 │   │ 影响分析模块 │ │ 测试验证模块 │    │
│  │  (Command)  │   │  (Impact)   │ │   (Test)    │    │
│  └─────────────┘   └─────────────┘ └─────────────┘    │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 1.2 依赖方向

| 关系类型 | 模块 | 说明 |
|---------|------|------|
| **依赖** | 状态管理模块 | 读取state.json获取变量���和模板版本 |
| **依赖** | 核心流程模型 | 理解阶段划分和文档类型 |
| **被依赖** | 命令体系模块 | 调用模板填充和验证功能 |
| **被依赖** | 影响分析模块 | 获取文档引用图谱 |
| **被依赖** | 测试验证模块 | 验证测试文档完整性 |

---

## 二、对外接口定义 {#arch-文档模板-集成接口}

### 2.1 验证接口（stage1核心）⭐

```typescript
/**
 * 文档验证器接口
 * 提供给其他模块调用的验证能力
 */
export interface IDocumentValidator {
  /**
   * 验证所有文档引用
   * 实现 PRD 4.4.4
   * @returns 验证结果，包含有效引用、断链、缺失ID等
   */
  validateDocumentReferences(): Promise<ReferenceValidationResult>;

  /**
   * 扫描所有引用
   * @returns 所有文档引用列表
   */
  scanAllReferences(): Promise<DocumentReference[]>;

  /**
   * 检查章节ID覆盖
   * @returns 缺失ID的章节列表
   */
  checkSectionIdCoverage(): Promise<SectionInfo[]>;

  /**
   * 验证单个文档
   * @param filePath 文档路径
   * @returns 单文档验证结果
   */
  validateDocument(filePath: string): Promise<DocumentValidationResult>;

  /**
   * 获取引用图谱
   * @returns 文档间引用关系图谱
   */
  getReferenceGraph(): Promise<DocumentReferenceGraph>;
}
```

### 2.2 模板接口

```typescript
/**
 * 模板管理器接口
 * 提供模板加载和填充能力
 */
export interface ITemplateManager {
  /**
   * 获取模板
   * @param type 模板类型
   * @param name 模板名称
   * @returns 模板对象
   */
  getTemplate(type: TemplateType, name: string): Promise<Template>;

  /**
   * 列出所有模板
   * @param type 可选，按类型筛选
   * @returns 模板信息列表
   */
  listTemplates(type?: TemplateType): Promise<TemplateInfo[]>;

  /**
   * 填充模板
   * @param template 模板对象
   * @param variables 变量值
   * @returns 填充后的模板
   */
  fillTemplate(
    template: Template,
    variables: Record<string, string>
  ): Promise<FilledTemplate>;

  /**
   * 解析变量值
   * @param variableNames 变量名列表
   * @returns 变量值映射
   */
  resolveVariables(variableNames: string[]): Promise<Record<string, string>>;
}
```

### 2.3 版本管理接口

```typescript
/**
 * 模板版本管理接口
 */
export interface ITemplateVersionManager {
  /**
   * 获取当前模板版本
   * @returns 各类型模板的版本号
   */
  getTemplateVersions(): Promise<TemplateVersions>;

  /**
   * 检查模板升级
   * @returns 升级检查结果
   */
  checkTemplateUpgrade(): Promise<UpgradeCheck>;
}
```

---

## 三、���赖接口调用

### 3.1 状态管理模块接口调用

文档模板模块需要调用状态管理模块的以下接口：

```typescript
/**
 * 从状态管理模块导入的接口
 */
import { StateManager } from '@/state-management';

/**
 * 调用示例
 */
class VariableService {
  constructor(private stateManager: StateManager) {}

  /**
   * 解析变量值
   */
  async resolve(variableNames: string[]): Promise<Record<string, string>> {
    const result: Record<string, string> = {};
    const state = await this.stateManager.readState();

    for (const name of variableNames) {
      switch (name) {
        case '项目名称':
          result[name] = state.project.name;
          break;
        case '项目描述':
          result[name] = state.project.description;
          break;
        case '版本号':
          result[name] = state.iterations[state.currentIteration].version;
          break;
        case '迭代':
          result[name] = state.currentIteration;
          break;
        // ... 其他变量
      }
    }

    return result;
  }
}
```

**调用的状态管理模块接口**：

| 接口 | 用途 | 调用时机 |
|------|------|----------|
| `readState()` | 读取state.json获取变量值 | 模板填充时 |
| `getTemplateVersions()` | 读取模板版本号 | 版本检查时 |

### 3.2 核心流程模型接口调用

```typescript
/**
 * 从核心流程模型导入的接口
 */
import { CoreProcessModel } from '@/core-process';

/**
 * 调用示例
 */
class ValidationService {
  constructor(private coreProcess: CoreProcessModel) {}

  /**
   * 获取阶段对应的文档类型
   */
  getDocumentTypeForPhase(phase: string): DocumentType {
    const phaseDef = this.coreProcess.getPhaseDefinition(phase);
    return phaseDef.documentType as DocumentType;
  }
}
```

---

## 四、被调用场景

### 4.1 命令体系模块调用

**场景1：文档生成命令**

```typescript
// 命令体系模块代码
class StartRequirementsCommand {
  constructor(private templateManager: ITemplateManager) {}

  async execute(): Promise<void> {
    // 1. 获取PRD模板
    const template = await this.templateManager.getTemplate('prd', 'PRD-backend-template');

    // 2. 解析变量
    const variables = await this.templateManager.resolveVariables([
      '项目名称', '版本号', '迭代'
    ]);

    // 3. 填充模板
    const filled = await this.templateManager.fillTemplate(template, variables);

    // 4. 保存文档
    // ...
  }
}
```

**场景2：文档验证命令**

```typescript
// 命令体系模块代码
class ValidateDocsCommand {
  constructor(private validator: IDocumentValidator) {}

  async execute(): Promise<void> {
    // 执行全量验证
    const result = await this.validator.validateDocumentReferences();

    // 处理结果
    if (result.brokenFile.length > 0 || result.brokenSection.length > 0) {
      // 报告错误
      console.error('文档验证失败');
      for (const broken of result.brokenFile) {
        console.error(`  文件不存在: ${broken.targetFile}`);
        console.error(`    引用位置: ${broken.sourceFile}:${broken.sourceLine}`);
      }
    }

    if (result.missingId.length > 0) {
      // 报告警告
      console.warn('以下章节缺少ID:');
      for (const missing of result.missingId) {
        console.warn(`  ${missing.file}: ${missing.sectionName}`);
        console.warn(`    建议ID: ${missing.requiredId}`);
      }
    }
  }
}
```

### 4.2 影响分析模块调用

```typescript
// 影响分析模块代码
class ImpactAnalyzer {
  constructor(private validator: IDocumentValidator) {}

  /**
   * 分析文档变更影响
   */
  async analyzeDocumentImpact(changedFile: string): Promise<ImpactReport> {
    // 获取引用图谱
    const graph = await this.validator.getReferenceGraph();

    // 找出所有引用了变更文档的文档
    const impacted = graph[changedFile]?.referencedBy || [];

    return {
      changedFile,
      directlyImpacted: impacted,
      indirectlyImpacted: await this.findIndirectImpact(impacted, graph)
    };
  }
}
```

### 4.3 阶段启动前验证

```typescript
// 命令体系模块代码
class PhaseTransitionCommand {
  constructor(
    private validator: IDocumentValidator,
    private stateManager: StateManager
  ) {}

  async execute(targetPhase: string): Promise<void> {
    // 阶段启动前验证前置文档
    const result = await this.validator.validateDocumentReferences();

    // 只检查目标阶段依赖的文档
    const relevantBroken = this.filterByPhase(result.brokenFile, targetPhase);

    if (relevantBroken.length > 0) {
      throw new Error('前置文档引用验证失败，无法进入下一阶段');
    }

    // 继续阶段流转
    await this.stateManager.transitionPhase(targetPhase);
  }
}
```

---

## 五、集成点详细定义 {#arch-文档模板-集成点}

### 5.1 与状态管理模块的集成点

```typescript
/**
 * 集成点1：读取变量值
 */
interface Integration_ReadVariables {
  /** 调用方 */
  caller: '文档模板模块.VariableService';

  /** 被调用方 */
  callee: '状态管理模块.StateManager';

  /** 接口 */
  interface: 'readState(): Promise<State>';

  /** 数据流 */
  dataFlow: '-> State (project, iterations, currentIteration)';

  /** 调用时机 */
  timing: '模板填充时解析变量';

  /** 错误处理 */
  errorHandling: 'StateFileNotFoundError -> 提示用户初始化项目';
}

/**
 * 集成点2：更新引用图谱
 */
interface Integration_UpdateReferenceGraph {
  /** 调用方 */
  caller: '文档模板模块.ValidationService';

  /** 被调用方 */
  callee: '状态管理模块.StateManager';

  /** 接口 */
  interface: 'updateDocumentReferences(graph): Promise<void>';

  /** 数据流 */
  dataFlow: 'DocumentReferenceGraph -> state.json.documentReferences';

  /** 调用时机 */
  timing: '验证完成后更新引用图谱';

  /** 错误处理 */
  errorHandling: 'WriteError -> 记录日志，不阻断主流程';
}
```

### 5.2 与命令体系模块的集成点

```typescript
/**
 * 集成点3：模板填充
 */
interface Integration_FillTemplate {
  /** 调用方 */
  caller: '命令体系模块./start-* 命令';

  /** 被调用方 */
  callee: '文档模板模块.TemplateManager';

  /** 接口 */
  interface: 'getTemplate() + fillTemplate()';

  /** 数据流 */
  dataFlow: 'TemplateType + variables -> FilledTemplate';

  /** 调用时机 */
  timing: '各阶段启动命令执行时';

  /** 错误处理 */
  errorHandling: 'TemplateNotFoundError -> 中止命令，提示检查模板';
}

/**
 * 集成点4：文档验证
 */
interface Integration_ValidateDocs {
  /** 调用方 */
  caller: '命令体系模块./validate-docs 命令';

  /** 被调用方 */
  callee: '文档模板模块.TemplateManager';

  /** 接口 */
  interface: 'validateDocumentReferences()';

  /** 数据流 */
  dataFlow: '-> ReferenceValidationResult';

  /** 调用时机 */
  timing: '用户执行 /validate-docs 命令';

  /** 错误处理 */
  errorHandling: '验证失败 -> 返回详细错误列表';
}

/**
 * 集成点5：自动验证
 */
interface Integration_AutoValidate {
  /** 调用方 */
  caller: '命令体系模块（文档生成后Hook）';

  /** 被调用方 */
  callee: '文档模板模块.TemplateManager';

  /** 接口 */
  interface: 'validateDocument(filePath)';

  /** 数据流 */
  dataFlow: 'filePath -> DocumentValidationResult';

  /** 调用时机 */
  timing: 'AI完成文档生成后自动执行';

  /** 错误处理 */
  errorHandling: 'brokenFile/brokenSection -> 阻止提交; missingId -> 警告';
}
```

### 5.3 与影响分析模块的集成点

```typescript
/**
 * 集成点6：获取引用图谱
 */
interface Integration_GetReferenceGraph {
  /** 调用方 */
  caller: '影响分析模块.ImpactAnalyzer';

  /** 被调用方 */
  callee: '文档模板模块.TemplateManager';

  /** 接口 */
  interface: 'getReferenceGraph(): Promise<DocumentReferenceGraph>';

  /** 数据流 */
  dataFlow: '-> DocumentReferenceGraph';

  /** 调用时机 */
  timing: '分析文档变更影响时';

  /** 错误处理 */
  errorHandling: '图谱不存在 -> 先执行全量验证生成图谱';
}
```

---

## 六、集成流程图

### 6.1 文档生成集成流程

```
用户执行 /start-requirements
  ↓
【命令体系模块】解析命令
  ↓
【命令体系模块】调用文档模板模块
  │
  ├──→ getTemplate('prd', 'PRD-backend-template')
  │       ↓
  │     【文档模板模块】读取模板文件
  │       ↓
  │     返回 Template 对象
  │
  ├──→ resolveVariables(['项目名称', '版本号', ...])
  │       ↓
  │     【文档模板模块】调用状态管理模块
  │       │
  │       └──→ readState()
  │              ↓
  │            【状态管理模块】返回 State
  │       ↓
  │     返回 变量值映射
  │
  └──→ fillTemplate(template, variables)
          ↓
        【文档模板模块】替换变量占位符
          ↓
        返回 FilledTemplate
  ↓
【命令体系模块】AI继续填充内容
  ↓
【命令体系模块】保存文档
  ↓
【命令体系模块】调用文档模板模块验证
  │
  └──→ validateDocument(filePath)
          ↓
        【文档模板模块】解析引用和章节ID
          ↓
        【文档模板模块】执行验证规则
          ↓
        返回 DocumentValidationResult
  ↓
【命令体系模块】根据验证结果决定下一步
  ├─ errors -> 提示修复
  └─ warnings -> 提示但继续
```

### 6.2 全量验证集成流程

```
用户执行 /validate-docs
  ↓
【命令体系模块】解析命令
  ↓
【命令体系模块】调用文档模板模块
  │
  └──→ validateDocumentReferences()
          ↓
        【文档模板模块】获取所有文档路径
          ↓
        【文档模板模块】并行解析所有文档
          │
          ├──→ ReferenceParser.parse()
          │       ↓
          │     提取所有引用
          │
          └──→ SectionIdParser.parse()
                  ↓
                提取所有章节ID
          ↓
        【文档模板模块】执行5条验证规则
          │
          ├─ 规则1: 文件存在性
          ├─ 规则2: 章节ID存在性
          ├─ 规则3: 必须章节ID
          ├─ 规则4: 内容一致性
          └─ 规则5: ID唯一性
          ↓
        返回 ReferenceValidationResult
  ↓
【命令体系模块】格式化输出结果
  │
  ├─ brokenFile/brokenSection/duplicateId
  │     ↓
  │   输出错误（红色）
  │
  └─ missingId/inconsistent
        ↓
      输出警告（黄色）
  ↓
【命令体系模块】调用文档模板模块更新引用图谱
  │
  └──→ updateReferenceGraph()
          ↓
        【文档模板模块】调用状态管理模块
          │
          └──→ 更新 state.json.documentReferences
          ↓
        返回成功
```

---

## 七、错误处理与恢复

### 7.1 错误分级

| 错误类型 | 严重程度 | 处理方式 | 用户提示 |
|---------|---------|---------|---------|
| TemplateNotFoundError | 阻断 | 中止操作 | "模板文件不存在，请检查 .solodev/templates/" |
| StateFileNotFoundError | 阻断 | 中止操作 | "state.json不存在，请执行项目初始化" |
| brokenFile | 阻断 | 阻止提交 | "引用的文件不存在：[路径]" |
| brokenSection | 阻断 | 阻止提交 | "引用的章节ID不存在：[ID]" |
| duplicateId | 阻断 | 阻止提交 | "章节ID重复：[ID] 出现在 [位置列表]" |
| missingId | 警告 | 允许继续 | "以下章节缺少ID：[列表]" |
| inconsistent | 警告 | 允许继续 | "内容不一致：[描述]" |

### 7.2 重试策略

```typescript
/**
 * 文件读取重试
 */
const FILE_READ_RETRY_CONFIG = {
  maxRetries: 3,
  retryDelay: 100, // ms
  backoffMultiplier: 2
};

/**
 * 带重试的文件读取
 */
async function readWithRetry(filePath: string): Promise<string> {
  let lastError: Error | null = null;

  for (let i = 0; i < FILE_READ_RETRY_CONFIG.maxRetries; i++) {
    try {
      return await fs.promises.readFile(filePath, 'utf-8');
    } catch (error) {
      lastError = error as Error;
      await sleep(FILE_READ_RETRY_CONFIG.retryDelay * Math.pow(
        FILE_READ_RETRY_CONFIG.backoffMultiplier,
        i
      ));
    }
  }

  throw lastError;
}
```

---

## 八、性能考虑

### 8.1 缓存策略

```typescript
/**
 * 文档缓存
 * 使用LRU策略，最多缓存10个文档
 */
class DocumentCache {
  private cache = new Map<string, CacheEntry>();
  private readonly MAX_SIZE = 10;

  get(filePath: string): string | null {
    const entry = this.cache.get(filePath);
    if (entry && Date.now() - entry.timestamp < 5000) {
      return entry.content;
    }
    return null;
  }

  set(filePath: string, content: string): void {
    if (this.cache.size >= this.MAX_SIZE) {
      // 删除最旧的条目
      const oldest = [...this.cache.entries()]
        .sort((a, b) => a[1].timestamp - b[1].timestamp)[0];
      this.cache.delete(oldest[0]);
    }
    this.cache.set(filePath, { content, timestamp: Date.now() });
  }
}
```

### 8.2 并行处理

```typescript
/**
 * 并行扫描所有文档
 */
async function scanAllDocuments(paths: string[]): Promise<ScanResult[]> {
  // 并行度限制为10
  const CONCURRENCY = 10;
  const results: ScanResult[] = [];

  for (let i = 0; i < paths.length; i += CONCURRENCY) {
    const batch = paths.slice(i, i + CONCURRENCY);
    const batchResults = await Promise.all(
      batch.map(path => scanDocument(path))
    );
    results.push(...batchResults);
  }

  return results;
}
```

---

## 九、集成测试要点

### 9.1 集成测试场景

| 场景 | 测试内容 | 验证点 |
|------|---------|--------|
| 模板填充 | 命令模块调用模板填充 | 变量正确替换 |
| 全量验证 | 命令模块调用全量验证 | 5条规则全部执行 |
| 自动验证 | 文档生成后自动验证 | 错误正确分类 |
| 引用图谱 | 影响分析调用获取图谱 | 图谱数据正确 |
| 状态读取 | 模板模块读取state.json | 变量值正确 |

### 9.2 集成测试示例

```typescript
describe('文档模板模块集成测试', () => {
  describe('与状态管理模块集成', () => {
    it('should resolve variables from state.json', async () => {
      // Arrange
      const stateManager = new StateManager(/* ... */);
      const templateManager = new TemplateManager(stateManager, /* ... */);

      // Act
      const variables = await templateManager.resolveVariables([
        '项目名称', '版本号'
      ]);

      // Assert
      expect(variables['项目名称']).toBe('AI超级个体开发助手');
      expect(variables['版本号']).toBe('v1.0.0');
    });
  });

  describe('与命令体系模块集成', () => {
    it('should validate document after generation', async () => {
      // Arrange
      const templateManager = new TemplateManager(/* ... */);
      const command = new StartRequirementsCommand(templateManager);

      // Act
      await command.execute();

      // Assert
      const result = await templateManager.validateDocument(
        'docs/PRD/PRD.md'
      );
      expect(result.isValid).toBe(true);
    });
  });
});
```

---

## 十、版本兼容性

### 10.1 接口版本

```typescript
/**
 * 接口版本定义
 */
const INTERFACE_VERSION = {
  /** 验证接口版本 */
  validator: '1.0.0',

  /** 模板接口版本 */
  template: '1.0.0',

  /** 版本管理接口版本 */
  version: '1.0.0'
};
```

### 10.2 向后兼容承诺

- **v1.x**: 保持接口签名不变
- **新增功能**: 使用可选参数
- **废弃接口**: 标记为@deprecated，保留2个迭代周期

---

## 十一、总结

### 11.1 核心集成点

| 集成点 | 调用方 | 被调用方 | stage1必需 |
|--------|--------|---------|-----------|
| 读取变量值 | 文档模板模块 | 状态管理模块 | ✅ |
| 模板填充 | 命令体系模块 | 文档模板模块 | ✅ |
| 文档验证 | 命令体系模块 | 文档模板模块 | ✅ |
| 引用图谱 | 影响分析模块 | 文档模板模块 | ❌ |

### 11.2 关键成功因素

1. **接口稳定**: 对外接口遵循语义化版本
2. **错误分级**: 清晰区分阻断错误和警告
3. **性能优化**: 缓存和并行处理
4. **测试覆盖**: 集成测试覆盖核心场景
