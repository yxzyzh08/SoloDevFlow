# 状态管理模块 - 系统架构总览

<!--
章节ID规范说明：
- 格式：{#arch-状态管理-[章节标识]}
- 必须标注ID的章节：模块划分、核心流程、对外接口
- 示例：{#arch-状态管理-目录结构} 表示状态管理模块系统架构的目录结构章节
-->

> **项目**: AI超级个体开发助手
> **版本**: v1.0.0
> **迭代**: Iteration 1
> **模块**: 状态管理模块
> **日期**: 2025-12-14

---

## 一、架构概述

### 1.1 模块定位

状态管理模块是整个系统的**数据中枢(Data Hub)**，负责管理项目的唯一状态真相来源(Single Source of Truth)：

```
┌─────────────────────────────────────────────────────┐
│              用户交互层(User Interface)              │
│  ───────────────────────────────────────────────── │
│  Slash Commands: /start-requirements, /approve ...  │
└───────────────────────┬─────────────────────────────┘
                        ↓ 触发命令
┌─────────────────────────────────────────────────────┐
│           命令体系模块(Command System)               │
│  ───────────────────────────────────────────────── │
│  解析命令 → 调用状态管理模块 → 执行业务逻辑         │
└───────────────────────┬─────────────────────────────┘
                        ↓ 读写状态
┌─────────────────────────────────────────────────────┐
│     【状态管理模块】(State Management Module)        │
│  ═══════════════════════════════════════════════   │
│  ┌─────────────────────────────────────────────┐   │
│  │  API层(Public Interface)                    │   │
│  │  ─────────────────────────────────────────  │   │
│  │  · readState() / writeState()               │   │
│  │  · updateModuleStatus() / updatePhaseStatus()│   │
│  │  · transitionPhase() / approvePhase()       │   │
│  └─────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────┐   │
│  │  Service层(Business Logic)                  │   │
│  │  ─────────────────────────────────────────  │   │
│  │  · StateService: 状态流转逻辑               │   │
│  │  · MigrationService: 迭代迁移逻辑           │   │
│  │  · HistoryService: 历史数据访问逻辑         │   │
│  └─────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────┐   │
│  │  Repository层(Data Access)                  │   │
│  │  ─────────────────────────────────────────  │   │
│  │  · StateRepository: state.json读写          │   │
│  │  · HistoryRepository: state_his.json读写    │   │
│  └─────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────┐   │
│  │  IO层(File System)                          │   │
│  │  ─────────────────────────────────────────  │   │
│  │  · FileIO: JSON文件读写                     │   │
│  │  · Backup: Git集成备份                      │   │
│  └─────────────────────────────────────────────┘   │
└───────────────────────┬─────────────────────────────┘
                        ↓ 依赖规则
┌─────────────────────────────────────────────────────┐
│      【核心流程模型】(Core Process Model)           │
│  ───────────────────────────────────────────────── │
│  提供: 阶段定义、验证规则、状态流转约束            │
└─────────────────────────────────────────────────────┘
                        ↓ 数据持久化
┌─────────────────────────────────────────────────────┐
│            数据持久化层(Data Persistence)            │
│  ───────────────────────────────────────────────── │
│  .solodev/state.json, .solodev/state_his.json      │
└─────────────────────────────────────────────────────┘
```

### 1.2 核心职责

**状态管理模块是"数据守护者"，不是"业务决策者"**：

| 职责类别 | 具体内容 | 非职责(由其他模块负责) |
|---------|---------|----------------------|
| **状态读写** | 提供统一的state.json读写接口 | ❌ 不负责定义阶段规则 |
| **状态验证** | 调用核心流程模型验证状态一致性 | ❌ 不负责实现验证逻辑 |
| **历史迁移** | 迭代完成后迁移到state_his.json | ❌ 不负责决定何时迭代完成 |
| **历史访问** | 智能判断何时读取历史数据 | ❌ 不负责分析历史趋势 |
| **变更记录** | 自动维护changeHistory | ❌ 不负责影响分析 |

### 1.3 架构特点

#### 特点1：分层架构(Layered Architecture)

**设计理念**：职责分离，每层只关心自己的事

```typescript
// 层次关系
API层 → 对外暴露接口，参数校验
  ↓
Service层 → 业务逻辑，事务管理
  ↓
Repository层 → 数据访问抽象，缓存管理
  ↓
IO层 → 文件系统操作，备份
```

**优势**：
- 每层可独立测试
- 易于替换实现（如从文件切换到数据库）
- 关注点分离，代码清晰

#### 特点2：事件驱动的变更记录

**设计理念**：每次状态变更自动记录到changeHistory

```typescript
// ❌ 手动记录变更（容易遗漏）
function updateModuleStatus(moduleName: string, newStatus: ModuleStatus) {
  state.modules[moduleName].status = newStatus;
  // 容易忘记记录changeHistory
}

// ✅ 自动记录变更（通过拦截器）
class StateService {
  private recordChange(description: string, changes: Change[]): void {
    this.state.changeHistory.push({
      timestamp: new Date().toISOString(),
      type: this.inferChangeType(changes),
      description,
      changedBy: 'ai',
      changes
    });
  }

  updateModuleStatus(moduleName: string, newStatus: ModuleStatus): void {
    const oldStatus = this.getModuleStatus(moduleName);

    // 更新状态
    this.state.modules[moduleName].status = newStatus;

    // 自动记录变更
    this.recordChange(
      `模块${moduleName}状态从${oldStatus}变更为${newStatus}`,
      [{ field: `modules.${moduleName}.status`, from: oldStatus, to: newStatus }]
    );
  }
}
```

**优势**：
- 变更记录不会遗漏
- 与核心流程模型11.4节设计一致
- 便于审计和回溯

#### 特点3：读写分离与缓存

**设计理念**：读操作使用缓存，写操作清除缓存

```typescript
class StateRepository {
  private cache: State | null = null;
  private cacheTimestamp: number = 0;
  private readonly CACHE_TTL = 5000; // 5秒缓存

  async read(): Promise<State> {
    // 缓存命中
    if (this.cache && Date.now() - this.cacheTimestamp < this.CACHE_TTL) {
      return this.cache;
    }

    // 缓存未命中，从文件读取
    const state = await this.fileIO.readJSON('.solodev/state.json');
    this.cache = state;
    this.cacheTimestamp = Date.now();
    return state;
  }

  async write(state: State): Promise<void> {
    await this.fileIO.writeJSON('.solodev/state.json', state);

    // 写入后更新缓存
    this.cache = state;
    this.cacheTimestamp = Date.now();
  }
}
```

**优势**：
- 减少文件IO次数
- 保证读写一致性
- TTL机制防止脏读

#### 特点4：原子性写入

**设计理念**：状态更新要么完全成功，要么完全失败

```typescript
class StateService {
  async transitionPhase(targetPhase: string): Promise<TransitionResult> {
    // 1. 读取当前状态
    const state = await this.repository.read();
    const currentPhase = state.iterations[state.currentIteration].currentPhase;

    // 2. 验证流转合法性（调用核心流程模型）
    const validation = this.coreProcess.validatePhaseTransition(currentPhase, targetPhase);
    if (!validation.isValid) {
      return { success: false, errors: validation.errors };
    }

    // 3. 构建新状态（不直接修改原状态）
    const newState = this.buildNewState(state, currentPhase, targetPhase);

    // 4. 验证新状态完整性
    const integrityCheck = this.coreProcess.validateStateIntegrity(newState);
    if (!integrityCheck.isValid) {
      return { success: false, errors: integrityCheck.errors };
    }

    // 5. 原子性写入
    await this.repository.write(newState);

    return { success: true, newPhase: targetPhase };
  }
}
```

**优势**：
- 避免部分更新导致的不一致
- 验证失败不影响原状态
- 支持事务性操作

### 1.4 关键设计决策

| 决策点 | 选择 | 理由 | 替代方案 |
|--------|------|------|---------|
| **架构模式** | 分层架构 | 职责清晰，易测试，易维护 | 单体类（难以测试和维护） |
| **数据访问** | Repository模式 | 屏蔽存储细节，便于替换 | 直接文件操作（耦合严重） |
| **变更记录** | 自动记录(拦截器模式) | 不遗漏，与核心流程模型一致 | 手动记录（容易遗漏） |
| **缓存策略** | 读时缓存+写时更新 | 平衡性能和一致性 | 无缓存（性能差） |
| **写入方式** | 原子性写入 | 避免部分更新 | 直接写入（可能不一致） |
| **历史访问** | 智能触发+配置控制 | 90%场景不需要历史 | 总是读取（性能浪费） |

---

## 二、模块内部结构

### 2.1 目录结构 {#arch-状态管理-目录结构}

```
src/state-management/
├── index.ts                    # 模块入口，导出公共API
│
├── api/                        # API层(对外接口)
│   ├── state-manager.ts        # 主API类
│   └── types.ts                # API层类型定义
│
├── services/                   # Service层(业务逻辑)
│   ├── state-service.ts        # 状态流转服务
│   ├── migration-service.ts    # 迭代迁移服务
│   └── history-service.ts      # 历史数据访问服务
│
├── repositories/               # Repository层(数据访问)
│   ├── state-repository.ts     # state.json访问
│   └── history-repository.ts   # state_his.json访问
│
├── io/                         # IO层(文件操作)
│   ├── file-io.ts              # 文件读写
│   └── backup.ts               # Git备份
│
├── utils/                      # 工具函数
│   ├── change-recorder.ts      # 变更记录器
│   └── state-builder.ts        # 状态构建器
│
└── __tests__/                  # 测试
    ├── unit/                   # 单元测试
    ├── integration/            # 集成测试
    └── fixtures/               # 测试数据
```

### 2.2 详细模块设计

#### 模块1：API层(api/)

**职责**：
- 对外暴露统一接口
- 参数校验
- 错误转换（内部错误 → 用户友好错误）

**核心接口**：

```typescript
/**
 * StateManager - 状态管理模块的唯一对外入口
 */
export class StateManager {
  constructor(
    private stateService: StateService,
    private migrationService: MigrationService,
    private historyService: HistoryService
  ) {}

  // ===== 读取接口 =====

  /**
   * 读取当前状态
   */
  async readState(): Promise<State> {
    return this.stateService.getState();
  }

  /**
   * 获取当前迭代
   */
  async getCurrentIteration(): Promise<Iteration> {
    const state = await this.readState();
    return state.iterations[state.currentIteration];
  }

  /**
   * 获取当前阶段
   */
  async getCurrentPhase(): Promise<PhaseState> {
    const iteration = await this.getCurrentIteration();
    return iteration.phases[iteration.currentPhase];
  }

  /**
   * 获取模块状态
   */
  async getModuleStatus(
    phaseName: string,
    moduleName: string
  ): Promise<ModuleState> {
    const state = await this.readState();
    const iteration = state.iterations[state.currentIteration];
    return iteration.phases[phaseName].modules[moduleName];
  }

  // ===== 写入接口 =====

  /**
   * 更新模块状态
   */
  async updateModuleStatus(
    phaseName: string,
    moduleName: string,
    newStatus: ModuleStatus,
    artifacts?: string[]
  ): Promise<UpdateResult> {
    return this.stateService.updateModuleStatus(
      phaseName, moduleName, newStatus, artifacts
    );
  }

  /**
   * 阶段流转
   */
  async transitionPhase(targetPhase: string): Promise<TransitionResult> {
    return this.stateService.transitionPhase(targetPhase);
  }

  /**
   * 审批阶段
   */
  async approvePhase(phaseName: string, approvedBy: string): Promise<ApproveResult> {
    return this.stateService.approvePhase(phaseName, approvedBy);
  }

  /**
   * 审批模块
   */
  async approveModule(
    phaseName: string,
    moduleName: string,
    approvedBy: string,
    artifacts: string[]
  ): Promise<ApproveResult> {
    return this.stateService.approveModule(
      phaseName, moduleName, approvedBy, artifacts
    );
  }

  // ===== 迁移接口 =====

  /**
   * 迁移迭代到历史
   */
  async migrateIterationToHistory(iterationId: string): Promise<MigrationResult> {
    return this.migrationService.migrate(iterationId);
  }

  // ===== 历史访问接口 =====

  /**
   * 智能读取历史
   * @param query - 查询意图描述
   * @returns 是否需要读取历史，以及原因
   */
  async analyzeHistoryNeed(query: string): Promise<HistoryNeedAnalysis> {
    return this.historyService.analyzeNeed(query);
  }

  /**
   * 读取历史迭代
   */
  async readHistoryIteration(iterationId: string): Promise<HistoricalIteration> {
    return this.historyService.getIteration(iterationId);
  }

  /**
   * 跨迭代对比
   */
  async compareIterations(
    iterationId1: string,
    iterationId2: string
  ): Promise<IterationComparison> {
    return this.historyService.compare(iterationId1, iterationId2);
  }
}
```

---

#### 模块2：Service层(services/)

**职责**：
- 实现业务逻辑
- 调用核心流程模型进行验证
- 协调Repository层

**StateService核心实现**：

```typescript
/**
 * StateService - 状态流转业务逻辑
 */
export class StateService {
  constructor(
    private repository: StateRepository,
    private coreProcess: CoreProcessModelAPI & CoreProcessValidators,
    private changeRecorder: ChangeRecorder
  ) {}

  private state: State | null = null;

  /**
   * 获取当前状态
   */
  async getState(): Promise<State> {
    if (!this.state) {
      this.state = await this.repository.read();
    }
    return this.state;
  }

  /**
   * 更新模块状态
   */
  async updateModuleStatus(
    phaseName: string,
    moduleName: string,
    newStatus: ModuleStatus,
    artifacts?: string[]
  ): Promise<UpdateResult> {
    const state = await this.getState();
    const iteration = state.iterations[state.currentIteration];
    const moduleState = iteration.phases[phaseName].modules[moduleName];

    if (!moduleState) {
      return {
        success: false,
        errors: [`Module "${moduleName}" not found in phase "${phaseName}"`]
      };
    }

    const oldStatus = moduleState.status;

    // 验证状态流转
    const validation = this.coreProcess.validateModuleTransition(oldStatus, newStatus);
    if (!validation.isValid) {
      return { success: false, errors: validation.errors };
    }

    // 更新状态
    moduleState.status = newStatus;
    if (newStatus === 'approved') {
      moduleState.approvedAt = new Date().toISOString();
    }
    if (artifacts) {
      moduleState.artifacts = [...(moduleState.artifacts || []), ...artifacts];
    }

    // 记录变更
    this.changeRecorder.record(state, {
      type: 'module_status_change',
      description: `模块${moduleName}状态从${oldStatus}变更为${newStatus}`,
      changes: [
        { field: `phases.${phaseName}.modules.${moduleName}.status`, from: oldStatus, to: newStatus }
      ]
    });

    // 验证状态完整性
    const integrity = this.coreProcess.validateStateIntegrity(state);
    if (!integrity.isValid) {
      // 回滚
      moduleState.status = oldStatus;
      return { success: false, errors: integrity.errors };
    }

    // 写入
    await this.repository.write(state);

    return { success: true, warnings: validation.warnings };
  }

  /**
   * 阶段流转
   */
  async transitionPhase(targetPhase: string): Promise<TransitionResult> {
    const state = await this.getState();
    const iteration = state.iterations[state.currentIteration];
    const currentPhase = iteration.currentPhase;

    // 获取阶段定义
    const targetDef = this.coreProcess.getPhaseDefinition(targetPhase);

    // 验证流转
    const validation = this.coreProcess.validatePhaseTransition(currentPhase, targetPhase);
    if (!validation.isValid) {
      return { success: false, errors: validation.errors };
    }

    // 更新状态
    iteration.phases[currentPhase].status = 'completed';
    iteration.phases[currentPhase].completedAt = new Date().toISOString();
    iteration.phases[targetPhase].status = 'in_progress';
    iteration.phases[targetPhase].startedAt = new Date().toISOString();
    iteration.currentPhase = targetPhase;

    // 记录变更
    this.changeRecorder.record(state, {
      type: 'phase_transition',
      description: `阶段从${currentPhase}流转到${targetPhase}`,
      changes: [
        { field: 'currentPhase', from: currentPhase, to: targetPhase },
        { field: `phases.${currentPhase}.status`, from: 'approved', to: 'completed' },
        { field: `phases.${targetPhase}.status`, from: 'pending', to: 'in_progress' }
      ]
    });

    // 验证完整性
    const integrity = this.coreProcess.validateStateIntegrity(state);
    if (!integrity.isValid) {
      return { success: false, errors: integrity.errors };
    }

    // 写入
    await this.repository.write(state);

    return {
      success: true,
      newPhase: targetPhase,
      warnings: validation.warnings
    };
  }

  /**
   * 回滚模块
   */
  async rollbackModule(
    moduleName: string,
    targetPhase: string,
    reason: string
  ): Promise<RollbackResult> {
    const state = await this.getState();
    const iteration = state.iterations[state.currentIteration];

    // 找到模块在各阶段的状态
    for (const [phaseName, phaseState] of Object.entries(iteration.phases)) {
      const moduleState = phaseState.modules[moduleName];
      if (moduleState) {
        // 标记为rolled_back
        const oldStatus = moduleState.status;
        moduleState.status = 'rolled_back';
        moduleState.previousApprovedAt = moduleState.approvedAt;
        moduleState.approvedAt = undefined;
        moduleState.rollbackHistory = moduleState.rollbackHistory || [];
        moduleState.rollbackHistory.push({
          rolledBackAt: new Date().toISOString(),
          reason,
          fromPhase: phaseName,
          toPhase: targetPhase
        });

        // 记录变更
        this.changeRecorder.record(state, {
          type: 'rollback',
          description: `模块${moduleName}从${phaseName}回滚到${targetPhase}`,
          changes: [
            { field: `modules.${moduleName}.status`, from: oldStatus, to: 'rolled_back' }
          ]
        });
      }
    }

    // 写入
    await this.repository.write(state);

    return { success: true, rolledBackModule: moduleName, targetPhase };
  }
}
```

---

#### 模块3：Repository层(repositories/)

**职责**：
- 封装文件读写
- 管理缓存
- 处理并发访问

```typescript
/**
 * StateRepository - state.json数据访问
 */
export class StateRepository {
  private cache: State | null = null;
  private cacheTimestamp: number = 0;
  private readonly CACHE_TTL = 5000; // 5秒
  private readonly STATE_PATH = '.solodev/state.json';

  constructor(private fileIO: FileIO) {}

  /**
   * 读取状态
   */
  async read(): Promise<State> {
    // 检查缓存
    if (this.isCacheValid()) {
      return this.cache!;
    }

    // 从文件读取
    try {
      const content = await this.fileIO.readJSON<State>(this.STATE_PATH);
      this.updateCache(content);
      return content;
    } catch (error) {
      if (error.code === 'ENOENT') {
        throw new StateFileNotFoundError('state.json not found');
      }
      if (error instanceof SyntaxError) {
        throw new StateFileCorruptedError('state.json is corrupted (invalid JSON)');
      }
      throw error;
    }
  }

  /**
   * 写入状态
   */
  async write(state: State): Promise<void> {
    // 更新metadata
    state.metadata.stateFileVersion++;
    state.metadata.totalStateChanges++;
    state.metadata.lastUpdatedAt = new Date().toISOString();
    state.metadata.lastUpdatedBy = 'ai';

    // 写入文件
    await this.fileIO.writeJSON(this.STATE_PATH, state);

    // 更新缓存
    this.updateCache(state);
  }

  /**
   * 检查文件大小
   */
  async checkFileSize(): Promise<FileSizeCheck> {
    const stats = await this.fileIO.stat(this.STATE_PATH);
    const sizeKB = stats.size / 1024;

    return {
      sizeKB,
      isOverLimit: sizeKB > 100,
      isWarning: sizeKB > 80,
      recommendation: sizeKB > 100
        ? '文件超过100KB，建议迁移历史迭代到state_his.json'
        : sizeKB > 80
        ? '文件接近100KB限制，请注意'
        : null
    };
  }

  private isCacheValid(): boolean {
    return this.cache !== null &&
           Date.now() - this.cacheTimestamp < this.CACHE_TTL;
  }

  private updateCache(state: State): void {
    this.cache = state;
    this.cacheTimestamp = Date.now();
  }

  /**
   * 使缓存失效
   */
  invalidateCache(): void {
    this.cache = null;
    this.cacheTimestamp = 0;
  }
}
```

---

#### 模块4：IO层(io/)

**职责**：
- 文件系统操作
- JSON序列化/反序列化
- Git集成

```typescript
/**
 * FileIO - 文件IO操作
 */
export class FileIO {
  constructor(private basePath: string) {}

  /**
   * 读取JSON文件
   */
  async readJSON<T>(relativePath: string): Promise<T> {
    const fullPath = path.join(this.basePath, relativePath);
    const content = await fs.promises.readFile(fullPath, 'utf-8');
    return JSON.parse(content) as T;
  }

  /**
   * 写入JSON文件
   */
  async writeJSON<T>(relativePath: string, data: T): Promise<void> {
    const fullPath = path.join(this.basePath, relativePath);
    const content = JSON.stringify(data, null, 2);
    await fs.promises.writeFile(fullPath, content, 'utf-8');
  }

  /**
   * 获取文件状态
   */
  async stat(relativePath: string): Promise<fs.Stats> {
    const fullPath = path.join(this.basePath, relativePath);
    return fs.promises.stat(fullPath);
  }

  /**
   * 检查文件是否存在
   */
  async exists(relativePath: string): Promise<boolean> {
    const fullPath = path.join(this.basePath, relativePath);
    try {
      await fs.promises.access(fullPath);
      return true;
    } catch {
      return false;
    }
  }
}

/**
 * GitBackup - Git备份操作
 */
export class GitBackup {
  constructor(private basePath: string) {}

  /**
   * 获取文件的Git历史
   */
  async getFileHistory(relativePath: string, limit: number = 10): Promise<GitCommit[]> {
    const result = await exec(
      `git log --oneline -n ${limit} -- ${relativePath}`,
      { cwd: this.basePath }
    );

    return this.parseGitLog(result.stdout);
  }

  /**
   * 恢复文件到指定版本
   */
  async restoreFile(relativePath: string, commitHash: string): Promise<void> {
    await exec(
      `git checkout ${commitHash} -- ${relativePath}`,
      { cwd: this.basePath }
    );
  }

  private parseGitLog(output: string): GitCommit[] {
    return output.trim().split('\n').map(line => {
      const [hash, ...messageParts] = line.split(' ');
      return { hash, message: messageParts.join(' ') };
    });
  }
}
```

---

## 三、核心流程

### 3.1 状态读取流程

```
用户/其他模块 调用 StateManager.readState()
  ↓
【API层】StateManager.readState()
  ↓
【Service层】StateService.getState()
  ↓
【Repository层】StateRepository.read()
  ├─ 缓存命中? → 返回缓存
  └─ 缓存未命中 →
       ↓
     【IO层】FileIO.readJSON('.solodev/state.json')
       ↓
     解析JSON → 更新缓存 → 返回State
```

### 3.2 状态更新流程

```
用户/其他模块 调用 StateManager.updateModuleStatus()
  ↓
【API层】参数校验
  ↓
【Service层】StateService.updateModuleStatus()
  ↓
  步骤1: 读取当前状态
  ↓
  步骤2: 调用【核心流程模型】.validateModuleTransition()
  ├─ 验证失败 → 返回错误
  └─ 验证通过 →
       ↓
     步骤3: 构建新状态
       ↓
     步骤4: 记录changeHistory（ChangeRecorder）
       ↓
     步骤5: 调用【核心流程模型】.validateStateIntegrity()
     ├─ 验证失败 → 回滚状态,返回错误
     └─ 验证通过 →
          ↓
        【Repository层】StateRepository.write()
          ↓
        【IO层】FileIO.writeJSON()
          ↓
        返回成功
```

### 3.3 迭代迁移流程

```
迭代完成并部署后,用户调用 StateManager.migrateIterationToHistory()
  ↓
【Service层】MigrationService.migrate(iterationId)
  ↓
  步骤1: 验证迁移条件
    - iterations[iterationId].status === 'completed'
    - iterations[iterationId].deployedAt !== null
  ├─ 不满足 → 返回错误
  └─ 满足 →
       ↓
     步骤2: 读取state.json和state_his.json
       ↓
     步骤3: 构建历史迭代对象
       - 提取完整phases数据
       - 提取当前迭代的tasks
       - 提取当前迭代的changeHistory
       - 添加summary
       ↓
     步骤4: 写入state_his.json
       ↓
     步骤5: 清理state.json
       - 删除已迁移的迭代
       - 清空globalTasks.completed
       - 清空changeHistory
       - 设置新的currentIteration
       ↓
     步骤6: 写入state.json
       ↓
     步骤7: 触发Git commit（通过Git集成模块）
       ↓
     返回迁移结果
```

### 3.4 历史数据访问流程

```
用户询问历史相关问题
  ↓
【Service层】HistoryService.analyzeNeed(query)
  ↓
  步骤1: 分析查询意图
    - 是否包含历史对比关键词（"对比"、"历史"、"iteration-X"）
    - 是否包含趋势分析关键词（"趋势"、"统计"、"过去"）
  ↓
  步骤2: 判断是否需要历史数据
  ├─ 不需要 → 返回 { needHistory: false }
  └─ 需要 →
       ↓
     步骤3: 检查settings.autoReadHistory
     ├─ autoReadHistory=false → 返回 { needHistory: true, requireConfirmation: true }
     └─ autoReadHistory=true →
          ↓
        步骤4: 读取state_his.json
          ↓
        步骤5: 返回历史数据
```

---

## 四、对外接口 {#arch-状态管理-对外接口}

### 4.1 读取接口

```typescript
export interface StateReader {
  /** 读取完整状态 */
  readState(): Promise<State>;

  /** 获取当前迭代 */
  getCurrentIteration(): Promise<Iteration>;

  /** 获取当前阶段 */
  getCurrentPhase(): Promise<PhaseState>;

  /** 获取模块状态 */
  getModuleStatus(phaseName: string, moduleName: string): Promise<ModuleState>;

  /** 获取模块依赖 */
  getModuleDependencies(): Promise<ModuleDependencies>;
}
```

### 4.2 写入接口

```typescript
export interface StateWriter {
  /** 更新模块状态 */
  updateModuleStatus(
    phaseName: string,
    moduleName: string,
    newStatus: ModuleStatus,
    artifacts?: string[]
  ): Promise<UpdateResult>;

  /** 阶段流转 */
  transitionPhase(targetPhase: string): Promise<TransitionResult>;

  /** 审批阶段 */
  approvePhase(phaseName: string, approvedBy: string): Promise<ApproveResult>;

  /** 审批模块 */
  approveModule(
    phaseName: string,
    moduleName: string,
    approvedBy: string,
    artifacts: string[]
  ): Promise<ApproveResult>;

  /** 回滚模块 */
  rollbackModule(
    moduleName: string,
    targetPhase: string,
    reason: string
  ): Promise<RollbackResult>;

  /** 更新Testing子阶段状态 */
  updateTestSubPhaseStatus(
    subPhase: 'e2e' | 'performance' | 'chaos',
    newStatus: TestSubPhaseStatus,
    artifacts?: TestSubPhaseArtifacts
  ): Promise<UpdateResult>;
}
```

### 4.3 迁移接口

```typescript
export interface MigrationAPI {
  /** 迁移迭代到历史 */
  migrateIterationToHistory(iterationId: string): Promise<MigrationResult>;

  /** 检查是否可以迁移 */
  canMigrate(iterationId: string): Promise<MigrationCheck>;
}
```

### 4.4 历史访问接口

```typescript
export interface HistoryAPI {
  /** 分析是否需要历史数据 */
  analyzeHistoryNeed(query: string): Promise<HistoryNeedAnalysis>;

  /** 读取历史迭代 */
  readHistoryIteration(iterationId: string): Promise<HistoricalIteration>;

  /** 跨迭代对比 */
  compareIterations(
    iterationId1: string,
    iterationId2: string
  ): Promise<IterationComparison>;

  /** 获取模块变更频率 */
  getModuleChangeFrequency(): Promise<ModuleChangeStats>;
}
```

### 4.5 工具接口

```typescript
export interface StateUtils {
  /** 检查state.json文件大小 */
  checkFileSize(): Promise<FileSizeCheck>;

  /** 获取上次进度摘要 */
  getProgressSummary(): Promise<ProgressSummary>;

  /** 建议下一步操作 */
  suggestNextAction(): Promise<ActionSuggestion>;

  /** 恢复state.json到指定Git版本 */
  restoreFromGit(commitHash: string): Promise<RestoreResult>;
}
```

---

## 五、非功能性设计

### 5.1 性能设计

**响应时间目标**：
- 状态读取: < 50ms
- 状态写入: < 100ms
- 历史迁移: < 500ms
- 文件大小检查: < 10ms

**优化策略**：

| 优化点 | 策略 | 预期效果 |
|-------|------|---------|
| 读取性能 | 5秒TTL缓存 | 减少80%文件IO |
| 写入性能 | 批量更新 | 多次更新合并为1次写入 |
| 解析性能 | 惰性解析 | 按需解析字段 |
| 大小控制 | 80KB警告,100KB强制迁移 | 保持文件轻量 |

### 5.2 可靠性设计

**错误处理**：

| 错误场景 | 处理策略 | 恢复方式 |
|---------|---------|---------|
| state.json不存在 | 抛出StateFileNotFoundError | 用户手动创建或从Git恢复 |
| state.json格式错误 | 抛出StateFileCorruptedError | 提供修复建议,或从Git恢复 |
| 写入失败 | 回滚到写入前状态 | 重试或人工干预 |
| 迁移失败 | 不删除原数据,记录错误 | 人工排查后重试 |

**原子性保证**：
- 写入前先验证新状态
- 验证失败不执行写入
- 写入使用临时文件+重命名（在v1.1考虑）

### 5.3 可扩展性设计

**Schema版本管理**：
- schema_version字段标识版本
- 新增字段使用可选类型
- 提供版本迁移函数

**未来扩展点**：
- v1.1: 增加状态变更事件订阅机制
- v2.0: 支持多迭代并行
- v2.0: 支持远程状态同步

### 5.4 可观测性设计

**日志规范**：

```typescript
// INFO级别：正常操作
logger.info('Phase transition completed', {
  from: 'requirements',
  to: 'architecture',
  duration: '50ms'
});

// WARN级别：警告但不阻塞
logger.warn('State file approaching size limit', {
  currentSize: '85KB',
  limit: '100KB'
});

// ERROR级别：错误
logger.error('State validation failed', {
  errors: ['currentPhase not found'],
  state: state
});
```

**指标收集**（v1.1考虑）：
- 读取/写入次数
- 缓存命中率
- 平均响应时间
- 文件大小趋势

---

## 六、与核心流程模型的集成

### 6.1 依赖关系

```
【状态管理模块】 ──依赖──→ 【核心流程模型】
     │
     ├── getPhaseDefinition()          # 获取阶段定义
     ├── validatePhaseTransition()     # 验证阶段流转
     ├── validateModuleTransition()    # 验证模块状态流转
     ├── validateStateIntegrity()      # 验证状态完整性
     ├── validateDependencies()        # 验证依赖关系
     └── getRootCauseAnalysisFramework() # 获取分层分析框架（回滚时使用）
```

### 6.2 调用时机

| 操作 | 调用的核心流程模型接口 |
|------|----------------------|
| 阶段流转 | validatePhaseTransition(), validateStateIntegrity() |
| 模块状态更新 | validateModuleTransition(), validateStateIntegrity() |
| 模块审批 | getPhaseDefinition(), validateStateIntegrity() |
| 回滚 | getRootCauseAnalysisFramework(), validateStateIntegrity() |
| 任何状态写入 | validateStateIntegrity() |

### 6.3 changeHistory维护

根据核心流程模型11.4节设计，**changeHistory由状态管理模块负责维护**：

```typescript
class ChangeRecorder {
  record(state: State, change: ChangeInput): void {
    state.changeHistory.push({
      timestamp: new Date().toISOString(),
      type: change.type,
      description: change.description,
      changedBy: change.changedBy || 'ai',
      changes: change.changes
    });
  }
}
```

---

## 七、架构演进计划

### 7.1 当前迭代范围(Iteration 1)

**已实现**：
- ✅ 分层架构设计
- ✅ 状态读写接口
- ✅ 迭代迁移机制
- ✅ 历史数据访问
- ✅ 自动changeHistory记录
- ✅ 与核心流程模型集成

**未实现(计划外)**：
- ⏳ 状态变更事件订阅(v1.1)
- ⏳ 写入原子性（临时文件+重命名）(v1.1)
- ⏳ 远程状态同步(v2.0)

### 7.2 未来迭代规划

**Iteration 2 (v1.1)**：
- 新增: 状态变更事件订阅（Pub/Sub模式）
- 新增: 写入原子性保证
- 优化: 缓存策略精细化

**Iteration 3 (v2.0)**：
- 新增: 多迭代并行支持
- 新增: 远程状态同步
- 新增: 状态快照和恢复

### 7.3 技术债务

| 债务描述 | 影响 | 计划解决时间 |
|---------|------|------------|
| 写入不保证原子性 | 极端情况可能部分写入 | Iteration 2 |
| 缓存策略简单 | 高并发场景可能有问题 | Iteration 2 |
| 无状态变更通知 | 模块间无法实时同步 | Iteration 2 |

---

## 八、总结

### 核心设计理念

**状态管理模块是"数据守护者"，不是"业务决策者"**：
- 提供统一的状态读写接口
- 调用核心流程模型进行验证
- 自动维护changeHistory
- 智能管理历史数据访问

### 关键成功因素

1. **分层架构**: 职责清晰，每层可独立测试
2. **自动变更记录**: 不遗漏任何状态变更
3. **与核心流程模型紧密集成**: 所有状态变更都经过验证
4. **智能历史访问**: 90%场景不需要历史数据
5. **原子性写入**: 避免部分更新导致的不一致

### 架构图示

```
┌─────────────────────────────────────────────────────┐
│              【状态管理模块】                        │
│  ═══════════════════════════════════════════════   │
│  ┌─────────────────────────────────────────────┐   │
│  │  API层: StateManager                        │   │
│  │  · readState() / writeState()               │   │
│  │  · updateModuleStatus() / transitionPhase() │   │
│  └────────────────────┬────────────────────────┘   │
│                       ↓                             │
│  ┌─────────────────────────────────────────────┐   │
│  │  Service层: StateService / MigrationService │   │
│  │  · 业务逻辑 · 事务管理 · 变更记录          │   │
│  └────────────────────┬────────────────────────┘   │
│                       ↓                             │
│  ┌─────────────────────────────────────────────┐   │
│  │  Repository层: StateRepository              │   │
│  │  · 数据访问 · 缓存管理                      │   │
│  └────────────────────┬────────────────────────┘   │
│                       ↓                             │
│  ┌─────────────────────────────────────────────┐   │
│  │  IO层: FileIO / GitBackup                   │   │
│  │  · 文件读写 · Git操作                       │   │
│  └─────────────────────────────────────────────┘   │
└───────────────────────┬─────────────────────────────┘
                        ↓ 依赖
            ┌───────────────────────┐
            │  【核心流程模型】      │
            │  · 验证规则 · 阶段定义 │
            └───────────────────────┘
```
