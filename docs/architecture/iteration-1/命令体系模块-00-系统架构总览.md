# 命令体系模块 - 系统架构总览

<!--
章节ID规范说明：
- 格式：{#arch-命令体系-[章节标识]}
- 必须标注ID的章节：模块划分、核心流程、对外接口
- 示例：{#arch-命令体系-模块划分} 表示命令体系模块系统架构的模块划分章节
-->

> **项目**: AI超级个体开发助手
> **版本**: v1.0.0
> **迭代**: Iteration 1
> **模块**: 命令体系模块
> **日期**: 2025-12-15

---

## 一、架构概述

### 1.1 模块定位

命令体系模块是整个系统的**用户交互入口(User Interface Gateway)**，负责解析用户命令并协调其他模块完成任务：

```
┌─────────────────────────────────────────────────────┐
│              用户交互层(User Interface)              │
│  ───────────────────────────────────────────────── │
│  用户输入: /start-requirements, /approve-architecture│
└───────────────────────┬─────────────────────────────┘
                        ↓ 命令输入
┌─────────────────────────────────────────────────────┐
│     【命令体系模块】(Command System Module)          │
│  ═══════════════════════════════════════════════   │
│  ┌─────────────────────────────────────────────┐   │
│  │  命令定义层(Command Definition)             │   │
│  │  ─────────────────────────────────────────  │   │
│  │  · .claude/commands/*.md 文件              │   │
│  │  · 命令名称、参数、描述定义                  │   │
│  └─────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────┐   │
│  │  命令执行层(Command Execution)              │   │
│  │  ─────────────────────────────────────────  │   │
│  │  · 命令解析: 解析参数、验证格式             │   │
│  │  · 状态检查: 调用状态管理模块验证前置条件    │   │
│  │  · 上下文加载: 调用状态管理模块获取上下文    │   │
│  │  · 任务执行: 协调各模块执行具体任务         │   │
│  └─────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────┐   │
│  │  审批控制层(Approval Control)               │   │
│  │  ─────────────────────────────────────────  │   │
│  │  · 审批点检测: 判断是否需要暂停等待审批     │   │
│  │  · 审批执行: 处理用户审批命令               │   │
│  └─────────────────────────────────────────────┘   │
└───────────────────────┬─────────────────────────────┘
                        ↓ 调用
┌─────────────────────────────────────────────────────┐
│            协作层(Collaboration Layer)               │
│  ───────────────────────────────────────────────── │
│  状态管理模块 | 核心流程模型 | 文档模板模块 | Git集成 │
└─────────────────────────────────────────────────────┘
```

### 1.2 核心职责

**命令体系模块是"交互入口"，不是"业务执行者"**：

| 职责类别 | 具体内容 | 非职责(由其他模块负责) |
|---------|---------|----------------------|
| **命令定义** | 定义9个命令的名称、参数、帮助文档 | ❌ 不负责定义阶段规则 |
| **命令解析** | 解析用户输入，验证参数合法性 | ❌ 不负责实现状态持久化 |
| **状态检查** | 调用状态管理模块检查前置条件 | ❌ 不负责实现状态流转逻辑 |
| **上下文加载** | 调用状态管理模块获取上下文 | ❌ 不负责上下文计算逻辑 |
| **任务协调** | 协调文档模板、Git集成等模块 | ❌ 不负责文档生成逻辑 |
| **审批控制** | 在关键节点暂停等待人工审批 | ❌ 不负责验证审批条件 |

### 1.3 架构特点

#### 特点1：命令即配置(Command as Configuration)

**设计理念**：命令通过Markdown文件定义，AI解释执行

```markdown
# .claude/commands/init.md

## 命令定义
- 名称: /init
- 描述: 初始化新项目
- 参数: 无（项目信息通过交互询问获取）

## 前置条件
- state.json不存在（项目未初始化）

## 执行流程
1. 检查.solodev/state.json是否存在
   - 如存在，提示"项目已初始化，无需重复执行"
2. 交互询问获取项目信息：
   - 询问1："请输入项目名称："
   - 询问2："请选择项目类型：1) backend  2) frontend  3) fullstack"
3. 创建项目结构：
   - .solodev/ 目录
   - .solodev/state.json（初始状态）
   - .solodev/templates/（可选）
4. 初始化state.json内容（使用交互获取的信息）
5. 提示"项目初始化完成，请执行 /start-requirements 启动需求分析"
```

```markdown
# .claude/commands/start-requirements.md

## 命令定义
- 名称: /start-requirements
- 描述: 启动需求分析阶段
- 参数: [模块名] (可选，指定单个模块)

## 执行流程
1. 检查state.json：currentPhase是否为null或上一迭代已完成
2. 更新state.json：currentPhase = "requirements"
3. 读取PRD模板，逐模块澄清需求
4. 生成PRD文档
5. 暂停等待审批
```

**优势**：
- 命令定义可读性强，非开发者也能理解
- 新增命令只需创建.md文件
- 便于版本控制和审计

#### 特点2：声明式执行流程

**设计理念**：命令的执行流程在定义文件中声明，AI按照声明执行

```typescript
// 命令执行引擎读取声明式流程
interface CommandDefinition {
  name: string;
  description: string;
  parameters: ParameterDefinition[];
  preconditions: PreconditionCheck[];
  steps: ExecutionStep[];
  approvalRequired: boolean;
}

// AI根据定义执行
async function executeCommand(command: CommandDefinition): Promise<void> {
  // 1. 检查前置条件
  for (const precondition of command.preconditions) {
    await checkPrecondition(precondition);
  }

  // 2. 执行步骤
  for (const step of command.steps) {
    await executeStep(step);
  }

  // 3. 检查是否需要审批
  if (command.approvalRequired) {
    await waitForApproval();
  }
}
```

#### 特点3：上下文驱动(Context-Driven)

**设计理念**：命令执行前加载精确上下文，减少AI认知负担

```
命令输入: /start-architecture
     ↓
【命令解析】解析命令名称和参数
     ↓
【状态检查】检查requirements阶段是否已完成
     ↓
【上下文加载】调用 stateManager.getContextForPhase('architecture')
     ↓
     返回上下文:
     - 当前迭代信息
     - 所有模块的PRD文档路径
     - 已完成模块的架构文档
     - 模块依赖关系
     ↓
【任务执行】AI基于精确上下文执行架构设计
```

**优势**：
- AI只看到相关上下文，不被无关信息干扰
- 上下文由代码计算，确保准确性
- 支持模块级精细控制

#### 特点4：审批点机制(Approval Points)

**设计理念**：关键节点强制暂停，等待人工确认

```
五大审批点:
1. 需求文档审批 (/approve-requirements)
2. 架构文档审批 (/approve-architecture)
3. E2E测试计划审批 (Testing阶段内)
4. 性能测试方案审批 (Testing阶段内)
5. 混沌测试方案审批 (Testing阶段内)
```

**实现方式**：
- 命令定义中标记 `approvalRequired: true`
- AI执行到审批点时生成审批提示
- 用户执行审批命令后继续

### 1.4 关键设计决策

| 决策点 | 选择 | 理由 | 替代方案 |
|--------|------|------|---------|
| **命令存储** | Markdown文件 | 可读性强，Claude CLI原生支持 | JSON配置（可读性差） |
| **执行方式** | AI解释执行 | 灵活，无需编译 | 代码硬编码（不灵活） |
| **上下文加载** | 集成状态管理模块 | 上下文准确，强制性 | AI自行读取文件（不可靠） |
| **审批机制** | 显式审批命令 | 用户控制明确 | 自动超时通过（风险高） |
| **错误处理** | 返回用户友好提示 | 提升用户体验 | 抛出技术错误（难以理解） |

---

## 二、模块内部结构

### 2.1 模块划分 {#arch-命令体系-模块划分}

命令体系模块分为**两层 + 命令定义仓库**：

```
命令体系模块
├── commands/                    # 命令定义仓库
│   ├── init.md                  # 初始化新项目
│   ├── start-requirements.md    # 启动需求分析
│   ├── approve-requirements.md  # 审批需求文档
│   ├── start-architecture.md    # 启动架构设计
│   ├── approve-architecture.md  # 审批架构文档
│   ├── start-implementation.md  # 启动实现阶段
│   ├── start-testing.md         # 启动测试阶段
│   ├── start-deployment.md      # 启动部署阶段
│   └── custom-task.md           # 自定义任务
│
├── executor/                    # 命令执行层
│   ├── command-parser.ts        # 命令解析器
│   ├── precondition-checker.ts  # 前置条件检查
│   ├── context-integrator.ts    # 上下文集成
│   └── step-executor.ts         # 步骤执行器
│
└── approval/                    # 审批控制层
    ├── approval-detector.ts     # 审批点检测
    └── approval-handler.ts      # 审批处理器
```

### 2.2 详细模块设计

#### 模块1：命令定义仓库(commands/)

**职责**：
- 存储所有命令的定义文件
- 提供命令元信息（名称、参数、描述）
- 定义命令执行流程

**命令文件结构**：

```markdown
# start-requirements.md

## 命令元信息
- **名称**: /start-requirements
- **描述**: 启动需求分析阶段，开始新迭代的第一步
- **参数**:
  - `[模块名]` (可选): 指定单个模块进行需求分析

## 前置条件
1. state.json存在且格式正确
2. currentPhase为null 或 上一迭代已完成（currentIteration的status=completed）

## 执行流程
1. 读取state.json，获取当前状态
2. 验证前置条件
3. 更新state.json:
   - currentPhase = "requirements"
   - phases.requirements.status = "in_progress"
   - phases.requirements.startedAt = 当前时间戳
4. 加载上下文: 调用 getContextForPhase("requirements")
5. 读取PRD模板(.solodev/templates/PRD-project-template.md)
6. 逐模块澄清需求（如指定模块，只处理该模块）
7. 生成PRD文档到 docs/PRD/
8. 生成审批提示: "需求分析完成，请审批PRD文档"

## 审批要求
- 需要审批: 是
- 审批命令: /approve-requirements

## 错误处理
| 错误场景 | 处理方式 |
|---------|---------|
| state.json不存在 | 提示"项目未初始化，请先执行 /init 命令" |
| 当前迭代未完成 | 提示"当前迭代尚未完成" |
| 参数的模块不存在 | 提示"模块[xxx]不存在" |
```

---

#### 模块2：命令执行层(executor/)

**职责**：
- 解析命令输入
- 检查前置条件
- 加载上下文
- 执行命令步骤

**核心组件1：命令解析器(command-parser.ts)**

```typescript
/**
 * CommandParser - 解析用户输入的命令
 */
export class CommandParser {
  /**
   * 解析命令字符串
   * @param input 用户输入，如 "/start-requirements 核心流程模型"
   * @returns ParsedCommand 或 HelpRequest（当包含 --help 时）
   */
  parse(input: string): ParsedCommand | HelpRequest {
    // 1. 提取命令名称
    const commandMatch = input.match(/^\/([a-z-]+)/);
    if (!commandMatch) {
      throw new InvalidCommandError('命令必须以/开头');
    }
    const commandName = commandMatch[1];

    // 2. 检查是否是帮助请求（--help 或 -h）
    if (input.includes('--help') || input.includes(' -h')) {
      return {
        type: 'help',
        command: commandName
      };
    }

    // 3. 提取参数
    const argsString = input.slice(commandMatch[0].length).trim();
    const args = this.parseArgs(argsString);

    // 4. 验证命令是否存在
    if (!this.commandExists(commandName)) {
      throw new CommandNotFoundError(`未知命令: /${commandName}`);
    }

    return {
      type: 'command',
      name: commandName,
      args,
      rawInput: input
    };
  }

  /**
   * 获取命令帮助信息
   */
  getHelp(commandName: string): CommandHelp {
    const definition = this.loadCommandDefinition(commandName);
    return {
      name: commandName,
      description: definition.description,
      usage: `/${commandName} ${definition.parameters.map(p => p.required ? `<${p.name}>` : `[${p.name}]`).join(' ')}`,
      parameters: definition.parameters,
      examples: definition.examples || []
    };
  }

  /**
   * 解析参数
   * 支持格式:
   * - 位置参数: /start-requirements 模块名
   * - 命名参数: /custom-task --modules=模块A,模块B "任务描述"
   */
  private parseArgs(argsString: string): CommandArgs {
    const args: CommandArgs = {
      positional: [],
      named: {}
    };

    // 解析命名参数 (--key=value)
    const namedRegex = /--(\w+)=([^\s"]+|"[^"]*")/g;
    let match;
    while ((match = namedRegex.exec(argsString)) !== null) {
      const key = match[1];
      let value = match[2];
      // 去除引号
      if (value.startsWith('"') && value.endsWith('"')) {
        value = value.slice(1, -1);
      }
      args.named[key] = value;
    }

    // 解析位置参数（剩余部分）
    const remaining = argsString.replace(namedRegex, '').trim();
    if (remaining) {
      // 处理引号包裹的字符串
      const quotedMatch = remaining.match(/"([^"]*)"/);
      if (quotedMatch) {
        args.positional.push(quotedMatch[1]);
      } else {
        args.positional = remaining.split(/\s+/);
      }
    }

    return args;
  }

  private commandExists(name: string): boolean {
    // 检查 .claude/commands/{name}.md 是否存在
    return fs.existsSync(`.claude/commands/${name}.md`);
  }
}
```

---

**核心组件2：前置条件检查器(precondition-checker.ts)**

```typescript
/**
 * PreconditionChecker - 检查命令执行的前置条件
 */
export class PreconditionChecker {
  constructor(
    private stateManager: StateManager,
    private coreProcess: CoreProcessAPI
  ) {}

  /**
   * 检查命令的前置条件
   */
  async check(
    commandName: string,
    preconditions: PreconditionDefinition[]
  ): Promise<PreconditionResult> {
    const errors: string[] = [];
    const warnings: string[] = [];

    for (const precondition of preconditions) {
      const result = await this.checkSingle(precondition);
      if (!result.passed) {
        if (result.severity === 'error') {
          errors.push(result.message);
        } else {
          warnings.push(result.message);
        }
      }
    }

    return {
      passed: errors.length === 0,
      errors,
      warnings
    };
  }

  /**
   * 检查单个前置条件
   */
  private async checkSingle(
    precondition: PreconditionDefinition
  ): Promise<SingleCheckResult> {
    switch (precondition.type) {
      case 'phase_completed':
        return this.checkPhaseCompleted(precondition.phase);

      case 'phase_approved':
        return this.checkPhaseApproved(precondition.phase);

      case 'state_exists':
        return this.checkStateExists();

      case 'modules_approved':
        return this.checkModulesApproved(precondition.phase, precondition.modules);

      default:
        return { passed: true, message: '' };
    }
  }

  /**
   * 检查阶段是否已完成
   */
  private async checkPhaseCompleted(phase: string): Promise<SingleCheckResult> {
    const state = await this.stateManager.readState();
    const iteration = state.iterations[state.currentIteration];
    const phaseState = iteration.phases[phase];

    if (phaseState.status !== 'completed' && phaseState.status !== 'approved') {
      return {
        passed: false,
        severity: 'error',
        message: `阶段"${phase}"尚未完成，当前状态: ${phaseState.status}`
      };
    }

    return { passed: true, message: '' };
  }

  /**
   * 检查阶段是否已审批
   */
  private async checkPhaseApproved(phase: string): Promise<SingleCheckResult> {
    const state = await this.stateManager.readState();
    const iteration = state.iterations[state.currentIteration];
    const phaseState = iteration.phases[phase];

    if (phaseState.status !== 'approved') {
      return {
        passed: false,
        severity: 'error',
        message: `阶段"${phase}"尚未审批通过，当前状态: ${phaseState.status}`
      };
    }

    return { passed: true, message: '' };
  }

  /**
   * 检查state.json是否存在
   */
  private async checkStateExists(): Promise<SingleCheckResult> {
    try {
      await this.stateManager.readState();
      return { passed: true, message: '' };
    } catch (error) {
      if (error instanceof StateFileNotFoundError) {
        return {
          passed: false,
          severity: 'error',
          message: '项目未初始化，请先执行 /init 命令'
        };
      }
      throw error;
    }
  }
}
```

---

**核心组件3：上下文集成器(context-integrator.ts)**

```typescript
/**
 * ContextIntegrator - 集成上下文加载功能
 */
export class ContextIntegrator {
  constructor(private stateManager: StateManager) {}

  /**
   * 加载命令执行上下文
   * @param commandName 命令名称
   * @param args 命令参数
   */
  async loadContext(
    commandName: string,
    args: CommandArgs
  ): Promise<ExecutionContext> {
    // 根据命令类型选择加载策略
    const loadStrategy = this.getLoadStrategy(commandName);

    switch (loadStrategy) {
      case 'phase':
        return this.loadPhaseContext(commandName);

      case 'module':
        const moduleName = args.positional[0];
        return this.loadModuleContext(moduleName);

      case 'custom':
        const modules = this.parseModuleList(args.named['modules']);
        return this.loadCustomContext(modules);

      default:
        return this.loadMinimalContext();
    }
  }

  /**
   * 加载阶段级上下文
   */
  private async loadPhaseContext(commandName: string): Promise<ExecutionContext> {
    const phase = this.commandToPhase(commandName);
    const contextResult = await this.stateManager.getContextForPhase(phase);

    if (!contextResult.success) {
      throw new ContextLoadError(contextResult.error || '上下文加载失败');
    }

    // 显示警告
    if (contextResult.warnings && contextResult.warnings.length > 0) {
      console.warn('上下文加载警告:', contextResult.warnings);
    }

    return {
      type: 'phase',
      phase,
      documents: contextResult.documents,
      stateFields: contextResult.stateFields,
      metadata: contextResult.metadata
    };
  }

  /**
   * 加载模块级上下文
   */
  private async loadModuleContext(moduleName: string): Promise<ExecutionContext> {
    const state = await this.stateManager.readState();
    const currentPhase = state.iterations[state.currentIteration].currentPhase;

    const contextResult = await this.stateManager.getContextForModule(
      moduleName,
      currentPhase
    );

    if (!contextResult.success) {
      throw new ContextLoadError(contextResult.error || '上下文加载失败');
    }

    return {
      type: 'module',
      module: moduleName,
      phase: currentPhase,
      documents: contextResult.documents,
      stateFields: contextResult.stateFields,
      dependencies: contextResult.dependencies
    };
  }

  /**
   * 加载自定义任务上下文
   */
  private async loadCustomContext(modules: string[]): Promise<ExecutionContext> {
    const state = await this.stateManager.readState();
    const currentPhase = state.iterations[state.currentIteration].currentPhase;

    if (modules.length === 0) {
      // 不指定模块，仅加载阶段级上下文
      return this.loadPhaseContext(`start-${currentPhase}`);
    }

    // 加载指定模块的上下文
    const allDocuments: string[] = [];
    const allDependencies: string[] = [];

    for (const moduleName of modules) {
      const contextResult = await this.stateManager.getContextForModule(
        moduleName,
        currentPhase
      );

      if (contextResult.success) {
        allDocuments.push(...contextResult.documents);
        if (contextResult.dependencies) {
          allDependencies.push(...contextResult.dependencies);
        }
      }
    }

    // 去重
    const uniqueDocuments = [...new Set(allDocuments)];
    const uniqueDependencies = [...new Set(allDependencies)];

    return {
      type: 'custom',
      modules,
      phase: currentPhase,
      documents: uniqueDocuments,
      dependencies: uniqueDependencies
    };
  }

  /**
   * 命令名映射到阶段
   */
  private commandToPhase(commandName: string): string {
    const mapping: Record<string, string> = {
      'start-requirements': 'requirements',
      'approve-requirements': 'requirements',
      'start-architecture': 'architecture',
      'approve-architecture': 'architecture',
      'start-implementation': 'implementation',
      'start-testing': 'testing',
      'start-deployment': 'deployment'
    };
    return mapping[commandName] || '';
  }

  /**
   * 解析模块列表
   */
  private parseModuleList(modulesStr?: string): string[] {
    if (!modulesStr) return [];
    return modulesStr.split(',').map(m => m.trim());
  }

  /**
   * 确定上下文加载策略
   */
  private getLoadStrategy(commandName: string): 'phase' | 'module' | 'custom' | 'minimal' {
    if (commandName === 'custom-task') {
      return 'custom';
    }
    if (commandName.startsWith('start-') || commandName.startsWith('approve-')) {
      return 'phase';
    }
    return 'minimal';
  }
}
```

---

#### 模块3：审批控制层(approval/)

**职责**：
- 检测命令是否需要审批
- 生成审批提示
- 处理审批命令

```typescript
/**
 * ApprovalDetector - 审批点检测
 */
export class ApprovalDetector {
  constructor(private coreProcess: CoreProcessAPI) {}

  /**
   * 检测当前是否在审批点
   */
  async detectApprovalPoint(
    commandName: string,
    state: State
  ): Promise<ApprovalPointInfo | null> {
    // 获取阶段定义
    const phase = this.commandToPhase(commandName);
    const definition = this.coreProcess.getPhaseDefinition(phase);

    if (!definition.needsApproval) {
      return null;
    }

    // 检查是否满足审批条件
    const iteration = state.iterations[state.currentIteration];
    const phaseState = iteration.phases[phase];

    // 检查所有模块是否已完成
    const allModulesCompleted = Object.values(phaseState.modules)
      .every(m => m.status === 'completed' || m.status === 'approved');

    if (!allModulesCompleted) {
      return null;
    }

    return {
      phase,
      approvalCommand: this.getApprovalCommand(phase),
      requiredArtifacts: definition.artifactTypes,
      message: this.generateApprovalMessage(phase)
    };
  }

  /**
   * 生成审批提示消息
   */
  private generateApprovalMessage(phase: string): string {
    const messages: Record<string, string> = {
      requirements: '需求分析完成，请审批PRD文档。审批命令: /approve-requirements',
      architecture: '架构设计完成，请审批架构文档。审批命令: /approve-architecture'
    };
    return messages[phase] || `${phase}阶段完成，请审批。`;
  }

  /**
   * 获取审批命令
   */
  private getApprovalCommand(phase: string): string {
    return `/approve-${phase}`;
  }
}

/**
 * ApprovalHandler - 审批处理器
 */
export class ApprovalHandler {
  constructor(
    private stateManager: StateManager,
    private coreProcess: CoreProcessAPI
  ) {}

  /**
   * 处理审批命令
   */
  async handleApproval(
    phase: string,
    approvedBy: string
  ): Promise<ApprovalResult> {
    // 1. 检查阶段是否可以审批
    const state = await this.stateManager.readState();
    const iteration = state.iterations[state.currentIteration];
    const phaseState = iteration.phases[phase];

    if (phaseState.status === 'approved') {
      return {
        success: false,
        errors: [`阶段"${phase}"已经审批通过`]
      };
    }

    if (phaseState.status !== 'in_progress') {
      return {
        success: false,
        errors: [`阶段"${phase}"当前状态为${phaseState.status}，无法审批`]
      };
    }

    // 2. 检查所有模块是否已完成
    const pendingModules = Object.entries(phaseState.modules)
      .filter(([_, m]) => m.status !== 'completed' && m.status !== 'approved')
      .map(([name]) => name);

    if (pendingModules.length > 0) {
      return {
        success: false,
        errors: [`以下模块尚未完成: ${pendingModules.join(', ')}`]
      };
    }

    // 3. 执行审批
    const result = await this.stateManager.approvePhase(phase, approvedBy);

    if (result.success) {
      return {
        success: true,
        approvedAt: result.approvedAt,
        nextAction: this.suggestNextAction(phase)
      };
    }

    return result;
  }

  /**
   * 建议下一步操作
   */
  private suggestNextAction(phase: string): string {
    const nextPhases: Record<string, string> = {
      requirements: '可以执行 /start-architecture 启动架构设计',
      architecture: '可以执行 /start-implementation 启动实现阶段',
      implementation: '可以执行 /start-testing 启动测试阶段',
      testing: '可以执行 /start-deployment 启动部署阶段',
      deployment: '迭代完成！可以开始新迭代'
    };
    return nextPhases[phase] || '';
  }
}
```

---

## 三、核心流程

### 3.1 主要业务流程 {#arch-命令体系-业务流程}

#### 流程1：命令执行主流程

```
用户输入命令（如 /start-architecture）
  ↓
【命令解析】CommandParser.parse()
  ├─ 解析命令名称: "start-architecture"
  └─ 解析参数: (无)
  ↓
【前置条件检查】PreconditionChecker.check()
  ├─ 检查 state.json 存在
  ├─ 检查 requirements 阶段已审批
  └─ 返回 PreconditionResult
  ↓
  ├─ 检查失败 → 返回错误提示给用户
  └─ 检查通过 →
       ↓
     【上下文加载】ContextIntegrator.loadContext()
       ├─ 调用 stateManager.getContextForPhase('architecture')
       └─ 返回 ExecutionContext
       ↓
       ├─ 加载失败 → 返回错误提示给用户
       └─ 加载成功 →
            ↓
          【显示上下文】向用户展示将使用的上下文
            ↓
          【执行任务】按步骤执行命令定义的流程
            ├─ 更新 state.json: currentPhase = "architecture"
            ├─ 读取架构模板
            ├─ 逐模块设计架构
            └─ 生成架构文档
            ↓
          【审批检测】ApprovalDetector.detectApprovalPoint()
            ├─ 需要审批 → 生成审批提示，暂停等待
            └─ 不需审批 → 继续或完成
```

#### 流程2：审批命令执行流程

```
用户输入审批命令（如 /approve-architecture）
  ↓
【命令解析】CommandParser.parse()
  ├─ 解析命令名称: "approve-architecture"
  └─ 提取阶段名: "architecture"
  ↓
【审批处理】ApprovalHandler.handleApproval()
  ↓
  步骤1: 读取当前状态
  ↓
  步骤2: 检查阶段状态
  ├─ 已审批 → 返回错误"阶段已审批通过"
  ├─ 非in_progress → 返回错误"阶段状态不可审批"
  └─ in_progress → 继续
  ↓
  步骤3: 检查模块完成状态
  ├─ 有未完成模块 → 返回错误"以下模块尚未完成..."
  └─ 全部完成 → 继续
  ↓
  步骤4: 调用 stateManager.approvePhase()
  ↓
  步骤5: 更新 state.json
    - phases.architecture.status = "approved"
    - phases.architecture.approvedAt = 当前时间
    - phases.architecture.approvedBy = "human"
  ↓
  步骤6: Git commit（通过Git集成模块）
  ↓
  返回成功: "架构阶段审批通过，可以执行 /start-implementation"
```

#### 流程3：自定义任务执行流程

```
用户输入: /custom-task --modules=核心流程模型,状态管理模块 "分析集成点"
  ↓
【命令解析】CommandParser.parse()
  ├─ 命令名称: "custom-task"
  ├─ 命名参数: { modules: "核心流程模型,状态管理模块" }
  └─ 位置参数: ["分析集成点"]
  ↓
【上下文加载】ContextIntegrator.loadCustomContext()
  ├─ 解析模块列表: ["核心流程模型", "状态管理模块"]
  ├─ 对每个模块调用 stateManager.getContextForModule()
  ├─ 合并上下文，去重文档列表
  └─ 返回 ExecutionContext
  ↓
【显示上下文确认】
  展示:
    "将加载以下上下文:
     - docs/PRD/modules/核心流程模型-PRD.md
     - docs/PRD/modules/状态管理模块-PRD.md
     - docs/architecture/iteration-1/核心流程模型-*.md
     - docs/architecture/iteration-1/状态管理模块-*.md
     - state.json相关字段
     是否继续? (y/n)"
  ↓
用户确认 (y)
  ↓
【状态快照】StateProtector.takeSnapshot()
  └─ 记录执行前的state.json关键字段（阶段状态、模块状态）
  ↓
【执行任务】
  ├─ AI基于上下文执行"分析集成点"任务
  └─ 生成分析报告
  ↓
【状态验证】StateProtector.verifyUnchanged()
  ├─ 比对执行前后的状态快照
  ├─ 如有意外变更 → 抛出 StateIntegrityError，回滚状态
  └─ 如无变更 → 正常返回
  ↓
返回: "任务已完成，分析报告: ..."

注: 自定义任务不影响state.json的阶段状态（仅为临时任务）
```

**状态保护机制设计**：

```typescript
/**
 * StateProtector - 状态保护器（用于/custom-task）
 * 确保自定义任务不会意外修改项目状态
 */
class StateProtector {
  private snapshot: StateSnapshot | null = null;

  /**
   * 拍摄状态快照
   */
  async takeSnapshot(): Promise<void> {
    const state = await this.stateManager.readState();
    this.snapshot = {
      currentPhase: state.iterations[state.currentIteration].currentPhase,
      phaseStatuses: this.extractPhaseStatuses(state),
      moduleStatuses: this.extractModuleStatuses(state),
      takenAt: new Date().toISOString()
    };
  }

  /**
   * 验证状态未被修改
   */
  async verifyUnchanged(): Promise<void> {
    if (!this.snapshot) {
      throw new Error('未拍摄状态快照');
    }

    const currentState = await this.stateManager.readState();
    const currentSnapshot = {
      currentPhase: currentState.iterations[currentState.currentIteration].currentPhase,
      phaseStatuses: this.extractPhaseStatuses(currentState),
      moduleStatuses: this.extractModuleStatuses(currentState)
    };

    // 比对关键字段
    if (!this.snapshotsEqual(this.snapshot, currentSnapshot)) {
      // 回滚状态
      await this.rollbackToSnapshot();
      throw new StateIntegrityError(
        '自定义任务不应修改项目状态，已自动回滚'
      );
    }
  }

  private snapshotsEqual(a: StateSnapshot, b: Partial<StateSnapshot>): boolean {
    return (
      a.currentPhase === b.currentPhase &&
      JSON.stringify(a.phaseStatuses) === JSON.stringify(b.phaseStatuses) &&
      JSON.stringify(a.moduleStatuses) === JSON.stringify(b.moduleStatuses)
    );
  }
}
```

---

## 四、对外接口 {#arch-命令体系-对外接口}

命令体系模块主要作为调用方，对外暴露的接口较少：

### 4.1 命令执行接口

```typescript
/**
 * CommandExecutor - 命令执行入口
 */
export interface CommandExecutor {
  /**
   * 执行命令
   * @param input 用户输入的原始命令字符串
   * @returns 执行结果
   */
  execute(input: string): Promise<ExecutionResult>;

  /**
   * 获取命令帮助
   * @param commandName 命令名称（可选，不提供则返回所有命令帮助）
   */
  getHelp(commandName?: string): Promise<CommandHelp>;

  /**
   * 获取命令列表
   */
  listCommands(): Promise<CommandInfo[]>;
}
```

### 4.2 执行结果类型

```typescript
interface ExecutionResult {
  /** 是否成功 */
  success: boolean;

  /** 命令名称 */
  command: string;

  /** 执行消息 */
  message: string;

  /** 错误信息（失败时） */
  errors?: string[];

  /** 警告信息 */
  warnings?: string[];

  /** 是否在审批点暂停 */
  waitingForApproval?: boolean;

  /** 审批信息（如果在审批点） */
  approvalInfo?: ApprovalPointInfo;

  /** 建议的下一步操作 */
  nextAction?: string;

  /** 产出文档 */
  artifacts?: string[];
}

interface CommandInfo {
  /** 命令名称 */
  name: string;

  /** 命令描述 */
  description: string;

  /** 参数定义 */
  parameters: ParameterInfo[];

  /** 是否需要审批 */
  needsApproval: boolean;
}

interface CommandHelp {
  /** 命令名称 */
  name: string;

  /** 详细描述 */
  description: string;

  /** 用法示例 */
  usage: string[];

  /** 参数说明 */
  parameters: ParameterHelp[];

  /** 前置条件说明 */
  preconditions: string[];
}
```

### 4.3 类型导出

```typescript
export type {
  // 命令相关
  ParsedCommand,
  CommandArgs,
  CommandDefinition,
  CommandInfo,
  CommandHelp,

  // 执行相关
  ExecutionResult,
  ExecutionContext,

  // 前置条件相关
  PreconditionResult,
  PreconditionDefinition,

  // 审批相关
  ApprovalPointInfo,
  ApprovalResult,

  // 错误类型
  InvalidCommandError,
  CommandNotFoundError,
  PreconditionFailedError,
  ContextLoadError
};
```

---

## 五、非功能性设计

### 5.1 性能设计

**响应时间目标**：
- 命令解析: < 50ms
- 前置条件检查: < 100ms（依赖状态管理模块）
- 上下文加载: < 200ms（依赖状态管理模块）

**优化策略**：

| 优化点 | 策略 | 预期效果 |
|-------|------|---------|
| 命令定义缓存 | 首次读取后缓存 | 避免重复文件IO |
| 前置条件并行检查 | 独立检查项并行执行 | 减少总检查时间 |
| 上下文预计算 | 阶段开始时预计算下一步上下文 | 减少用户等待 |

### 5.2 可靠性设计

**错误处理**：

| 错误场景 | 处理策略 | 用户提示 |
|---------|---------|---------|
| 命令格式错误 | 返回用法说明 | "用法: /command-name [参数]" |
| 命令不存在 | 返回可用命令列表 | "未知命令，可用命令: /start-requirements..." |
| 前置条件不满足 | 返回具体原因 | "需求阶段尚未完成，无法启动架构设计" |
| 上下文加载失败 | 返回错误原因 | "上下文加载失败: 模块X的PRD文档不存在" |
| 状态更新失败 | 回滚操作 | "状态更新失败，请稍后重试" |

**容错机制**：
- 命令执行失败时，state.json回滚到执行前状态
- 每次新会话开始时读取state.json，了解当前进度继续工作（会话恢复）
- 注：不支持命令执行中途的断点恢复（会话中断时无法可靠捕获状态）

### 5.3 可维护性设计

**日志策略**：

```typescript
// INFO: 命令执行
logger.info('Command executed', {
  command: '/start-architecture',
  duration: '150ms',
  success: true
});

// WARN: 前置条件警告
logger.warn('Precondition warning', {
  command: '/start-testing',
  warning: '有2个模块覆盖率未达100%'
});

// ERROR: 执行失败
logger.error('Command execution failed', {
  command: '/approve-requirements',
  error: '模块"核心流程模型"尚未完成'
});
```

### 5.4 安全性设计

- **输入验证**: 所有命令参数进行严格验证
- **权限控制**: 依赖Claude CLI的会话权限
- **审计日志**: 所有命令执行记录到changeHistory

---

## 六、与其他模块的协作

### 6.1 依赖关系

```
【命令体系模块】
     │
     ├── 依赖 ──→ 【状态管理模块】
     │            · readState()
     │            · updateModuleStatus()
     │            · transitionPhase()
     │            · approvePhase()
     │            · getContextForPhase()
     │            · getContextForModule()
     │
     ├── 依赖 ──→ 【核心流程模型】
     │            · getPhaseDefinition()
     │            · validatePhaseTransition()
     │
     ├── 协作 ──→ 【文档模板模块】
     │            · 读取模板生成文档
     │
     └── 协作 ──→ 【Git集成模块】
                  · 状态变更后自动commit
```

### 6.2 调用时机

| 操作 | 调用的接口 | 所属模块 |
|------|----------|---------|
| 命令执行前 | readState() | 状态管理模块 |
| 前置条件检查 | getPhaseDefinition() | 核心流程模型 |
| 上下文加载 | getContextForPhase(), getContextForModule() | 状态管理模块 |
| 阶段流转 | transitionPhase() | 状态管理模块 |
| 审批执行 | approvePhase() | 状态管理模块 |
| 文档生成 | fillTemplate() | 文档模板模块 |
| 状态提交 | commitStateChange() | Git集成模块 |

---

## 七、架构演进计划

### 7.1 当前迭代范围(Iteration 1)

**已设计**：
- ✅ 8个核心命令定义
- ✅ 命令解析器
- ✅ 前置条件检查器
- ✅ 上下文集成器
- ✅ 审批控制器

**未实现(计划外)**：
- ⏳ 命令别名支持(v1.1)
- ⏳ 命令组合支持(v1.1)
- ⏳ 命令历史记录(v1.1)

### 7.2 未来迭代规划

**Iteration 2 (v1.1)**：
- 新增: 命令别名（如 `/req` = `/start-requirements`）
- 新增: 命令组合（如 `/full-cycle` 依次执行所有阶段）
- 新增: 命令参数补全提示

**Iteration 3 (v2.0)**：
- 新增: 自定义命令支持
- 新增: 命令权限控制
- 新增: 多用户协作场景

### 7.3 技术债务

| 债务描述 | 影响 | 计划解决时间 |
|---------|------|------------|
| 命令定义解析依赖AI理解 | 可能有解析偏差 | Iteration 2（增加结构化元数据） |
| 无命令执行超时机制 | 长时间任务可能卡住 | Iteration 2 |

---

## 八、总结

### 核心设计理念

**命令体系模块是"交互入口"，不是"业务执行者"**：
- 定义命令，不实现业务逻辑
- 协调模块，不直接操作数据
- 控制审批，不决定审批条件

### 关键成功因素

1. **命令即配置**: 命令定义清晰、可扩展
2. **上下文驱动**: 精确加载相关上下文
3. **审批点机制**: 关键节点强制暂停
4. **友好错误处理**: 用户能理解如何修复
5. **与状态管理模块紧密集成**: 确保状态一致性

### 架构图示

```
┌─────────────────────────────────────────────────────┐
│              【命令体系模块】                          │
│  ═══════════════════════════════════════════════   │
│  ┌─────────────────────────────────────────────┐   │
│  │  命令定义仓库: .claude/commands/*.md        │   │
│  │  · 8个核心命令定义                           │   │
│  └────────────────────┬────────────────────────┘   │
│                       ↓                             │
│  ┌─────────────────────────────────────────────┐   │
│  │  命令执行层                                   │   │
│  │  · CommandParser: 解析命令                   │   │
│  │  · PreconditionChecker: 检查前置条件         │   │
│  │  · ContextIntegrator: 加载上下文             │   │
│  │  · StepExecutor: 执行步骤                    │   │
│  └────────────────────┬────────────────────────┘   │
│                       ↓                             │
│  ┌─────────────────────────────────────────────┐   │
│  │  审批控制层                                   │   │
│  │  · ApprovalDetector: 检测审批点              │   │
│  │  · ApprovalHandler: 处理审批命令             │   │
│  └─────────────────────────────────────────────┘   │
└───────────────────────┬─────────────────────────────┘
                        ↓ 协作
    ┌───────────────────┼───────────────────┐
    │                   │                   │
┌───┴───────┐   ┌───────┴───────┐   ┌───────┴───────┐
│状态管理模块│   │核心流程模型   │   │文档模板/Git集成│
│ · 状态读写 │   │ · 验证规则    │   │ · 文档生成    │
│ · 上下文   │   │ · 阶段定义    │   │ · 自动提交    │
└───────────┘   └───────────────┘   └───────────────┘
```
