# 核心流程模型 - 集成设计

<!--
章节ID规范说明：
- 格式：{#arch-集成-核心流程-[章节标识]}
- 必须标注ID的章节：调用序列、接口定义、集成点
- 示例：{#arch-集成-核心流程-接口汇总} 表示核心流程模型集成设计的接口汇总章节
-->

> **项目**: AI超级个体开发助手
> **版本**: v1.0.0
> **迭代**: Iteration 1
> **模块**: 核心流程模型
> **日期**: 2025-12-14
> **集成复杂度**: 简单(simple)

---

## 一、集成概述

### 1.1 涉及模块

核心流程模型作为**元模型层**,被以下模块依赖:

| 模块名称 | 依赖关系 | 集成复杂度 | 集成文档 |
|---------|---------|-----------|---------|
| **状态管理模块** | 依赖核心流程模型 | simple | 本文档 |
| **命令体系模块** | 依赖核心流程模型 | simple | 本文档 |
| **影响分析模块** | 依赖核心流程模型 | simple | 本文档 |
| **文档模板模块** | 依赖核心流程模型 | simple | 本文档 |
| **测试验证模块** | 依赖核心流程模型 | simple | 本文档 |
| **Git集成模块** | 间接依赖(通过状态管理模块) | - | - |

### 1.2 集成目标

**核心流程模型的集成目标**:
1. 为其他模块提供阶段定义、依赖关系、验证规则等元数据
2. 提供纯函数算法(拓扑排序、影响分析)供其他模块调用
3. 确保所有模块对"阶段"、"模块依赖"有统一的理解

### 1.3 集成复杂度说明

**为何标记为"simple"**:
- ✅ 核心流程模型只提供只读接口和纯函数算法
- ✅ 无状态依赖,所有函数为纯函数(无副作用)
- ✅ 单向依赖,不存在循环依赖
- ✅ 接口清晰,参数简单,无复杂数据转换

---

## 二、集成点详细设计

### 集成点1: 核心流程模型 → 状态管理模块 {#集成点1-状态管理}

#### 2.1.1 集成概述

**调用方**: 状态管理模块
**被调用方**: 核心流程模型

**集成目的**:
- 状态管理模块需要获取阶段定义(PhaseDefinition)以执行状态流转
- 状态管理模块需要验证阶段流转是否合法
- 状态管理模块需要验证state.json的完整性

#### 2.1.2 调用序列

```
【状态管理模块】.transitionPhase(currentPhase, targetPhase)
  ↓
  步骤1: 调用【核心流程模型】.getPhaseDefinition(currentPhase)
     → 获取当前阶段定义
  ↓
  步骤2: 调用【核心流程模型】.getPhaseDefinition(targetPhase)
     → 获取目标阶段定义
  ↓
  步骤3: 调用【核心流程模型】.validatePhaseTransition(current, target)
     → 验证流转是否合法
  ↓
  步骤4: (如果验证通过) 更新state.json
  ↓
  步骤5: 调用【核心流程模型】.validateStateIntegrity(newState)
     → 验证更新后的state.json一致性
  ↓
  返回流转结果
```

#### 2.1.3 接口定义 {#集成点1-接口}

**接口1: getPhaseDefinition**

```typescript
/**
 * 获取阶段定义
 * @param phaseName - 阶段名称
 * @returns 阶段定义
 * @throws PhaseNotFoundError - 阶段不存在
 */
function getPhaseDefinition(phaseName: string): PhaseDefinition {
  const definition = phaseDefinitions[phaseName];
  if (!definition) {
    throw new PhaseNotFoundError(`Phase "${phaseName}" not found`);
  }
  return definition;
}
```

**参数**:
- `phaseName`: `'requirements' | 'architecture' | 'implementation' | 'testing' | 'deployment'`

**返回值**:
```typescript
interface PhaseDefinition {
  name: string;
  order: number;
  needsApproval: boolean;
  artifactTypes: string[];
  nextPhase: string | null;
  canRollbackTo: string[];
  validators: string[];
  completionCriteria: {
    minModuleStatus: ModuleStatus;
    requireAllModules: boolean;
  };
}
```

**错误处理**:
- `PhaseNotFoundError`: 阶段名称不合法

---

**接口2: validatePhaseTransition**

```typescript
/**
 * 验证阶段流转是否合法
 * @param currentPhase - 当前阶段
 * @param targetPhase - 目标阶段
 * @returns 验证结果
 */
function validatePhaseTransition(
  currentPhase: string,
  targetPhase: string
): ValidationResult {
  // 实现见"数据模型设计.md"
}
```

**参数**:
- `currentPhase`: 当前阶段名称
- `targetPhase`: 目标阶段名称

**返回值**:
```typescript
interface ValidationResult {
  isValid: boolean;
  errors: string[];    // 阻塞性错误
  warnings: string[];  // 非阻塞性警告
}
```

**验证逻辑**:
1. 正向流转: 检查`currentPhase.nextPhase === targetPhase`
2. 回滚: 检查`currentPhase.canRollbackTo.includes(targetPhase)`
3. 非法流转: 返回`isValid: false`

---

**接口3: validateStateIntegrity**

```typescript
/**
 * 验证state.json的完整性
 * @param state - 完整的state对象
 * @returns 验证结果
 */
function validateStateIntegrity(state: State): ValidationResult {
  // 执行7类完整性约束验证
  // 实现见"数据模型设计.md"
}
```

**参数**:
- `state`: 完整的state对象

**返回值**: `ValidationResult`

**验证内容**:
- 约束1: currentIteration存在性
- 约束2: currentPhase存在性
- 约束3: 模块名称一致性
- 约束4: 已完成阶段模块状态
- 约束5: 阶段顺序一致性
- 约束6: 依赖关系DAG
- 约束7: 依赖关系双向一致

#### 2.1.4 数据流图

```
【状态管理模块】
  ↓ phaseName
【核心流程模型】.getPhaseDefinition()
  ↓ PhaseDefinition
【状态管理模块】
  ↓ currentPhase + targetPhase
【核心流程模型】.validatePhaseTransition()
  ↓ ValidationResult
【状态管理模块】
  ↓ newState
【核心流程模型】.validateStateIntegrity()
  ↓ ValidationResult
【状态管理模块】
```

#### 2.1.5 错误处理

| 错误类型 | 处理策略 | 是否重试 |
|---------|---------|---------|
| `PhaseNotFoundError` | 阻止流转,记录错误日志 | 否 |
| `ValidationError` | 阻止流转,展示错误给用户 | 否 |

---

### 集成点2: 核心流程模型 → 命令体系模块 {#集成点2-命令体系}

#### 2.2.1 集成概述

**调用方**: 命令体系模块
**被调用方**: 核心流程模型

**集成目的**:
- 命令执行前验证阶段流转是否合法
- 获取阶段定义以判断是否需要人工审批

#### 2.2.2 调用序列

```
用户执行命令: /approve
  ↓
【命令体系模块】.handleApproveCommand()
  ↓
  步骤1: 读取state.json获取currentPhase
  ↓
  步骤2: 调用【核心流程模型】.getPhaseDefinition(currentPhase)
     → 获取阶段定义
  ↓
  步骤3: 检查 definition.needsApproval === true
  ↓
  步骤4: 调用【状态管理模块】.approvePhase()
  ↓
  返回结果给用户
```

#### 2.2.3 接口定义 {#集成点2-接口}

**接口: getPhaseDefinition**

(与集成点1相同,复用接口)

#### 2.2.4 使用示例

```typescript
// 命令体系模块中的实现
class ApproveCommand {
  async execute(): Promise<void> {
    const state = await stateManager.readState();
    const currentPhase = state.iterations[state.currentIteration].currentPhase;

    // 调用核心流程模型获取阶段定义
    const phaseDefinition = coreProcessModel.getPhaseDefinition(currentPhase);

    if (!phaseDefinition.needsApproval) {
      throw new Error(`Phase "${currentPhase}" does not require approval`);
    }

    // 执行审批逻辑
    await stateManager.approvePhase(currentPhase, 'human');
  }
}
```

---

### 集成点3: 核心流程模型 → 影响分析模块 {#集成点3-影响分析}

#### 2.3.1 集成概述

**调用方**: 影响分析模块
**被调用方**: 核心流程模型

**集成目的**:
- 影响分析模块调用核心流程模型的`analyzeImpact`算法
- 计算模块变更的影响范围

#### 2.3.2 调用序列

```
用户执行命令: /report-issue "支付模块" "退款逻辑错误"
  ↓
【影响分析模块】.analyzeIssue()
  ↓
  步骤1: 读取state.json获取moduleDependencies
  ↓
  步骤2: 调用【核心流程模型】.analyzeImpact(
           moduleName='支付模块',
           changeType='requirements',
           dependencies=moduleDependencies
         )
     → 获取影响报告
  ↓
  步骤3: 基于影响报告生成待办任务列表
  ↓
  步骤4: 展示影响报告给用户
  ↓
  返回影响报告
```

#### 2.3.3 接口定义 {#集成点3-接口}

**接口: analyzeImpact**

```typescript
/**
 * 影响分析算法 - 计算模块变更的影响范围
 * @param moduleName - 变更的模块名称
 * @param changeType - 变更类型
 * @param dependencies - 模块依赖关系图
 * @returns 影响分析报告
 */
function analyzeImpact(
  moduleName: string,
  changeType: ChangeType,
  dependencies: ModuleDependencies
): ImpactReport {
  // 使用BFS遍历dependedBy,找到所有受影响模块
  const affected: Set<string> = new Set([moduleName]);
  const queue: string[] = [moduleName];
  const propagationPath: PropagationPathItem[] = [];

  while (queue.length > 0) {
    const current = queue.shift()!;
    const currentDep = dependencies[current];

    if (!currentDep) continue;

    for (const dependentModule of currentDep.dependedBy) {
      if (!affected.has(dependentModule)) {
        affected.add(dependentModule);
        queue.push(dependentModule);

        propagationPath.push({
          module: dependentModule,
          reason: `Depends on ${current}`,
          depth: propagationPath.filter(p => p.module === current).length + 1
        });
      }
    }
  }

  // 根据变更类型确定影响的阶段
  const impactedPhases = determineImpactedPhases(changeType);

  // 预估工作量
  const estimatedEffort = calculateEffort(affected.size, changeType);

  // 建议回滚阶段
  const suggestedRollbackPhase = determinRollbackPhase(changeType);

  return {
    sourceModule: moduleName,
    changeType,
    affectedModules: Array.from(affected),
    impactedPhases,
    estimatedEffort,
    propagationPath,
    suggestedRollbackPhase
  };
}
```

**参数**:
- `moduleName`: 变更的模块名称
- `changeType`: `'requirements' | 'architecture' | 'implementation' | 'testing' | 'hotfix'`
- `dependencies`: 完整的模块依赖关系图

**返回值**:
```typescript
interface ImpactReport {
  sourceModule: string;
  changeType: ChangeType;
  affectedModules: string[];         // 受影响的模块列表
  impactedPhases: string[];          // 受影响的阶段列表
  estimatedEffort: number;           // 预估工作量(人天)
  propagationPath?: PropagationPathItem[];
  suggestedRollbackPhase: string;    // 建议回滚到的阶段
}
```

**算法复杂度**: O(V + E),其中V是模块数,E是依赖边数

#### 2.3.4 使用示例

```typescript
// 影响分析模块中的实现
class ImpactAnalyzer {
  async analyzeIssue(
    moduleName: string,
    issueDescription: string
  ): Promise<ImpactReport> {
    const state = await stateManager.readState();
    const dependencies = state.moduleDependencies;

    // 根据问题描述推断变更类型
    const changeType = this.inferChangeType(issueDescription);

    // 调用核心流程模型的影响分析算法
    const report = coreProcessModel.analyzeImpact(
      moduleName,
      changeType,
      dependencies
    );

    // 记录到日志
    logger.info('Impact analysis completed', {
      sourceModule: moduleName,
      affectedCount: report.affectedModules.length,
      suggestedRollback: report.suggestedRollbackPhase
    });

    return report;
  }
}
```

---

### 集成点4: 核心流程模型 → 文档模板模块 {#集成点4-文档模板}

#### 2.4.1 集成概述

**调用方**: 文档模板模块
**被调用方**: 核心流程模型

**集成目的**:
- 文档模板模块需要获取阶段定义以填充模板变量
- 例如: 生成架构文档时需要知道`architecture`阶段的`artifactTypes`

#### 2.4.2 调用序列

```
【文档模板模块】.generateArchitectureDoc(moduleName)
  ↓
  步骤1: 读取模板文件
  ↓
  步骤2: 调用【核心流程模型】.getPhaseDefinition('architecture')
     → 获取architecture阶段定义
  ↓
  步骤3: 使用definition.artifactTypes填充模板变量
  ↓
  步骤4: 生成完整文档
  ↓
  返回文档内容
```

#### 2.4.3 接口定义 {#集成点4-接口}

**接口: getPhaseDefinition**

(与集成点1相同,复用接口)

**接口: getAllPhaseDefinitions**

```typescript
/**
 * 获取所有阶段定义
 * @returns 所有阶段定义的映射
 */
function getAllPhaseDefinitions(): Record<string, PhaseDefinition> {
  return { ...phaseDefinitions };
}
```

**返回值**: `Record<string, PhaseDefinition>`

---

### 集成点5: 核心流程模型 → 测试验证模块 {#集成点5-测试验证}

#### 2.5.1 集成概述

**调用方**: 测试验证模块
**被调用方**: 核心流程模型

**集成目的**:
- 测试验证模块需要获取阶段定义以生成测试用例
- 验证测试流程是否符合阶段定义

#### 2.5.2 调用序列

```
【测试验证模块】.generateE2ETestPlan()
  ↓
  步骤1: 调用【核心流程模块】.getPhaseDefinition('testing')
     → 获取testing阶段定义
  ↓
  步骤2: 根据definition.artifactTypes确定需要生成的测试文档类型
  ↓
  步骤3: 生成测试计划文档
  ↓
  返回测试计划
```

#### 2.5.3 接口定义 {#集成点5-接口}

**接口: getPhaseDefinition**

(与集成点1相同,复用接口)

---

## 三、通用集成接口汇总 {#arch-集成-核心流程-接口汇总}

### 3.1 配置访问接口

```typescript
export interface CoreProcessModelAPI {
  /** 获取阶段定义 */
  getPhaseDefinition(phaseName: string): PhaseDefinition;

  /** 获取所有阶段定义 */
  getAllPhaseDefinitions(): Record<string, PhaseDefinition>;
}
```

### 3.2 算法接口

```typescript
export interface CoreProcessAlgorithms {
  /** 拓扑排序 */
  topologicalSort(dependencies: ModuleDependencies): string[];

  /** 并行调度 */
  scheduleParallelExecution(dependencies: ModuleDependencies): string[][];

  /** 影响分析 */
  analyzeImpact(
    moduleName: string,
    changeType: ChangeType,
    dependencies: ModuleDependencies
  ): ImpactReport;
}
```

### 3.3 验证接口

```typescript
export interface CoreProcessValidators {
  /** 验证状态完整性 */
  validateStateIntegrity(state: State): ValidationResult;

  /** 验证依赖关系 */
  validateDependencies(dependencies: ModuleDependencies): ValidationResult;

  /** 验证阶段流转 */
  validatePhaseTransition(
    currentPhase: string,
    targetPhase: string
  ): ValidationResult;

  /** 验证模块状态流转 */
  validateModuleTransition(
    currentStatus: ModuleStatus,
    targetStatus: ModuleStatus
  ): ValidationResult;
}
```

### 3.4 类型导出

```typescript
export type {
  // Phase相关
  PhaseStatus, PhaseDefinition, PhaseState,

  // Iteration相关
  IterationStatus, Iteration,

  // Module相关
  ModuleStatus, ModuleState, ModuleDependency, IntegrationPoint,

  // Transition相关
  TransitionRequest, TransitionResult,

  // Validation相关
  ValidationResult,

  // ImpactAnalysis相关
  ChangeType, ImpactReport
};
```

---

## 四、集成示例代码

### 4.1 状态管理模块集成示例

```typescript
// state-manager.ts
import {
  CoreProcessModelAPI,
  CoreProcessValidators,
  PhaseDefinition,
  ValidationResult
} from '@/core-process-model';

class StateManager {
  constructor(
    private coreProcess: CoreProcessModelAPI & CoreProcessValidators
  ) {}

  async transitionPhase(targetPhase: string): Promise<void> {
    const state = await this.readState();
    const currentPhase = state.iterations[state.currentIteration].currentPhase;

    // 1. 验证阶段流转
    const validation = this.coreProcess.validatePhaseTransition(
      currentPhase,
      targetPhase
    );

    if (!validation.isValid) {
      throw new Error(`Invalid phase transition: ${validation.errors.join(', ')}`);
    }

    // 2. 执行状态更新
    state.iterations[state.currentIteration].currentPhase = targetPhase;
    state.iterations[state.currentIteration].phases[currentPhase].status = 'completed';
    state.iterations[state.currentIteration].phases[targetPhase].status = 'in_progress';

    // 3. 验证更新后的状态
    const stateValidation = this.coreProcess.validateStateIntegrity(state);

    if (!stateValidation.isValid) {
      throw new Error(`State integrity check failed: ${stateValidation.errors.join(', ')}`);
    }

    // 4. 保存state.json
    await this.writeState(state);

    logger.info('Phase transition completed', {
      from: currentPhase,
      to: targetPhase,
      warnings: validation.warnings
    });
  }
}
```

### 4.2 影响分析模块集成示例

```typescript
// impact-analyzer.ts
import {
  CoreProcessAlgorithms,
  ImpactReport,
  ChangeType
} from '@/core-process-model';

class ImpactAnalyzer {
  constructor(private coreProcess: CoreProcessAlgorithms) {}

  async analyzeModuleChange(
    moduleName: string,
    changeType: ChangeType
  ): Promise<ImpactReport> {
    const state = await stateManager.readState();
    const dependencies = state.moduleDependencies;

    // 调用核心流程模型的影响分析算法
    const report = this.coreProcess.analyzeImpact(
      moduleName,
      changeType,
      dependencies
    );

    // 生成待办任务
    const tasks = this.generateTasks(report);

    logger.info('Impact analysis completed', {
      sourceModule: moduleName,
      affectedModules: report.affectedModules,
      estimatedEffort: report.estimatedEffort,
      tasksGenerated: tasks.length
    });

    return report;
  }

  private generateTasks(report: ImpactReport): Task[] {
    const tasks: Task[] = [];

    for (const module of report.affectedModules) {
      for (const phase of report.impactedPhases) {
        tasks.push({
          title: `重新${this.getPhaseAction(phase)} ${module}`,
          phase,
          module,
          priority: module === report.sourceModule ? 'P0' : 'P1'
        });
      }
    }

    return tasks;
  }
}
```

### 4.3 命令体系模块集成示例

```typescript
// commands/approve.ts
import { CoreProcessModelAPI, PhaseDefinition } from '@/core-process-model';

class ApproveCommand {
  constructor(private coreProcess: CoreProcessModelAPI) {}

  async execute(): Promise<void> {
    const state = await stateManager.readState();
    const iteration = state.iterations[state.currentIteration];
    const currentPhase = iteration.currentPhase;

    // 获取阶段定义
    const phaseDefinition = this.coreProcess.getPhaseDefinition(currentPhase);

    // 检查是否需要审批
    if (!phaseDefinition.needsApproval) {
      throw new Error(
        `Phase "${currentPhase}" does not require approval (needsApproval=false)`
      );
    }

    // 检查完成条件
    const meetsCompletionCriteria = this.checkCompletionCriteria(
      iteration.phases[currentPhase],
      phaseDefinition
    );

    if (!meetsCompletionCriteria) {
      throw new Error(
        `Phase "${currentPhase}" does not meet completion criteria`
      );
    }

    // 执行审批
    await stateManager.approvePhase(currentPhase, 'human');

    console.log(`Phase "${currentPhase}" approved successfully`);
  }
}
```

---

## 五、错误处理与监控

### 5.1 错误分类

| 错误类型 | 处理策略 | 是否重试 | 日志级别 |
|---------|---------|---------|---------|
| `PhaseNotFoundError` | 阻止操作,记录错误 | 否 | ERROR |
| `ValidationError` | 阻止操作,展示给用户 | 否 | ERROR |
| `CircularDependencyError` | 阻止操作,记录详细依赖链 | 否 | ERROR |
| `InvalidInputError` | 阻止操作,提示正确格式 | 否 | WARN |

### 5.2 监控指标

| 指标名称 | 监控目标 | 告警阈值 |
|---------|---------|---------|
| 算法执行时间 | < 10ms | > 50ms |
| 验证失败率 | < 1% | > 5% |
| API调用频率 | - | > 1000次/分钟 |

### 5.3 日志规范

```typescript
// 日志示例
logger.info('Phase transition validation', {
  currentPhase: 'requirements',
  targetPhase: 'architecture',
  isValid: true,
  warnings: ['Some modules not completed']
});

logger.error('State validation failed', {
  errors: ['currentIteration not found'],
  state: state  // 记录完整state以便调试
});
```

---

## 六、性能优化

### 6.1 缓存策略

```typescript
// 阶段定义缓存(静态配置,全局复用)
const phaseDefinitionsCache = new Map<string, PhaseDefinition>();

// 拓扑排序结果缓存(依赖关系未变时复用)
const topologicalSortCache = new WeakMap<ModuleDependencies, string[]>();

// 影响分析结果缓存(模块+变更类型+依赖关系作为key)
const impactAnalysisCache = new Map<string, ImpactReport>();
```

### 6.2 性能基准

**当前性能指标** (模块数=10):
- `getPhaseDefinition`: < 1ms
- `topologicalSort`: ~2ms
- `analyzeImpact`: ~5ms
- `validateStateIntegrity`: ~3ms

**性能目标** (模块数=50):
- `getPhaseDefinition`: < 1ms
- `topologicalSort`: < 10ms
- `analyzeImpact`: < 20ms
- `validateStateIntegrity`: < 10ms

---

## 七、测试策略

### 7.1 单元测试

**测试覆盖**:
- ✅ 所有公开接口
- ✅ 所有算法(正常场景+异常场景)
- ✅ 所有验证器

**测试用例示例**:
```typescript
describe('CoreProcessModel', () => {
  describe('getPhaseDefinition', () => {
    it('should return phase definition for valid phase', () => {
      const definition = coreProcess.getPhaseDefinition('requirements');
      expect(definition.name).toBe('requirements');
      expect(definition.order).toBe(1);
    });

    it('should throw PhaseNotFoundError for invalid phase', () => {
      expect(() => coreProcess.getPhaseDefinition('invalid'))
        .toThrow(PhaseNotFoundError);
    });
  });

  describe('analyzeImpact', () => {
    it('should return affected modules for linear dependency', () => {
      const dependencies = {
        'A': { dependsOn: [], dependedBy: ['B'] },
        'B': { dependsOn: ['A'], dependedBy: ['C'] },
        'C': { dependsOn: ['B'], dependedBy: [] }
      };

      const report = coreProcess.analyzeImpact('A', 'requirements', dependencies);

      expect(report.affectedModules).toEqual(['A', 'B', 'C']);
    });

    it('should detect circular dependency', () => {
      const dependencies = {
        'A': { dependsOn: ['B'], dependedBy: [] },
        'B': { dependsOn: ['A'], dependedBy: [] }
      };

      expect(() => coreProcess.analyzeImpact('A', 'requirements', dependencies))
        .toThrow(CircularDependencyError);
    });
  });
});
```

### 7.2 集成测试

**测试场景**:
1. 状态管理模块 + 核心流程模型: 完整阶段流转流程
2. 影响分析模块 + 核心流程模型: 变更影响分析流程
3. 命令体系模块 + 核心流程模型: 命令验证流程

---

## 八、总结

### 8.1 集成关系图

```
┌─────────────────────────────────────────────┐
│         【核心流程模型】                     │
│  ─────────────────────────────────────────  │
│  Exports:                                   │
│  · getPhaseDefinition()                     │
│  · getAllPhaseDefinitions()                 │
│  · topologicalSort()                        │
│  · analyzeImpact()                          │
│  · validatePhaseTransition()                │
│  · validateStateIntegrity()                 │
│  · validateDependencies()                   │
└───────────────┬─────────────────────────────┘
                ↑ 被依赖
    ┌───────────┼───────────┬──────────┬──────────┐
    │           │           │          │          │
┌───┴───┐  ┌───┴────┐  ┌──┴────┐  ┌──┴────┐  ┌──┴────┐
│状态管理│  │命令体系│  │影响分析│  │文档模板│  │测试验证│
│模块   │  │模块    │  │模块    │  │模块    │  │模块    │
└───────┘  └────────┘  └────────┘  └────────┘  └────────┘
```

### 8.2 集成特点

1. **单向依赖**: 所有模块依赖核心流程模型,无循环依赖
2. **只读接口**: 核心流程模型只提供只读接口,不修改外部状态
3. **纯函数算法**: 无副作用,易测试,可缓存
4. **清晰职责**: 核心流程模型只负责"规则定义",不负责"业务执行"

### 8.3 关键成功因素

- ✅ 接口简单清晰,参数少,无复杂数据转换
- ✅ 纯函数设计,无副作用,易于单元测试
- ✅ 错误处理完善,异常信息清晰
- ✅ 性能优化(缓存策略),满足性能目标

---

## 九、补充设计(评审后新增)

> 本节基于架构评审反馈,补充以下内容

### 9.1 新增算法接口

#### determineImpactedPhases - 确定影响阶段

```typescript
/**
 * 确定变更影响的阶段
 * @param changeType - 变更类型
 * @returns 受影响的阶段列表
 */
function determineImpactedPhases(changeType: ChangeType): string[];
```

**调用方**: 影响分析模块
**用途**: 根据变更类型确定需要重新执行的阶段
**复杂度**: simple (O(1)映射查找)

**使用示例**:
```typescript
// 影响分析模块中使用
const impactedPhases = coreProcess.determineImpactedPhases('requirements');
// 返回: ['requirements', 'architecture', 'implementation', 'testing']
```

---

#### calculateEffort - 预估工作量

```typescript
/**
 * 预估变更的工作量
 * @param affectedModuleCount - 受影响的模块数量
 * @param changeType - 变更类型
 * @returns 预估工作量(人天)
 */
function calculateEffort(
  affectedModuleCount: number,
  changeType: ChangeType
): number;
```

**调用方**: 影响分析模块
**用途**: 预估回滚和重做的工作量,帮助用户决策
**复杂度**: simple (O(1)计算)

**使用示例**:
```typescript
// 影响分析模块中使用
const effort = coreProcess.calculateEffort(3, 'architecture');
// 返回: 5.0 (人天)
```

---

### 9.2 新增分层分析框架接口

#### getRootCauseAnalysisFramework - 获取分层分析框架

```typescript
/**
 * 获取分层分析框架配置
 * @returns 分层分析框架定义
 */
function getRootCauseAnalysisFramework(): RootCauseAnalysisFramework;
```

**调用方**: 影响分析模块
**用途**: 获取分层分析的层次定义、回滚映射、分析提示
**复杂度**: simple

**使用示例**:
```typescript
// 影响分析模块中使用
const framework = coreProcess.getRootCauseAnalysisFramework();

// 按层次进行分析
for (const layer of framework.layers) {
  const conclusion = await ai.analyze(layer.question, testFailure);

  if (conclusion === '测试用例问题') {
    const rollbackPhase = framework.rollbackMapping['test_case_issue'];
    // rollbackPhase = 'testing'
    break;
  }
  // 继续下一层分析...
}
```

---

### 9.3 职责归属明确: changeHistory维护

**决策**: **changeHistory由状态管理模块负责维护**

**原因**:
- 状态管理模块负责所有state.json的写入操作
- changeHistory是state.json的一部分
- 每次写入操作应自动记录变更历史

**集成方式**:
核心流程模型不提供changeHistory写入接口,状态管理模块内部实现。

```typescript
// 状态管理模块内部实现(参考)
class StateManager {
  // 所有写入操作自动记录changeHistory
  async updateModuleStatus(moduleName: string, newStatus: ModuleStatus): Promise<void> {
    const oldStatus = this.getModuleStatus(moduleName);

    // 1. 更新状态
    // ...

    // 2. 自动记录changeHistory
    this.state.changeHistory.push({
      timestamp: new Date().toISOString(),
      type: 'module_status_change',
      description: `模块${moduleName}状态从${oldStatus}变更为${newStatus}`,
      changedBy: 'ai',
      changes: [{ field: `modules.${moduleName}.status`, from: oldStatus, to: newStatus }]
    });

    // 3. 保存state.json
    await this.writeState(this.state);
  }
}
```

---

### 9.4 更新接口汇总

#### 算法接口(更新)

```typescript
export interface CoreProcessAlgorithms {
  /** 拓扑排序 */
  topologicalSort(dependencies: ModuleDependencies): string[];

  /** 并行调度 */
  scheduleParallelExecution(dependencies: ModuleDependencies): string[][];

  /** 影响分析 */
  analyzeImpact(
    moduleName: string,
    changeType: ChangeType,
    dependencies: ModuleDependencies
  ): ImpactReport;

  /** 确定影响阶段 (新增) */
  determineImpactedPhases(changeType: ChangeType): string[];

  /** 预估工作量 (新增) */
  calculateEffort(affectedModuleCount: number, changeType: ChangeType): number;
}
```

#### 配置访问接口(更新)

```typescript
export interface CoreProcessModelAPI {
  /** 获取阶段定义 */
  getPhaseDefinition(phaseName: string): PhaseDefinition;

  /** 获取所有阶段定义 */
  getAllPhaseDefinitions(): Record<string, PhaseDefinition>;

  /** 获取分层分析框架 (新增) */
  getRootCauseAnalysisFramework(): RootCauseAnalysisFramework;
}
```

#### 类型导出(更新)

```typescript
export type {
  // Phase相关
  PhaseStatus, PhaseDefinition, PhaseState,

  // Testing子阶段相关 (新增)
  TestingPhaseState, TestSubPhaseState, TestSubPhaseStatus,

  // Iteration相关
  IterationStatus, Iteration,

  // Module相关
  ModuleStatus, ModuleState, ModuleDependency, IntegrationPoint,

  // Transition相关
  TransitionRequest, TransitionResult,

  // Validation相关
  ValidationResult,

  // ImpactAnalysis相关
  ChangeType, ImpactReport,

  // 分层分析相关 (新增)
  RootCauseAnalysisFramework, AnalysisLayer, RootCauseType, RootCauseAnalysisResult,

  // 回滚相关 (新增)
  RollbackRule, CascadeRollbackRule
};
```

---

### 9.5 更新集成关系图

```
┌───────────────────────────────────────────────────────┐
│              【核心流程模型】                          │
│  ───────────────────────────────────────────────────  │
│  Exports:                                             │
│  · getPhaseDefinition()                               │
│  · getAllPhaseDefinitions()                           │
│  · getRootCauseAnalysisFramework()     (新增)         │
│  · topologicalSort()                                  │
│  · analyzeImpact()                                    │
│  · determineImpactedPhases()           (新增)         │
│  · calculateEffort()                   (新增)         │
│  · validatePhaseTransition()                          │
│  · validateStateIntegrity()                           │
│  · validateDependencies()                             │
└────────────────────────┬──────────────────────────────┘
                         ↑ 被依赖
    ┌────────────────────┼────────────────┬─────────────┐
    │                    │                │             │
┌───┴────┐  ┌────────┐  ┌┴───────┐  ┌────┴────┐  ┌────┴────┐
│状态管理 │  │命令体系│  │影响分析│  │文档模板 │  │测试验证 │
│模块    │  │模块    │  │模块    │  │模块     │  │模块     │
├────────┤  └────────┘  ├────────┤  └─────────┘  └─────────┘
│维护    │              │调用    │
│change- │              │新增的  │
│History │              │3个接口 │
└────────┘              └────────┘
```

---

## 十、评审问题解决总结

| 问题编号 | 问题描述 | 集成设计补充 |
|---------|---------|-------------|
| 问题1 | 分层分析算法缺失 | 新增getRootCauseAnalysisFramework()接口 |
| 问题4 | changeHistory职责归属 | 明确由状态管理模块维护,核心流程模型不涉及 |
| 问题5 | 算法实现缺失 | 新增determineImpactedPhases()和calculateEffort()接口 |

---

### 9.6 新增Testing子阶段验证接口（状态管理模块评审后补充）

> 根据状态管理模块架构评审反馈（问题4：Testing子阶段验证归属），明确Testing子阶段状态流转规则由核心流程模型定义。

#### validateTestSubPhaseTransition - 验证Testing子阶段状态流转

```typescript
/**
 * 验证Testing子阶段状态流转
 * @param subPhase - 子阶段名称
 * @param currentStatus - 当前状态
 * @param targetStatus - 目标状态
 * @returns 验证结果
 */
function validateTestSubPhaseTransition(
  subPhase: 'e2e' | 'performance' | 'chaos',
  currentStatus: TestSubPhaseStatus,
  targetStatus: TestSubPhaseStatus
): ValidationResult;
```

**调用方**: 状态管理模块
**用途**: 验证Testing子阶段的状态流转是否合法
**复杂度**: simple (O(1)映射查找)

**Testing子阶段状态机定义**:

```typescript
/**
 * Testing子阶段状态机
 *
 * 状态流转图:
 * pending → plan_in_progress → plan_approved → executing → passed
 *                                                    ↓
 *                                                 failed
 *                                                    ↓
 *                                                executing (可重新执行)
 */
const TEST_SUB_PHASE_TRANSITIONS: Record<TestSubPhaseStatus, TestSubPhaseStatus[]> = {
  'pending': ['plan_in_progress'],
  'plan_in_progress': ['plan_approved'],
  'plan_approved': ['executing'],
  'executing': ['passed', 'failed'],
  'passed': [],  // 终态
  'failed': ['executing']  // 可重新执行
};
```

**实现逻辑**:

```typescript
function validateTestSubPhaseTransition(
  subPhase: 'e2e' | 'performance' | 'chaos',
  currentStatus: TestSubPhaseStatus,
  targetStatus: TestSubPhaseStatus
): ValidationResult {
  // 1. 获取允许的目标状态列表
  const allowedTargets = TEST_SUB_PHASE_TRANSITIONS[currentStatus];

  // 2. 检查目标状态是否在允许列表中
  if (!allowedTargets.includes(targetStatus)) {
    return {
      isValid: false,
      errors: [
        `Invalid ${subPhase} status transition: ${currentStatus} → ${targetStatus}. ` +
        `Allowed transitions: ${currentStatus} → ${allowedTargets.join(' | ') || '(none, terminal state)'}`
      ],
      warnings: []
    };
  }

  // 3. 验证子阶段顺序约束（e2e → performance → chaos）
  if (targetStatus === 'plan_in_progress' && subPhase !== 'e2e') {
    const prerequisitePhases = {
      'performance': 'e2e',
      'chaos': 'performance'
    };
    // 注意：这个约束检查需要状态管理模块传入更多上下文
    // 当前设计中，约束检查放在状态管理模块进行
  }

  return {
    isValid: true,
    errors: [],
    warnings: []
  };
}
```

**使用示例**:

```typescript
// 状态管理模块中的调用
class StateService {
  async updateTestSubPhaseStatus(
    subPhase: 'e2e' | 'performance' | 'chaos',
    newStatus: TestSubPhaseStatus
  ): Promise<UpdateResult> {
    const state = await this.getState();
    const testingPhase = state.iterations[state.currentIteration].phases.testing as TestingPhaseState;
    const currentStatus = testingPhase.testPhases[subPhase].status;

    // 调用核心流程模型验证
    const validation = this.coreProcess.validateTestSubPhaseTransition(
      subPhase,
      currentStatus,
      newStatus
    );

    if (!validation.isValid) {
      return { success: false, errors: validation.errors };
    }

    // 继续更新状态...
  }
}
```

---

#### 更新验证器接口汇总

```typescript
export interface CoreProcessValidators {
  /** 验证阶段流转 */
  validatePhaseTransition(
    currentPhase: string,
    targetPhase: string
  ): ValidationResult;

  /** 验证模块状态流转 */
  validateModuleTransition(
    currentStatus: ModuleStatus,
    targetStatus: ModuleStatus
  ): ValidationResult;

  /** 验证状态完整性 */
  validateStateIntegrity(state: State): ValidationResult;

  /** 验证依赖关系 */
  validateDependencies(dependencies: ModuleDependencies): ValidationResult;

  /** 验证Testing子阶段状态流转 (新增) */
  validateTestSubPhaseTransition(
    subPhase: 'e2e' | 'performance' | 'chaos',
    currentStatus: TestSubPhaseStatus,
    targetStatus: TestSubPhaseStatus
  ): ValidationResult;
}
```

---

**下一步**: 更新state.json记录补充设计进度
