# 状态管理模块 - 数据模型设计

<!--
章节ID规范说明：
- 格式：{#arch-data-状态管理-[章节标识]}
- 必须标注ID的章节：Schema定义、字段说明、数据约束
- 示例：{#arch-data-状态管理-State} 表示状态管理模块数据模型的State定义
-->

> **项目**: AI超级个体开发助手
> **版本**: v1.0.0
> **迭代**: Iteration 1
> **模块**: 状态管理模块
> **日期**: 2025-12-14

---

## 一、数据模型概述

### 1.1 设计理念

状态管理模块的数据模型遵循以下设计理念：

**理念1：单一数据源(Single Source of Truth)**
- state.json是项目状态的唯一权威来源
- 所有模块从state.json读取状态，不缓存副本
- 避免状态分散导致的不一致

**理念2：分层存储(Tiered Storage)**
- state.json: 当前迭代的活跃数据（< 100KB）
- state_his.json: 历史迭代的归档数据（可增长）
- 通过迁移机制保持state.json轻量

**理念3：完整性约束(Integrity Constraints)**
- 所有状态变更都经过核心流程模型验证
- 7类完整性约束保证数据一致性
- 变更历史可追溯

### 1.2 核心数据结构

| 数据结构 | 职责 | 存储位置 |
|---------|------|---------|
| `State` | 完整项目状态 | state.json |
| `HistoricalState` | 历史迭代归档 | state_his.json |
| `Change` | 变更记录 | state.json.changeHistory |
| `ProgressSummary` | 进度摘要（计算值） | 内存 |

---

## 二、核心类型定义

### 2.1 State - 完整项目状态 {#arch-data-状态管理-State}

```typescript
/**
 * State - 完整项目状态
 * 存储位置: .solodev/state.json
 */
interface State {
  /** Schema版本 */
  schema_version: string;  // "1.0.0"

  /** 项目基本信息 */
  project: ProjectInfo;

  /** 自举信息(仅当前项目需要) */
  bootstrap?: BootstrapInfo;

  /** 当前迭代ID */
  currentIteration: string;  // "iteration-1"

  /** 所有迭代(仅当前活跃迭代) */
  iterations: Record<string, Iteration>;

  /** 模块依赖关系(所有迭代共享) */
  moduleDependencies: ModuleDependencies;

  /** 全局任务 */
  globalTasks: GlobalTasks;

  /** 变更历史(仅当前迭代) */
  changeHistory: Change[];

  /** 设置 */
  settings: Settings;

  /** 元数据 */
  metadata: Metadata;

  /** 模板版本 */
  templateVersions: TemplateVersions;
}
```

### 2.2 ProjectInfo - 项目基本信息

```typescript
/**
 * 项目基本信息
 */
interface ProjectInfo {
  /** 项目名称 */
  name: string;

  /** 项目描述 */
  description: string;

  /** 项目类型 */
  type: 'backend' | 'frontend' | 'fullstack' | 'library' | 'tool';

  /** 创建时间 */
  createdAt: string;  // ISO8601

  /** 更新时间 */
  updatedAt?: string;  // ISO8601
}
```

### 2.3 Iteration - 迭代

```typescript
/**
 * 迭代 - 继承自核心流程模型的Iteration定义
 */
interface Iteration {
  /** 迭代ID */
  id: string;

  /** 版本号 */
  version: string;

  /** 迭代目标 */
  goal?: string;

  /** 状态 */
  status: IterationStatus;

  /** 开始时间 */
  startedAt: string;

  /** 完成时间 */
  completedAt?: string;

  /** 部署时间 */
  deployedAt?: string;

  /** 当前阶段 */
  currentPhase: string;

  /** 各阶段状态 */
  phases: {
    requirements: PhaseState;
    architecture: PhaseState;
    implementation: PhaseState;
    testing: TestingPhaseState;  // 特殊类型，包含子阶段
    deployment: PhaseState;
  };

  /** Git信息 */
  git?: {
    startCommit: string;
    endCommit?: string;
    tag?: string;
  };
}
```

### 2.4 PhaseState - 阶段状态

```typescript
/**
 * 阶段状态 - 继承自核心流程模型
 */
interface PhaseState {
  /** 状态 */
  status: PhaseStatus;

  /** 开始时间 */
  startedAt?: string;

  /** 审批时间 */
  approvedAt?: string;

  /** 审批人 */
  approvedBy?: string;

  /** 完成时间 */
  completedAt?: string;

  /** 模块状态 */
  modules: Record<string, ModuleState>;

  /** 当前处理进度 */
  currentProcess?: CurrentProcess;
}

/**
 * 当前处理进度
 */
interface CurrentProcess {
  /** 当前模块 */
  currentModule: string | null;

  /** 已完成模块 */
  completedModules: string[];

  /** 剩余模块 */
  remainingModules: string[];

  /** 下一步建议 */
  nextAction: string;
}
```

### 2.5 TestingPhaseState - Testing阶段特殊状态

```typescript
/**
 * Testing阶段状态 - 继承自核心流程模型11.1节
 */
interface TestingPhaseState extends PhaseState {
  /** Testing子阶段状态 */
  testPhases: {
    e2e: TestSubPhaseState;
    performance: TestSubPhaseState;
    chaos: TestSubPhaseState;
  };
}

/**
 * Testing子阶段状态
 */
interface TestSubPhaseState {
  /** 状态 */
  status: TestSubPhaseStatus;

  /** 计划审批时间 */
  planApprovedAt?: string;

  /** 计划审批人 */
  planApprovedBy?: string;

  /** 执行时间 */
  executedAt?: string;

  /** 通过时间 */
  passedAt?: string;

  /** 失败时间 */
  failedAt?: string;

  /** 失败原因 */
  failureReason?: string;

  /** 产物 */
  artifacts: TestSubPhaseArtifacts;
}

/**
 * Testing子阶段状态枚举
 */
type TestSubPhaseStatus =
  | 'pending'
  | 'plan_in_progress'
  | 'plan_approved'
  | 'executing'
  | 'passed'
  | 'failed';

/**
 * Testing子阶段产物
 */
interface TestSubPhaseArtifacts {
  /** 测试计划 */
  plan: string;

  /** 测试代码 */
  code?: string;

  /** 测试报告 */
  report?: string;
}
```

### 2.6 ModuleState - 模块状态

```typescript
/**
 * 模块状态 - 继承自核心流程模型，扩展回滚字段
 */
interface ModuleState {
  /** 状态 */
  status: ModuleStatus;

  /** 优先级 */
  priority: 'P0' | 'P1' | 'P2';

  /** 开始时间 */
  startedAt?: string;

  /** 审批时间 */
  approvedAt?: string;

  /** 审批人 */
  approvedBy?: string;

  /** 完成时间 */
  completedAt?: string;

  /** 产物 */
  artifacts: string[];

  /** 审核人 */
  reviewer?: string;

  /** 待解决问题(仅requirements) */
  pendingQuestions?: string[];

  /** 已澄清方面(仅requirements) */
  clarifiedAspects?: string[];

  // ===== 回滚相关字段(核心流程模型11.2节) =====

  /** 之前的审批时间(回滚后保留) */
  previousApprovedAt?: string;

  /** 回滚历史 */
  rollbackHistory?: RollbackHistoryEntry[];
}

/**
 * 模块状态枚举 - 扩展自核心流程模型
 */
type ModuleStatus =
  | 'pending'
  | 'in_progress'
  | 'partially_clarified'
  | 'approved'
  | 'completed'
  | 'rolled_back';  // 新增

/**
 * 回滚历史条目
 */
interface RollbackHistoryEntry {
  /** 回滚时间 */
  rolledBackAt: string;

  /** 回滚原因 */
  reason: string;

  /** 从哪个阶段回滚 */
  fromPhase: string;

  /** 回滚到哪个阶段 */
  toPhase: string;
}
```

### 2.7 ModuleDependencies - 模块依赖关系

```typescript
/**
 * 模块依赖关系 - 继承自核心流程模型
 */
type ModuleDependencies = Record<string, ModuleDependency>;

interface ModuleDependency {
  /** 依赖的模块 */
  dependsOn: string[];

  /** 被依赖的模块 */
  dependedBy: string[];

  /** 是否基础模块 */
  isFoundation?: boolean;

  /** 模块描述 */
  description?: string;

  /** 集成点 */
  integrationPoints?: IntegrationPoint[];
}

interface IntegrationPoint {
  /** 目标模块 */
  targetModule: string;

  /** 接口 */
  interface: string;

  /** 目的 */
  purpose: string;

  /** 数据流 */
  dataFlow: string;

  /** 错误处理 */
  errorHandling: string;

  /** 复杂度 */
  complexity: 'simple' | 'complex';
}
```

### 2.8 GlobalTasks - 全局任务

```typescript
/**
 * 全局任务
 */
interface GlobalTasks {
  /** 待处理任务 */
  pending: Task[];

  /** 进行中任务 */
  in_progress?: Task[];

  /** 已完成任务(仅当前迭代) */
  completed: Task[];
}

/**
 * 任务
 */
interface Task {
  /** 任务ID */
  id: string;

  /** 标题 */
  title: string;

  /** 描述 */
  description?: string;

  /** 优先级 */
  priority: 'P0' | 'P1' | 'P2';

  /** 所属迭代 */
  iteration?: string;

  /** 所属阶段 */
  phase?: string;

  /** 所属模块 */
  module?: string;

  /** 创建时间 */
  createdAt: string;

  /** 完成时间 */
  completedAt?: string;

  /** 解决方案 */
  resolution?: string;
}
```

### 2.9 Change - 变更记录

```typescript
/**
 * 变更记录
 */
interface Change {
  /** 时间戳 */
  timestamp: string;

  /** 变更类型 */
  type: ChangeType;

  /** 描述 */
  description: string;

  /** 变更人 */
  changedBy: 'ai' | 'human';

  /** 详细变更 */
  changes: ChangeDetail[];

  /** 决策(可选) */
  decision?: string;

  /** 附加说明 */
  notes?: string;

  /** 评审反馈(可选) */
  reviewFeedback?: string[];

  /** 产物(可选) */
  artifacts?: string[];
}

/**
 * 变更类型 - 扩展自核心流程模型
 */
type ChangeType =
  | 'init'
  | 'bootstrap'
  | 'phase_transition'
  | 'module_status_change'
  | 'module_completed'
  | 'approval'
  | 'rollback'
  | 'task_completed'
  | 'iteration_completed'
  | 'architecture_supplement'  // 架构补充
  | 'hotfix';

/**
 * 变更详情
 */
interface ChangeDetail {
  /** 字段路径 */
  field: string;

  /** 原值 */
  from: any;

  /** 新值 */
  to: any;
}
```

### 2.10 Settings - 设置

```typescript
/**
 * 设置
 */
interface Settings {
  /** 自动读取历史数据 */
  autoReadHistory: boolean;

  /** 阶段流转需要审批 */
  requireApprovalForPhaseTransition: boolean;

  /** 其他设置(可扩展) */
  [key: string]: any;
}
```

### 2.11 Metadata - 元数据

```typescript
/**
 * 元数据
 */
interface Metadata {
  /** 最后Git提交 */
  lastGitCommit: string;

  /** 最后Git提交信息 */
  lastGitCommitMessage: string;

  /** 最后Git提交时间 */
  lastGitCommitAt: string;

  /** state文件版本 */
  stateFileVersion: number;

  /** 总状态变更次数 */
  totalStateChanges: number;

  /** 最后更新时间 */
  lastUpdatedAt: string;

  /** 最后更新人 */
  lastUpdatedBy: 'ai' | 'human';
}
```

---

## 三、历史数据模型

### 3.1 HistoricalState - 历史状态

```typescript
/**
 * 历史状态
 * 存储位置: .solodev/state_his.json
 */
interface HistoricalState {
  /** Schema版本 */
  schema_version: string;

  /** 已完成的迭代 */
  completedIterations: Record<string, HistoricalIteration>;
}
```

### 3.2 HistoricalIteration - 历史迭代

```typescript
/**
 * 历史迭代 - 完整的已归档迭代
 */
interface HistoricalIteration {
  /** 迭代ID */
  id: string;

  /** 版本号 */
  version: string;

  /** 迭代目标 */
  goal: string;

  /** 状态 */
  status: 'completed';

  /** 开始时间 */
  startedAt: string;

  /** 完成时间 */
  completedAt: string;

  /** 部署时间 */
  deployedAt: string;

  /** Git Tag */
  gitTag: string;

  /** 各阶段状态 */
  phases: {
    requirements: PhaseState;
    architecture: PhaseState;
    implementation: PhaseState;
    testing: TestingPhaseState;
    deployment: PhaseState;
  };

  /** 所有任务 */
  tasks: Task[];

  /** 所有变更 */
  changeHistory: Change[];

  /** 迭代总结 */
  summary: string;

  /** 迭代统计 */
  stats?: IterationStats;
}

/**
 * 迭代统计
 */
interface IterationStats {
  /** 总模块数 */
  totalModules: number;

  /** 总任务数 */
  totalTasks: number;

  /** 回滚次数 */
  rollbackCount: number;

  /** 总耗时(天) */
  durationDays: number;
}
```

---

## 四、数据操作模型

### 4.1 UpdateResult - 更新结果

```typescript
/**
 * 更新结果
 */
interface UpdateResult {
  /** 是否成功 */
  success: boolean;

  /** 错误信息 */
  errors?: string[];

  /** 警告信息 */
  warnings?: string[];
}
```

### 4.2 TransitionResult - 流转结果

```typescript
/**
 * 阶段流转结果
 */
interface TransitionResult extends UpdateResult {
  /** 新阶段 */
  newPhase?: string;
}
```

### 4.3 ApproveResult - 审批结果

```typescript
/**
 * 审批结果
 */
interface ApproveResult extends UpdateResult {
  /** 审批时间 */
  approvedAt?: string;
}
```

### 4.4 RollbackResult - 回滚结果

```typescript
/**
 * 回滚结果
 */
interface RollbackResult extends UpdateResult {
  /** 回滚的模块 */
  rolledBackModule?: string;

  /** 目标阶段 */
  targetPhase?: string;

  /** 受影响的模块 */
  affectedModules?: string[];
}
```

### 4.5 MigrationResult - 迁移结果

```typescript
/**
 * 迁移结果
 */
interface MigrationResult extends UpdateResult {
  /** 迁移的迭代ID */
  migratedIterationId?: string;

  /** 新的当前迭代ID */
  newCurrentIterationId?: string;
}
```

### 4.6 HistoryNeedAnalysis - 历史需求分析

```typescript
/**
 * 历史需求分析结果
 */
interface HistoryNeedAnalysis {
  /** 是否需要历史数据 */
  needHistory: boolean;

  /** 原因 */
  reason: string;

  /** 是否需要用户确认 */
  requireConfirmation: boolean;

  /** 建议读取的迭代 */
  suggestedIterations?: string[];
}
```

### 4.7 ProgressSummary - 进度摘要

```typescript
/**
 * 进度摘要 - 用于会话恢复
 */
interface ProgressSummary {
  /** 当前迭代 */
  currentIteration: string;

  /** 当前阶段 */
  currentPhase: string;

  /** 当前模块(如果有) */
  currentModule: string | null;

  /** 已完成模块数 */
  completedModules: number;

  /** 剩余模块数 */
  remainingModules: number;

  /** 上次操作描述 */
  lastAction: string;

  /** 上次操作时间 */
  lastActionTime: string;

  /** 建议下一步 */
  suggestedNextStep: string;
}
```

### 4.8 FileSizeCheck - 文件大小检查

```typescript
/**
 * 文件大小检查结果
 */
interface FileSizeCheck {
  /** 当前大小(KB) */
  sizeKB: number;

  /** 是否超过限制 */
  isOverLimit: boolean;

  /** 是否接近限制 */
  isWarning: boolean;

  /** 建议 */
  recommendation: string | null;
}
```

---

## 五、状态操作规范

### 5.1 状态读取规范

```typescript
/**
 * 状态读取流程
 */
async function readStateFlow(): Promise<State> {
  // 1. 检查缓存
  if (cache.isValid()) {
    return cache.get();
  }

  // 2. 读取文件
  const content = await fs.readFile('.solodev/state.json', 'utf-8');

  // 3. 解析JSON
  let state: State;
  try {
    state = JSON.parse(content);
  } catch (error) {
    throw new StateFileCorruptedError('Invalid JSON');
  }

  // 4. Schema版本检查
  if (state.schema_version !== CURRENT_SCHEMA_VERSION) {
    state = await migrateSchema(state);
  }

  // 5. 更新缓存
  cache.set(state);

  return state;
}
```

### 5.2 状态写入规范

```typescript
/**
 * 状态写入流程
 */
async function writeStateFlow(
  state: State,
  changeDescription: string,
  changes: ChangeDetail[]
): Promise<void> {
  // 1. 记录变更历史
  state.changeHistory.push({
    timestamp: new Date().toISOString(),
    type: inferChangeType(changes),
    description: changeDescription,
    changedBy: 'ai',
    changes
  });

  // 2. 更新metadata
  state.metadata.stateFileVersion++;
  state.metadata.totalStateChanges++;
  state.metadata.lastUpdatedAt = new Date().toISOString();
  state.metadata.lastUpdatedBy = 'ai';

  // 3. 验证状态完整性
  const validation = coreProcess.validateStateIntegrity(state);
  if (!validation.isValid) {
    throw new StateValidationError(validation.errors);
  }

  // 4. 序列化
  const content = JSON.stringify(state, null, 2);

  // 5. 写入文件
  await fs.writeFile('.solodev/state.json', content, 'utf-8');

  // 6. 更新缓存
  cache.set(state);

  // 7. 检查文件大小
  const sizeCheck = await checkFileSize();
  if (sizeCheck.isWarning) {
    console.warn(sizeCheck.recommendation);
  }
}
```

### 5.3 迁移操作规范

```typescript
/**
 * 迭代迁移流程
 */
async function migrateIterationFlow(iterationId: string): Promise<void> {
  // 1. 验证迁移条件
  const state = await readState();
  const iteration = state.iterations[iterationId];

  if (iteration.status !== 'completed' || !iteration.deployedAt) {
    throw new MigrationConditionError('Iteration not ready for migration');
  }

  // 2. 读取历史文件
  let history: HistoricalState;
  try {
    history = await readHistoryFile();
  } catch {
    history = { schema_version: '1.0.0', completedIterations: {} };
  }

  // 3. 构建历史迭代对象
  const historicalIteration: HistoricalIteration = {
    ...iteration,
    status: 'completed',
    tasks: state.globalTasks.completed.filter(t => t.iteration === iterationId),
    changeHistory: state.changeHistory.filter(c => belongsToIteration(c, iterationId)),
    summary: generateSummary(iteration),
    stats: calculateStats(iteration)
  };

  // 4. 写入历史文件
  history.completedIterations[iterationId] = historicalIteration;
  await writeHistoryFile(history);

  // 5. 清理当前状态
  delete state.iterations[iterationId];
  state.globalTasks.completed = state.globalTasks.completed.filter(
    t => t.iteration !== iterationId
  );
  state.changeHistory = state.changeHistory.filter(
    c => !belongsToIteration(c, iterationId)
  );

  // 6. 设置新的当前迭代
  state.currentIteration = `iteration-${parseInt(iterationId.split('-')[1]) + 1}`;
  state.iterations[state.currentIteration] = createNewIteration(state.currentIteration);

  // 7. 写入当前状态
  await writeState(state);
}
```

---

## 六、错误类型定义

### 6.1 状态管理模块错误

```typescript
/**
 * 状态文件未找到错误
 */
class StateFileNotFoundError extends Error {
  readonly code = 'STATE_FILE_NOT_FOUND';

  constructor(message: string = 'state.json not found') {
    super(message);
    this.name = 'StateFileNotFoundError';
  }
}

/**
 * 状态文件损坏错误
 */
class StateFileCorruptedError extends Error {
  readonly code = 'STATE_FILE_CORRUPTED';

  constructor(message: string = 'state.json is corrupted') {
    super(message);
    this.name = 'StateFileCorruptedError';
  }

  /** 修复建议 */
  getRecoverySuggestions(): string[] {
    return [
      '手动检查JSON格式: https://jsonlint.com/',
      '从Git历史恢复: git checkout HEAD~1 .solodev/state.json',
      '检查常见错误: 缺少逗号、多余逗号、引号不匹配'
    ];
  }
}

/**
 * 状态验证错误
 */
class StateValidationError extends Error {
  readonly code = 'STATE_VALIDATION_ERROR';
  readonly errors: string[];

  constructor(errors: string[]) {
    super(`State validation failed: ${errors.join(', ')}`);
    this.name = 'StateValidationError';
    this.errors = errors;
  }
}

/**
 * 迁移条件错误
 */
class MigrationConditionError extends Error {
  readonly code = 'MIGRATION_CONDITION_ERROR';

  constructor(message: string) {
    super(message);
    this.name = 'MigrationConditionError';
  }
}

/**
 * 历史数据未找到错误
 */
class HistoryNotFoundError extends Error {
  readonly code = 'HISTORY_NOT_FOUND';

  constructor(iterationId: string) {
    super(`Historical iteration "${iterationId}" not found`);
    this.name = 'HistoryNotFoundError';
  }
}
```

---

## 七、数据完整性约束

状态管理模块执行的验证（调用核心流程模型）：

### 7.1 写入前验证

| 约束 | 验证内容 | 调用接口 |
|------|---------|---------|
| 约束1 | currentIteration存在性 | validateStateIntegrity() |
| 约束2 | currentPhase存在性 | validateStateIntegrity() |
| 约束3 | 模块名称一致性 | validateStateIntegrity() |
| 约束4 | 已完成阶段模块状态 | validateStateIntegrity() |
| 约束5 | 阶段顺序一致性 | validateStateIntegrity() |
| 约束6 | 依赖关系DAG | validateDependencies() |
| 约束7 | 依赖关系双向一致 | validateDependencies() |

### 7.2 状态流转验证

| 操作 | 验证内容 | 调用接口 |
|------|---------|---------|
| 阶段流转 | 流转是否合法 | validatePhaseTransition() |
| 模块状态更新 | 状态流转是否合法 | validateModuleTransition() |

---

## 八、缓存模型

### 8.1 缓存结构

```typescript
/**
 * 状态缓存
 */
interface StateCache {
  /** 缓存的状态 */
  state: State | null;

  /** 缓存时间戳 */
  timestamp: number;

  /** 缓存有效期(ms) */
  ttl: number;

  /** 是否有效 */
  isValid(): boolean;

  /** 获取缓存 */
  get(): State;

  /** 设置缓存 */
  set(state: State): void;

  /** 使缓存失效 */
  invalidate(): void;
}
```

### 8.2 缓存实现

```typescript
class StateCacheImpl implements StateCache {
  state: State | null = null;
  timestamp: number = 0;
  ttl: number = 5000;  // 5秒

  isValid(): boolean {
    return this.state !== null && Date.now() - this.timestamp < this.ttl;
  }

  get(): State {
    if (!this.state) {
      throw new Error('Cache is empty');
    }
    return this.state;
  }

  set(state: State): void {
    this.state = state;
    this.timestamp = Date.now();
  }

  invalidate(): void {
    this.state = null;
    this.timestamp = 0;
  }
}
```

---

## 九、数据迁移

### 9.1 Schema版本迁移

```typescript
/**
 * Schema迁移函数类型
 */
type SchemaMigration = (state: any) => any;

/**
 * Schema迁移注册表
 */
const schemaMigrations: Record<string, SchemaMigration> = {
  '1.0.0_to_1.1.0': (state) => {
    // 示例: 添加新字段
    state.iterations[state.currentIteration].phases.testing.testPhases = {
      e2e: { status: 'pending', artifacts: { plan: '' } },
      performance: { status: 'pending', artifacts: { plan: '' } },
      chaos: { status: 'pending', artifacts: { plan: '' } }
    };
    state.schema_version = '1.1.0';
    return state;
  }
};

/**
 * 执行Schema迁移
 */
function migrateSchema(state: any): State {
  const currentVersion = state.schema_version;
  const targetVersion = CURRENT_SCHEMA_VERSION;

  if (currentVersion === targetVersion) {
    return state as State;
  }

  const migrationKey = `${currentVersion}_to_${targetVersion}`;
  const migration = schemaMigrations[migrationKey];

  if (!migration) {
    throw new Error(`No migration path from ${currentVersion} to ${targetVersion}`);
  }

  return migration(state) as State;
}
```

---

## 十、总结

### 10.1 数据模型层次

```
┌─────────────────────────────────────────────────────┐
│                   State (顶层)                       │
│  ───────────────────────────────────────────────── │
│  · project: 项目信息                                │
│  · currentIteration: 当前迭代ID                     │
│  · iterations: 迭代列表                             │
│  · moduleDependencies: 模块依赖                     │
│  · globalTasks: 全局任务                            │
│  · changeHistory: 变更历史                          │
│  · settings: 设置                                   │
│  · metadata: 元数据                                 │
└───────────────────────┬─────────────────────────────┘
                        │
    ┌───────────────────┼───────────────────┐
    ↓                   ↓                   ↓
┌─────────────┐   ┌─────────────┐   ┌─────────────┐
│ Iteration   │   │ Module      │   │ Change      │
│ 迭代        │   │ Dependencies│   │ History     │
│ · phases    │   │ · dependsOn │   │ · changes   │
│ · status    │   │ · dependedBy│   │ · type      │
└──────┬──────┘   └─────────────┘   └─────────────┘
       │
       ↓
┌─────────────┐
│ PhaseState  │
│ · modules   │
│ · status    │
└──────┬──────┘
       │
       ↓
┌─────────────┐
│ ModuleState │
│ · artifacts │
│ · status    │
└─────────────┘
```

### 10.2 核心设计要点

1. **单一数据源**: state.json是唯一权威
2. **分层存储**: 活跃数据与历史数据分离
3. **完整性约束**: 所有变更都经过验证
4. **变更追溯**: changeHistory记录所有变更
5. **可扩展**: Schema版本管理支持演进

---

## 十一、补充设计（评审反馈）

> 本节内容针对架构评审反馈的6个问题进行补充设计。

### 11.1 历史关键词识别逻辑（问题1）

**PRD需求**：自动读取历史数据的触发条件应基于关键词识别。

**设计决策**：**混合策略 - AI层面判断 + 代码辅助**

**理由**：
1. 关键词识别涉及自然语言理解，AI层面（CLAUDE.md规范）更适合
2. 代码层面提供辅助匹配，提高准确性
3. 最终决策由AI结合上下文判断

**实现设计**：

```typescript
/**
 * 历史关键词匹配器
 * 提供辅助匹配能力，最终决策由AI层面完成
 */
interface HistoryKeywordMatcher {
  /**
   * 历史对比关键词
   * 匹配场景：用户明确提到历史对比
   */
  comparisonKeywords: string[];

  /**
   * 趋势分析关键词
   * 匹配场景：用户要求长期趋势分析
   */
  trendKeywords: string[];

  /**
   * 迭代引用模式
   * 匹配场景：用户明确引用某个历史迭代
   */
  iterationPattern: RegExp;

  /**
   * 执行匹配
   * @param query - 用户查询
   * @returns 匹配结果（辅助信息，非最终决策）
   */
  match(query: string): KeywordMatchResult;
}

/**
 * 关键词匹配结果
 */
interface KeywordMatchResult {
  /** 是否匹配到历史对比关键词 */
  hasComparisonKeyword: boolean;

  /** 是否匹配到趋势分析关键词 */
  hasTrendKeyword: boolean;

  /** 匹配到的迭代ID（如果有） */
  matchedIterationIds: string[];

  /** 匹配到的具体关键词 */
  matchedKeywords: string[];

  /** 置信度（0-1），供AI参考 */
  confidence: number;
}

/**
 * 默认实现
 */
class DefaultHistoryKeywordMatcher implements HistoryKeywordMatcher {
  comparisonKeywords = [
    '对比', '比较', '历史', '之前', '上次', '上个迭代',
    '变化', '差异', '改变了什么'
  ];

  trendKeywords = [
    '趋势', '统计', '频率', '过去', '多少次',
    '经常', '一直', '反复', '历次'
  ];

  iterationPattern = /iteration-(\d+)/gi;

  match(query: string): KeywordMatchResult {
    const lowerQuery = query.toLowerCase();

    // 匹配对比关键词
    const matchedComparison = this.comparisonKeywords.filter(
      kw => lowerQuery.includes(kw)
    );

    // 匹配趋势关键词
    const matchedTrend = this.trendKeywords.filter(
      kw => lowerQuery.includes(kw)
    );

    // 匹配迭代ID
    const iterationMatches = query.match(this.iterationPattern) || [];
    const matchedIterationIds = iterationMatches.map(
      m => m.toLowerCase()
    );

    // 计算置信度
    const totalMatches = matchedComparison.length + matchedTrend.length + matchedIterationIds.length;
    const confidence = Math.min(totalMatches * 0.3, 1.0);

    return {
      hasComparisonKeyword: matchedComparison.length > 0,
      hasTrendKeyword: matchedTrend.length > 0,
      matchedIterationIds,
      matchedKeywords: [...matchedComparison, ...matchedTrend],
      confidence
    };
  }
}
```

**HistoryService更新**：

```typescript
class HistoryService {
  private keywordMatcher: HistoryKeywordMatcher;

  /**
   * 分析是否需要历史数据
   * 综合关键词匹配和AI层面判断
   */
  async analyzeNeed(query: string): Promise<HistoryNeedAnalysis> {
    // 1. 代码层面：关键词匹配
    const matchResult = this.keywordMatcher.match(query);

    // 2. 检查配置
    const state = await this.repository.read();
    const autoReadHistory = state.settings.autoReadHistory;

    // 3. 构建分析结果
    //    注意：这是辅助信息，最终决策由AI层面完成
    return {
      needHistory: matchResult.confidence > 0.3,
      reason: this.buildReason(matchResult),
      requireConfirmation: !autoReadHistory && matchResult.confidence < 0.7,
      suggestedIterations: matchResult.matchedIterationIds,
      // 新增：提供匹配详情供AI参考
      matchDetails: matchResult
    };
  }

  private buildReason(match: KeywordMatchResult): string {
    if (match.matchedIterationIds.length > 0) {
      return `用户明确引用了历史迭代: ${match.matchedIterationIds.join(', ')}`;
    }
    if (match.hasComparisonKeyword) {
      return `检测到历史对比关键词: ${match.matchedKeywords.join(', ')}`;
    }
    if (match.hasTrendKeyword) {
      return `检测到趋势分析关键词: ${match.matchedKeywords.join(', ')}`;
    }
    return '未检测到明确的历史数据需求';
  }
}
```

**扩展HistoryNeedAnalysis类型**：

```typescript
interface HistoryNeedAnalysis {
  needHistory: boolean;
  reason: string;
  requireConfirmation: boolean;
  suggestedIterations?: string[];
  /** 新增：匹配详情，供AI层面参考 */
  matchDetails?: KeywordMatchResult;
}
```

**AI层面（CLAUDE.md）的职责**：
- 结合上下文判断是否真正需要历史数据
- 处理代码无法识别的隐含需求（如"和以前比起来如何？"）
- 在matchDetails.confidence较低时主动询问用户

---

### 11.2 会话恢复触发机制澄清（问题2）

**PRD需求**：每次会话开始时，AI自动读取state.json，主动提示上次进度，建议下一步行动。

**设计澄清**：**这是"接口能力"，不是"自动触发能力"**

**职责划分**：

| 层面 | 职责 | 说明 |
|------|------|------|
| **状态管理模块** | 提供接口能力 | `getProgressSummary()` 和 `suggestNextAction()` |
| **AI层面(CLAUDE.md)** | 自动触发 | 会话开始时主动调用这些接口 |

**代码层面**（已实现）：

```typescript
interface StateUtils {
  /**
   * 获取上次进度摘要
   * 【接口能力】提供数据，不负责"主动"
   */
  getProgressSummary(): Promise<ProgressSummary>;

  /**
   * 建议下一步操作
   * 【接口能力】提供建议，不负责"主动"
   */
  suggestNextAction(): Promise<ActionSuggestion>;
}
```

**AI层面（CLAUDE.md 第六节 核心工作流程）**：

```markdown
### 会话开始流程

1. 读取 .solodev/state.json
2. 分析当前阶段（currentPhase）和当前进度
3. 调用 getProgressSummary() 获取进度摘要
4. 调用 suggestNextAction() 获取建议
5. **主动提示用户**上次进度和建议的下一步行动
```

**为何不在代码层面实现自动触发**：
1. 代码层面无法感知"会话开始"这个事件
2. "主动提示"是AI行为，属于CLAUDE.md规范范畴
3. 代码层面只负责提供数据能力

**结论**：当前设计正确，`getProgressSummary()` 和 `suggestNextAction()` 是接口能力，由AI层面在会话开始时主动调用并向用户展示。

---

### 11.3 批量更新接口（问题3）

**问题**：集成设计7.2节推荐批量操作，但StateWriter接口中没有定义batchUpdate()方法。

**设计补充**：在StateWriter接口中添加batchUpdate()方法。

```typescript
/**
 * 批量更新操作类型
 */
type BatchOperation =
  | { type: 'moduleStatus'; phaseName: string; moduleName: string; status: ModuleStatus; artifacts?: string[] }
  | { type: 'phaseTransition'; targetPhase: string }
  | { type: 'approvePhase'; phaseName: string; approvedBy: string }
  | { type: 'approveModule'; phaseName: string; moduleName: string; approvedBy: string; artifacts: string[] }
  | { type: 'testSubPhaseStatus'; subPhase: 'e2e' | 'performance' | 'chaos'; status: TestSubPhaseStatus; artifacts?: TestSubPhaseArtifacts };

/**
 * 批量更新结果
 */
interface BatchUpdateResult extends UpdateResult {
  /** 每个操作的结果 */
  operationResults: UpdateResult[];

  /** 成功操作数 */
  successCount: number;

  /** 失败操作数 */
  failureCount: number;
}

/**
 * StateWriter接口扩展
 */
export interface StateWriter {
  // ... 其他接口保持不变 ...

  /**
   * 批量更新
   * 多个操作合并为一次写入，提高性能
   *
   * 执行策略：
   * 1. 所有操作在内存中依次执行
   * 2. 每个操作都进行验证
   * 3. 任一操作失败，整个批量操作回滚
   * 4. 所有操作成功后，一次性写入文件
   *
   * @param operations - 操作列表
   * @returns 批量更新结果
   */
  batchUpdate(operations: BatchOperation[]): Promise<BatchUpdateResult>;
}
```

**实现设计**：

```typescript
class StateService {
  async batchUpdate(operations: BatchOperation[]): Promise<BatchUpdateResult> {
    const state = await this.getState();
    const originalState = JSON.parse(JSON.stringify(state)); // 深拷贝用于回滚
    const operationResults: UpdateResult[] = [];

    try {
      // 1. 在内存中依次执行所有操作
      for (const op of operations) {
        const result = await this.executeSingleOperation(state, op);
        operationResults.push(result);

        if (!result.success) {
          // 任一操作失败，立即回滚
          throw new BatchOperationError(
            `Operation ${op.type} failed: ${result.errors?.join(', ')}`,
            operationResults
          );
        }
      }

      // 2. 所有操作成功，验证最终状态
      const integrity = this.coreProcess.validateStateIntegrity(state);
      if (!integrity.isValid) {
        throw new BatchOperationError(
          `Final state validation failed: ${integrity.errors.join(', ')}`,
          operationResults
        );
      }

      // 3. 一次性写入
      await this.repository.write(state);

      return {
        success: true,
        operationResults,
        successCount: operations.length,
        failureCount: 0
      };

    } catch (error) {
      // 回滚：恢复原始状态
      this.state = originalState;

      return {
        success: false,
        errors: [error.message],
        operationResults: error.operationResults || operationResults,
        successCount: operationResults.filter(r => r.success).length,
        failureCount: operationResults.filter(r => !r.success).length + 1
      };
    }
  }

  private async executeSingleOperation(
    state: State,
    op: BatchOperation
  ): Promise<UpdateResult> {
    switch (op.type) {
      case 'moduleStatus':
        return this.updateModuleStatusInMemory(state, op.phaseName, op.moduleName, op.status, op.artifacts);
      case 'phaseTransition':
        return this.transitionPhaseInMemory(state, op.targetPhase);
      case 'approvePhase':
        return this.approvePhaseInMemory(state, op.phaseName, op.approvedBy);
      // ... 其他操作类型
    }
  }
}
```

---

### 11.4 Testing子阶段验证归属（问题4）

**问题**：TestSubPhaseStatus状态流转规则由谁定义？updateTestSubPhaseStatus()是否需要调用核心流程模型验证？

**设计决策**：**由核心流程模型定义，状态管理模块调用验证**

**理由**：
1. Testing子阶段是阶段的一部分，状态流转规则应与其他阶段保持一致性
2. 核心流程模型作为"规则定义者"，应包含所有状态流转规则
3. 状态管理模块作为"规则执行者"，调用核心流程模型验证

**核心流程模型需要新增的接口**：

```typescript
/**
 * 核心流程模型 - Testing子阶段验证接口
 * 需要在核心流程模型-集成设计.md中补充
 */
interface CoreProcessTestingValidators {
  /**
   * 验证Testing子阶段状态流转
   * @param subPhase - 子阶段名称
   * @param currentStatus - 当前状态
   * @param targetStatus - 目标状态
   * @returns 验证结果
   */
  validateTestSubPhaseTransition(
    subPhase: 'e2e' | 'performance' | 'chaos',
    currentStatus: TestSubPhaseStatus,
    targetStatus: TestSubPhaseStatus
  ): ValidationResult;
}
```

**Testing子阶段状态流转规则**（定义在核心流程模型中）：

```typescript
/**
 * Testing子阶段状态机
 *
 * pending → plan_in_progress → plan_approved → executing → passed/failed
 *                                                    ↓
 *                                               (失败后可重新执行)
 *                                                    ↓
 *                                              executing → passed/failed
 */
const TEST_SUB_PHASE_TRANSITIONS: Record<TestSubPhaseStatus, TestSubPhaseStatus[]> = {
  'pending': ['plan_in_progress'],
  'plan_in_progress': ['plan_approved'],
  'plan_approved': ['executing'],
  'executing': ['passed', 'failed'],
  'passed': [],  // 终态
  'failed': ['executing']  // 可重新执行
};
```

**状态管理模块的调用方式**：

```typescript
class StateService {
  async updateTestSubPhaseStatus(
    subPhase: 'e2e' | 'performance' | 'chaos',
    newStatus: TestSubPhaseStatus,
    artifacts?: TestSubPhaseArtifacts
  ): Promise<UpdateResult> {
    const state = await this.getState();
    const iteration = state.iterations[state.currentIteration];
    const testingPhase = iteration.phases.testing as TestingPhaseState;
    const currentStatus = testingPhase.testPhases[subPhase].status;

    // 调用核心流程模型验证
    const validation = this.coreProcess.validateTestSubPhaseTransition(
      subPhase,
      currentStatus,
      newStatus
    );

    if (!validation.isValid) {
      return { success: false, errors: validation.errors };
    }

    // 更新状态
    testingPhase.testPhases[subPhase].status = newStatus;

    // 根据状态更新时间戳
    if (newStatus === 'plan_approved') {
      testingPhase.testPhases[subPhase].planApprovedAt = new Date().toISOString();
    } else if (newStatus === 'executing') {
      testingPhase.testPhases[subPhase].executedAt = new Date().toISOString();
    } else if (newStatus === 'passed') {
      testingPhase.testPhases[subPhase].passedAt = new Date().toISOString();
    } else if (newStatus === 'failed') {
      testingPhase.testPhases[subPhase].failedAt = new Date().toISOString();
    }

    // 更新产物
    if (artifacts) {
      testingPhase.testPhases[subPhase].artifacts = {
        ...testingPhase.testPhases[subPhase].artifacts,
        ...artifacts
      };
    }

    // 记录变更
    this.changeRecorder.record(state, {
      type: 'module_status_change',
      description: `Testing子阶段${subPhase}状态从${currentStatus}变更为${newStatus}`,
      changes: [
        { field: `phases.testing.testPhases.${subPhase}.status`, from: currentStatus, to: newStatus }
      ]
    });

    await this.repository.write(state);

    return { success: true };
  }
}
```

**需要同步更新核心流程模型**：
- 在核心流程模型-集成设计.md的接口列表中添加 `validateTestSubPhaseTransition()`
- 在核心流程模型-数据模型设计.md中添加 `TEST_SUB_PHASE_TRANSITIONS` 状态机定义

---

### 11.5 缓存失效场景方案（问题5）

**问题**：
1. 多进程/多会话场景下，如何保证缓存一致性？
2. 如果用户手动编辑了state.json，缓存如何失效？

**设计决策**：**v1.0接受限制，v1.1实现文件Hash校验**

**v1.0策略（当前迭代）**：

```typescript
/**
 * v1.0 缓存策略：TTL + 写入时更新
 *
 * 限制：
 * 1. 多进程场景可能有最多5秒的数据不一致
 * 2. 用户手动编辑后，需等待5秒或主动触发读取
 *
 * 可接受原因：
 * 1. 当前系统是单AI会话场景，多进程场景较少
 * 2. 5秒TTL足够短，影响有限
 * 3. 用户手动编辑state.json是边缘场景
 */
class StateRepository {
  private cache: State | null = null;
  private cacheTimestamp: number = 0;
  private readonly CACHE_TTL = 5000; // 5秒

  /**
   * 读取状态（带缓存）
   */
  async read(): Promise<State> {
    if (this.isCacheValid()) {
      return this.cache!;
    }
    // ... 从文件读取并更新缓存
  }

  /**
   * 使缓存失效（供外部调用）
   * 使用场景：用户明确知道state.json被修改时调用
   */
  invalidateCache(): void {
    this.cache = null;
    this.cacheTimestamp = 0;
  }
}
```

**v1.1策略（未来迭代）**：

```typescript
/**
 * v1.1 缓存策略：文件Hash校验
 *
 * 改进：
 * 1. 每次读取时对比文件Hash
 * 2. Hash不一致则重新加载
 * 3. 可选：文件监听（fs.watch）
 */
class StateRepositoryV11 {
  private cache: State | null = null;
  private cacheHash: string | null = null;

  async read(): Promise<State> {
    // 1. 计算当前文件Hash
    const currentHash = await this.calculateFileHash();

    // 2. Hash一致，返回缓存
    if (this.cache && this.cacheHash === currentHash) {
      return this.cache;
    }

    // 3. Hash不一致或无缓存，重新加载
    const state = await this.fileIO.readJSON<State>(this.STATE_PATH);
    this.cache = state;
    this.cacheHash = currentHash;
    return state;
  }

  private async calculateFileHash(): Promise<string> {
    const content = await this.fileIO.readRaw(this.STATE_PATH);
    return crypto.createHash('md5').update(content).digest('hex');
  }
}
```

**v1.0文档说明**（需要添加到系统架构总览）：

```markdown
### 已知限制（v1.0）

| 限制 | 影响 | 规避方式 |
|------|------|---------|
| 缓存5秒TTL | 多进程场景可能有短暂不一致 | 单会话使用（当前主要场景） |
| 无文件监听 | 手动编辑state.json后缓存可能过期 | 等待5秒或重启会话 |

这些限制将在v1.1中通过文件Hash校验解决。
```

---

### 11.6 迁移原子性失败恢复机制（问题6）

**问题**：迁移操作涉及两个文件（state.json + state_his.json），如果步骤4成功后步骤5/6/7失败，状态如何恢复？

**设计决策**：**备份文件 + 事务日志 + 回滚机制**

**实现设计**：

```typescript
/**
 * 迁移事务状态
 */
interface MigrationTransaction {
  /** 事务ID */
  transactionId: string;

  /** 开始时间 */
  startedAt: string;

  /** 当前步骤 */
  currentStep: MigrationStep;

  /** 备份文件路径 */
  backupPaths: {
    state: string;
    history: string;
  };

  /** 迁移的迭代ID */
  iterationId: string;
}

type MigrationStep =
  | 'started'
  | 'backup_created'
  | 'history_written'
  | 'state_cleaned'
  | 'completed'
  | 'rolled_back';

/**
 * 迁移事务日志路径
 */
const MIGRATION_LOG_PATH = '.solodev/migration.log.json';

/**
 * MigrationService - 带原子性保证的迁移服务
 */
class MigrationService {
  /**
   * 执行迁移（带原子性保证）
   */
  async migrate(iterationId: string): Promise<MigrationResult> {
    const transactionId = `migration-${Date.now()}`;
    let transaction: MigrationTransaction | null = null;

    try {
      // 步骤1: 创建事务日志
      transaction = await this.createTransaction(transactionId, iterationId);

      // 步骤2: 创建备份
      await this.createBackups(transaction);
      transaction.currentStep = 'backup_created';
      await this.updateTransactionLog(transaction);

      // 步骤3: 写入历史文件
      await this.writeHistory(iterationId);
      transaction.currentStep = 'history_written';
      await this.updateTransactionLog(transaction);

      // 步骤4: 清理state.json
      await this.cleanState(iterationId);
      transaction.currentStep = 'state_cleaned';
      await this.updateTransactionLog(transaction);

      // 步骤5: 完成迁移
      transaction.currentStep = 'completed';
      await this.updateTransactionLog(transaction);

      // 步骤6: 清理备份和事务日志
      await this.cleanupTransaction(transaction);

      return { success: true, migratedIterationId: iterationId };

    } catch (error) {
      // 回滚
      if (transaction) {
        await this.rollback(transaction);
      }

      return {
        success: false,
        errors: [`Migration failed: ${error.message}. Rolled back successfully.`]
      };
    }
  }

  /**
   * 创建事务
   */
  private async createTransaction(
    transactionId: string,
    iterationId: string
  ): Promise<MigrationTransaction> {
    const transaction: MigrationTransaction = {
      transactionId,
      startedAt: new Date().toISOString(),
      currentStep: 'started',
      backupPaths: {
        state: `.solodev/backup/state.${transactionId}.json`,
        history: `.solodev/backup/state_his.${transactionId}.json`
      },
      iterationId
    };

    // 确保backup目录存在
    await this.ensureDir('.solodev/backup');

    // 写入事务日志
    await this.updateTransactionLog(transaction);

    return transaction;
  }

  /**
   * 创建备份
   */
  private async createBackups(transaction: MigrationTransaction): Promise<void> {
    // 备份state.json
    await this.fileIO.copy(
      '.solodev/state.json',
      transaction.backupPaths.state
    );

    // 备份state_his.json（如果存在）
    if (await this.fileIO.exists('.solodev/state_his.json')) {
      await this.fileIO.copy(
        '.solodev/state_his.json',
        transaction.backupPaths.history
      );
    }
  }

  /**
   * 回滚事务
   */
  private async rollback(transaction: MigrationTransaction): Promise<void> {
    console.warn(`Rolling back migration transaction: ${transaction.transactionId}`);

    try {
      // 根据当前步骤决定回滚策略
      switch (transaction.currentStep) {
        case 'state_cleaned':
          // state.json已清理，需要从备份恢复
          await this.fileIO.copy(
            transaction.backupPaths.state,
            '.solodev/state.json'
          );
          // 继续回滚history
          // falls through

        case 'history_written':
          // history已写入，需要从备份恢复（或删除新增内容）
          if (await this.fileIO.exists(transaction.backupPaths.history)) {
            await this.fileIO.copy(
              transaction.backupPaths.history,
              '.solodev/state_his.json'
            );
          } else {
            // 原来没有history文件，删除新创建的
            await this.fileIO.delete('.solodev/state_his.json');
          }
          break;

        case 'backup_created':
        case 'started':
          // 还没修改任何文件，无需回滚
          break;
      }

      // 更新事务状态
      transaction.currentStep = 'rolled_back';
      await this.updateTransactionLog(transaction);

      // 清理备份
      await this.cleanupBackups(transaction);

    } catch (rollbackError) {
      console.error('Rollback failed!', rollbackError);
      console.error('Manual recovery required. Backup files:', transaction.backupPaths);
      throw new MigrationRollbackError(
        `Rollback failed. Manual recovery required. Backups: ${JSON.stringify(transaction.backupPaths)}`
      );
    }
  }

  /**
   * 清理事务（成功后）
   */
  private async cleanupTransaction(transaction: MigrationTransaction): Promise<void> {
    await this.cleanupBackups(transaction);
    await this.fileIO.delete(MIGRATION_LOG_PATH);
  }

  /**
   * 清理备份文件
   */
  private async cleanupBackups(transaction: MigrationTransaction): Promise<void> {
    if (await this.fileIO.exists(transaction.backupPaths.state)) {
      await this.fileIO.delete(transaction.backupPaths.state);
    }
    if (await this.fileIO.exists(transaction.backupPaths.history)) {
      await this.fileIO.delete(transaction.backupPaths.history);
    }
  }

  /**
   * 更新事务日志
   */
  private async updateTransactionLog(transaction: MigrationTransaction): Promise<void> {
    await this.fileIO.writeJSON(MIGRATION_LOG_PATH, transaction);
  }

  /**
   * 恢复未完成的事务（启动时调用）
   */
  async recoverPendingTransaction(): Promise<void> {
    if (!await this.fileIO.exists(MIGRATION_LOG_PATH)) {
      return;
    }

    const transaction = await this.fileIO.readJSON<MigrationTransaction>(MIGRATION_LOG_PATH);

    if (transaction.currentStep !== 'completed' && transaction.currentStep !== 'rolled_back') {
      console.warn('Found incomplete migration transaction, rolling back...');
      await this.rollback(transaction);
    }

    // 清理事务日志
    await this.fileIO.delete(MIGRATION_LOG_PATH);
  }
}

/**
 * 迁移回滚错误
 */
class MigrationRollbackError extends Error {
  readonly code = 'MIGRATION_ROLLBACK_ERROR';

  constructor(message: string) {
    super(message);
    this.name = 'MigrationRollbackError';
  }
}
```

**启动时检查**：

```typescript
// StateManager初始化时
class StateManager {
  async initialize(): Promise<void> {
    // 检查并恢复未完成的迁移事务
    await this.migrationService.recoverPendingTransaction();

    // 其他初始化逻辑...
  }
}
```

**迁移流程图**：

```
开始迁移
  ↓
步骤1: 创建事务日志 (migration.log.json)
  ↓
步骤2: 创建备份
  ├─ 备份 state.json → backup/state.{id}.json
  └─ 备份 state_his.json → backup/state_his.{id}.json
  ↓
步骤3: 写入 state_his.json
  ↓                          ← 如果失败，从备份恢复 state_his.json
步骤4: 清理 state.json
  ↓                          ← 如果失败，从备份恢复 state.json
步骤5: 标记事务完成
  ↓
步骤6: 清理备份和事务日志
  ↓
迁移完成
```

**关键保证**：
1. **任何步骤失败都能回滚**：通过备份文件恢复原始状态
2. **崩溃恢复**：启动时检查migration.log.json，自动回滚未完成事务
3. **回滚失败处理**：记录备份路径，便于人工恢复
