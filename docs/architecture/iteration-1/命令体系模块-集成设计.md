# 命令体系模块 - 集成设计

<!--
章节ID规范说明：
- 格式：{#arch-集成-命令体系-[章节标识]}
- 必须标注ID的章节：调用序列、接口定义、集成点
- 示例：{#arch-集成-命令体系-集成点列表} 表示命令体系模块集成设计的集成点列表章节
-->

> **项目**: AI超级个体开发助手
> **版本**: v1.0.0
> **迭代**: Iteration 1
> **模块**: 命令体系模块
> **日期**: 2025-12-15
> **集成复杂度**: simple

---

## 一、集成概述

### 1.1 依赖关系

命令体系模块是系统的**用户交互入口**，依赖多个模块完成工作：

```
                    ┌───────────────────────┐
                    │      用户输入          │
                    │  /start-architecture  │
                    └───────────┬───────────┘
                                ↓
┌───────────────────────────────────────────────────────┐
│               【命令体系模块】                          │
│  · 命令解析 · 前置条件检查 · 上下文加载 · 任务协调     │
└───────────────────────────────────────────────────────┘
                                ↓ 依赖
        ┌───────────────────────┼───────────────────────┐
        │                       │                       │
        ↓                       ↓                       ↓
┌───────────────┐    ┌───────────────────┐    ┌───────────────┐
│【状态管理模块】│    │  【核心流程模型】  │    │【文档模板模块】│
│ · 状态读写    │    │  · 阶段定义       │    │ · 模板读取    │
│ · 上下文加载  │    │  · 验证规则       │    │ · 文档生成    │
│ · 审批执行    │    └───────────────────┘    └───────────────┘
└───────────────┘
        │
        ↓
┌───────────────┐
│ 【Git集成模块】│
│ · 自动提交    │
└───────────────┘
```

### 1.2 集成目标

**作为依赖方**：
- 调用状态管理模块读写状态
- 调用状态管理模块获取上下文
- 调用核心流程模型获取阶段定义和验证
- 调用文档模板模块生成文档
- 触发Git集成模块自动提交

**作为被依赖方**：
- 命令体系模块是最上层模块，不被其他模块依赖
- 仅对外提供命令执行入口

### 1.3 集成复杂度说明

**为何标记为"simple"**：
- ✅ 单向依赖，无循环
- ✅ 接口调用清晰
- ✅ 数据流向明确
- ✅ 错误处理直接

---

## 二、与状态管理模块的集成 {#arch-集成-命令体系-状态管理}

### 2.1 集成点列表 {#arch-集成-命令体系-集成点列表}

| 接口 | 用途 | 调用时机 |
|------|------|---------|
| `readState()` | 读取当前状态 | 命令执行前 |
| `getCurrentPhase()` | 获取当前阶段 | 前置条件检查 |
| `getContextForPhase()` | 获取阶段级上下文 | 上下文加载 |
| `getContextForModule()` | 获取模块级上下文 | 上下文加载 |
| `transitionPhase()` | 执行阶段流转 | 阶段命令执行 |
| `approvePhase()` | 执行阶段审批 | 审批命令执行 |
| `updateModuleStatus()` | 更新模块状态 | 模块完成时 |

### 2.2 详细集成设计

#### 接口1：readState

**调用场景**：命令执行前读取当前状态

```typescript
// 命令体系模块中的使用
class CommandExecutor {
  constructor(private stateManager: StateManager) {}

  async execute(input: string): Promise<ExecutionResult> {
    // 1. 解析命令
    const parsed = this.parser.parse(input);

    // 2. 读取当前状态（判断前置条件）
    let state: State;
    try {
      state = await this.stateManager.readState();
    } catch (error) {
      if (error instanceof StateFileNotFoundError) {
        return {
          success: false,
          command: parsed.name,
          message: 'state.json不存在，请先初始化项目',
          errors: [error.message]
        };
      }
      throw error;
    }

    // 3. 继续执行...
  }
}
```

**调用序列**：

```
用户执行命令
  ↓
【命令体系模块】CommandExecutor.execute()
  ↓
【命令体系模块】调用 stateManager.readState()
  ↓
【状态管理模块】StateManager.readState()
  ├─ 检查缓存
  ├─ 读取文件
  └─ 返回 State
  ↓
【命令体系模块】基于状态判断前置条件
```

---

#### 接口2：getContextForPhase

**调用场景**：加载阶段级上下文

```typescript
// 命令体系模块中的使用
class ContextIntegrator {
  constructor(private stateManager: StateManager) {}

  async loadPhaseContext(phase: string): Promise<ExecutionContext> {
    // 调用状态管理模块获取上下文
    const contextResult = await this.stateManager.getContextForPhase(phase);

    // 检查结果
    if (!contextResult.success) {
      throw new ContextLoadError(
        contextResult.error || '上下文加载失败',
        contextResult.missingDocuments
      );
    }

    // 显示警告
    if (contextResult.warnings && contextResult.warnings.length > 0) {
      console.warn('上下文加载警告:');
      contextResult.warnings.forEach(w => console.warn(`  - ${w}`));
    }

    // 构建执行上下文
    return {
      type: 'phase',
      phase,
      documents: contextResult.documents.map(d => ({
        path: d,
        type: this.inferDocumentType(d),
        required: true,
        exists: true
      })),
      stateFields: contextResult.stateFields,
      metadata: {
        loadedAt: new Date().toISOString(),
        totalDocuments: contextResult.documents.length,
        estimatedSizeKB: contextResult.estimatedSizeKB || 0,
        exceedsLimit: (contextResult.estimatedSizeKB || 0) > 100
      }
    };
  }
}
```

**调用序列**：

```
用户执行 /start-architecture
  ↓
【命令体系模块】ContextIntegrator.loadPhaseContext('architecture')
  ↓
【命令体系模块】调用 stateManager.getContextForPhase('architecture')
  ↓
【状态管理模块】计算需要加载的上下文
  ├─ 读取 state.json
  ├─ 查找 requirements 阶段的所有PRD文档
  ├─ 查找已完成的架构文档
  ├─ 提取相关 state.json 字段
  └─ 返回 ContextResult
  ↓
【命令体系模块】构建 ExecutionContext
  ↓
【命令体系模块】展示上下文给AI
```

---

#### 接口3：getContextForModule

**调用场景**：加载模块级上下文（/custom-task命令）

```typescript
// 命令体系模块中的使用
class ContextIntegrator {
  async loadCustomContext(modules: string[]): Promise<ExecutionContext> {
    const state = await this.stateManager.readState();
    const currentPhase = state.iterations[state.currentIteration].currentPhase;

    const allDocuments: ContextDocument[] = [];
    const allDependencies: string[] = [];

    // 对每个模块加载上下文
    for (const moduleName of modules) {
      const contextResult = await this.stateManager.getContextForModule(
        moduleName,
        currentPhase
      );

      if (!contextResult.success) {
        throw new ContextLoadError(
          `模块"${moduleName}"上下文加载失败: ${contextResult.error}`
        );
      }

      // 收集文档
      contextResult.documents.forEach(d => {
        if (!allDocuments.find(doc => doc.path === d)) {
          allDocuments.push({
            path: d,
            type: this.inferDocumentType(d),
            module: moduleName,
            required: true,
            exists: true
          });
        }
      });

      // 收集依赖
      if (contextResult.dependencies) {
        contextResult.dependencies.forEach(dep => {
          if (!allDependencies.includes(dep)) {
            allDependencies.push(dep);
          }
        });
      }
    }

    return {
      type: 'custom',
      modules,
      phase: currentPhase,
      documents: allDocuments,
      dependencies: allDependencies,
      metadata: {
        loadedAt: new Date().toISOString(),
        totalDocuments: allDocuments.length,
        estimatedSizeKB: this.estimateSize(allDocuments),
        exceedsLimit: this.estimateSize(allDocuments) > 100
      }
    };
  }
}
```

---

#### 接口4：transitionPhase

**调用场景**：执行阶段流转

```typescript
// 命令体系模块中的使用
class PhaseCommandExecutor {
  constructor(private stateManager: StateManager) {}

  async executeStartCommand(
    targetPhase: string
  ): Promise<ExecutionResult> {
    // 1. 执行阶段流转
    const result = await this.stateManager.transitionPhase(targetPhase);

    if (!result.success) {
      return {
        success: false,
        command: `start-${targetPhase}`,
        message: `阶段流转失败`,
        errors: result.errors,
        waitingForApproval: false,
        artifacts: []
      };
    }

    // 2. 显示警告
    if (result.warnings && result.warnings.length > 0) {
      console.warn('阶段流转警告:', result.warnings);
    }

    return {
      success: true,
      command: `start-${targetPhase}`,
      message: `已进入${targetPhase}阶段`,
      warnings: result.warnings,
      waitingForApproval: false,
      nextAction: this.suggestNextAction(targetPhase),
      artifacts: []
    };
  }
}
```

**调用序列**：

```
用户执行 /start-architecture
  ↓
【命令体系模块】PhaseCommandExecutor.executeStartCommand('architecture')
  ↓
【命令体系模块】调用 stateManager.transitionPhase('architecture')
  ↓
【状态管理模块】StateService.transitionPhase()
  ├─ 调用【核心流程模型】validatePhaseTransition()
  ├─ 更新 state.json
  │   - currentPhase = 'architecture'
  │   - phases.requirements.status = 'completed'
  │   - phases.architecture.status = 'in_progress'
  ├─ 记录 changeHistory
  └─ 返回 TransitionResult
  ↓
【命令体系模块】根据结果返回 ExecutionResult
```

---

#### 接口5：approvePhase

**调用场景**：执行阶段审批

```typescript
// 命令体系模块中的使用
class ApprovalHandler {
  constructor(private stateManager: StateManager) {}

  async handleApproval(
    phase: string,
    approvedBy: string
  ): Promise<ApprovalResult> {
    // 1. 执行审批
    const result = await this.stateManager.approvePhase(phase, approvedBy);

    if (!result.success) {
      return {
        success: false,
        errors: result.errors
      };
    }

    // 2. 返回成功结果
    return {
      success: true,
      approvedAt: result.approvedAt,
      nextAction: this.suggestNextAction(phase)
    };
  }

  private suggestNextAction(phase: string): string {
    const nextActions: Record<string, string> = {
      requirements: '可以执行 /start-architecture 启动架构设计',
      architecture: '可以执行 /start-implementation 启动实现阶段',
      implementation: '可以执行 /start-testing 启动测试阶段',
      testing: '可以执行 /start-deployment 启动部署阶段',
      deployment: '迭代完成！'
    };
    return nextActions[phase] || '';
  }
}
```

**调用序列**：

```
用户执行 /approve-architecture
  ↓
【命令体系模块】ApprovalHandler.handleApproval('architecture', 'human')
  ↓
【命令体系模块】调用 stateManager.approvePhase()
  ↓
【状态管理模块】StateService.approvePhase()
  ├─ 检查阶段状态 (必须是 in_progress)
  ├─ 检查所有模块已完成
  ├─ 更新 state.json
  │   - phases.architecture.status = 'approved'
  │   - phases.architecture.approvedAt = timestamp
  │   - phases.architecture.approvedBy = 'human'
  ├─ 记录 changeHistory
  └─ 返回 ApproveResult
  ↓
【命令体系模块】返回 ApprovalResult
```

---

## 三、与核心流程模型的集成 {#arch-集成-命令体系-核心流程}

### 3.1 集成点列表

| 接口 | 用途 | 调用时机 |
|------|------|---------|
| `getPhaseDefinition()` | 获取阶段定义 | 前置条件检查 |
| `validatePhaseTransition()` | 验证阶段流转 | 间接调用（通过状态管理模块） |

### 3.2 详细集成设计

#### 接口1：getPhaseDefinition

**调用场景**：获取阶段元信息（判断是否需要审批等）

```typescript
// 命令体系模块中的使用
class PreconditionChecker {
  constructor(private coreProcess: CoreProcessAPI) {}

  async checkPhaseApprovalRequired(
    commandName: string
  ): Promise<boolean> {
    // 获取目标阶段
    const phase = this.commandToPhase(commandName);
    if (!phase) return false;

    // 获取阶段定义
    const definition = this.coreProcess.getPhaseDefinition(phase);

    return definition.needsApproval;
  }

  async getPhaseCompletionCriteria(
    phase: string
  ): Promise<CompletionCriteria> {
    const definition = this.coreProcess.getPhaseDefinition(phase);
    return definition.completionCriteria;
  }
}
```

**调用序列**：

```
用户执行 /start-architecture
  ↓
【命令体系模块】PreconditionChecker.check()
  ↓
【命令体系模块】调用 coreProcess.getPhaseDefinition('architecture')
  ↓
【核心流程模型】返回 PhaseDefinition
  {
    name: 'architecture',
    order: 2,
    needsApproval: true,
    artifactTypes: ['系统架构总览', '数据模型设计', '集成设计'],
    nextPhase: 'implementation',
    canRollbackTo: ['requirements']
  }
  ↓
【命令体系模块】根据定义判断前置条件
```

---

## 四、与文档模板模块的集成 {#arch-集成-命令体系-文档模板}

### 4.1 集成点列表

| 接口 | 用途 | 调用时机 |
|------|------|---------|
| `readTemplate()` | 读取模板文件 | 文档生成前 |
| `fillTemplate()` | 填充模板变量 | 文档生成时 |
| `validateReferences()` | 验证文档引用 | 文档生成后 |

### 4.2 详细集成设计

```typescript
// 命令体系模块中的使用
class DocumentGenerator {
  constructor(
    private templateModule: TemplateModule,
    private stateManager: StateManager
  ) {}

  async generateArchitectureDoc(
    moduleName: string
  ): Promise<GenerationResult> {
    // 1. 读取状态获取变量
    const state = await this.stateManager.readState();
    const variables = this.buildVariables(state, moduleName);

    // 2. 读取模板
    const template = await this.templateModule.readTemplate(
      '.solodev/templates/architecture-system-overview-template.md'
    );

    // 3. 填充模板
    const content = await this.templateModule.fillTemplate(template, variables);

    // 4. 写入文件
    const outputPath = `docs/architecture/iteration-1/${moduleName}-00-系统架构总览.md`;
    await fs.writeFile(outputPath, content);

    // 5. 验证引用
    const validationResult = await this.templateModule.validateReferences(outputPath);

    if (validationResult.errors.length > 0) {
      return {
        success: false,
        errors: validationResult.errors
      };
    }

    return {
      success: true,
      outputPath,
      warnings: validationResult.warnings
    };
  }

  private buildVariables(state: State, moduleName: string): Record<string, string> {
    const iteration = state.iterations[state.currentIteration];
    return {
      '[项目名称]': state.project.name,
      '[版本号]': iteration.version,
      '[迭代]': iteration.id,
      '[日期]': new Date().toISOString().split('T')[0],
      '[模块名称]': moduleName
    };
  }
}
```

---

## 五、与Git集成模块的集成 {#arch-集成-命令体系-Git集成}

### 5.1 集成点列表

| 接口 | 用途 | 调用时机 |
|------|------|---------|
| `commitStateChange()` | 提交状态变更 | 阶段流转后、审批后 |
| `commitDocuments()` | 提交文档变更 | 文档生成后 |

### 5.2 详细集成设计

```typescript
// 命令体系模块中的使用
class GitIntegrator {
  constructor(private gitModule: GitModule) {}

  async commitAfterPhaseTransition(
    fromPhase: string,
    toPhase: string
  ): Promise<void> {
    const message = `chore(state): 阶段流转 ${fromPhase} → ${toPhase}`;

    await this.gitModule.commitStateChange(message);
  }

  async commitAfterApproval(phase: string): Promise<void> {
    const message = `chore(state): ${phase}阶段审批通过`;

    await this.gitModule.commitStateChange(message);
  }

  async commitDocuments(
    phase: string,
    moduleName: string,
    documents: string[]
  ): Promise<void> {
    const message = `docs(${phase}): 生成${moduleName}文档`;

    await this.gitModule.commitDocuments(documents, message);
  }
}
```

---

## 六、完整命令执行流程 {#arch-集成-命令体系-完整流程}

### 6.1 阶段命令执行流程

以 `/start-architecture` 为例：

```
用户输入: /start-architecture
  ↓
【1. 命令解析】
CommandParser.parse("/start-architecture")
  → ParsedCommand { name: "start-architecture", args: {} }
  ↓
【2. 前置条件检查】
PreconditionChecker.check()
  │
  ├─ 调用 stateManager.readState()
  │   → 获取当前状态
  │
  ├─ 检查 state.json 存在
  │   → 通过
  │
  ├─ 调用 coreProcess.getPhaseDefinition('architecture')
  │   → 获取阶段定义
  │
  └─ 检查 requirements 阶段已审批
      → state.phases.requirements.status === 'approved'
      → 通过
  ↓
【3. 上下文加载】
ContextIntegrator.loadPhaseContext('architecture')
  │
  └─ 调用 stateManager.getContextForPhase('architecture')
      │
      └─ 返回 ContextResult
          {
            documents: [
              "docs/PRD/PRD.md",
              "docs/PRD/modules/核心流程模型-PRD.md",
              "docs/PRD/modules/状态管理模块-PRD.md",
              ...
            ],
            stateFields: [
              { path: "moduleDependencies", value: {...} },
              { path: "project", value: {...} }
            ]
          }
  ↓
【4. 展示上下文确认】
"将加载以下上下文:
 - docs/PRD/PRD.md
 - docs/PRD/modules/核心流程模型-PRD.md
 - docs/PRD/modules/状态管理模块-PRD.md
 - ...
 是否继续? (y/n)"
  ↓
用户确认 (y)
  ↓
【5. 状态更新】
调用 stateManager.transitionPhase('architecture')
  │
  ├─ 内部调用 coreProcess.validatePhaseTransition()
  │   → 验证通过
  │
  └─ 更新 state.json
      - currentPhase = 'architecture'
      - phases.requirements.status = 'completed'
      - phases.architecture.status = 'in_progress'
      - phases.architecture.startedAt = timestamp
  ↓
【6. Git提交】
GitIntegrator.commitAfterPhaseTransition()
  │
  └─ 调用 gitModule.commitStateChange()
      → git commit -m "chore(state): 阶段流转 requirements → architecture"
  ↓
【7. 任务执行】
AI基于上下文执行架构设计
  │
  ├─ 读取架构模板
  ├─ 逐模块设计架构
  └─ 生成架构文档
  ↓
【8. 文档提交】
GitIntegrator.commitDocuments()
  │
  └─ 调用 gitModule.commitDocuments()
      → git commit -m "docs(architecture): 生成核心流程模型文档"
  ↓
【9. 审批检测】
ApprovalDetector.detectApprovalPoint()
  │
  └─ 返回 ApprovalPointInfo
      {
        phase: 'architecture',
        approvalCommand: '/approve-architecture',
        message: '架构设计完成，请审批架构文档'
      }
  ↓
【10. 返回结果】
ExecutionResult
{
  success: true,
  command: 'start-architecture',
  message: '架构设计完成',
  waitingForApproval: true,
  approvalInfo: { ... },
  artifacts: ['docs/architecture/iteration-1/...']
}
```

### 6.2 审批命令执行流程

以 `/approve-architecture` 为例：

```
用户输入: /approve-architecture
  ↓
【1. 命令解析】
CommandParser.parse("/approve-architecture")
  → ParsedCommand { name: "approve-architecture", args: {} }
  ↓
【2. 前置条件检查】
PreconditionChecker.check()
  │
  ├─ 检查 state.json 存在 → 通过
  │
  └─ 检查 architecture 阶段状态 === 'in_progress'
      → 通过
  ↓
【3. 模块完成检查】
调用 stateManager.readState()
  │
  └─ 检查所有模块 status === 'completed' 或 'approved'
      → 通过
  ↓
【4. 执行审批】
ApprovalHandler.handleApproval('architecture', 'human')
  │
  └─ 调用 stateManager.approvePhase('architecture', 'human')
      │
      └─ 更新 state.json
          - phases.architecture.status = 'approved'
          - phases.architecture.approvedAt = timestamp
          - phases.architecture.approvedBy = 'human'
  ↓
【5. Git提交】
GitIntegrator.commitAfterApproval('architecture')
  │
  └─ 调用 gitModule.commitStateChange()
      → git commit -m "chore(state): architecture阶段审批通过"
  ↓
【6. 返回结果】
ApprovalResult
{
  success: true,
  approvedAt: '2025-12-15T10:00:00Z',
  nextAction: '可以执行 /start-implementation 启动实现阶段'
}
```

---

## 七、错误处理协议

### 7.1 错误传播策略

```
【命令体系模块】捕获所有下游错误，转换为用户友好消息
     │
     ├─ StateFileNotFoundError → "state.json不存在，请先初始化项目"
     │
     ├─ StateFileCorruptedError → "state.json格式错误，请检查或从Git恢复"
     │
     ├─ PhaseTransitionError → "阶段流转失败: {具体原因}"
     │
     ├─ ContextLoadError → "上下文加载失败: {具体原因}"
     │
     └─ 其他错误 → "命令执行失败: {错误消息}"
```

### 7.2 错误处理示例

```typescript
class CommandExecutor {
  async execute(input: string): Promise<ExecutionResult> {
    try {
      // 1. 解析命令
      const parsed = this.parser.parse(input);

      // 2. 检查前置条件
      const preconditionResult = await this.checker.check(parsed.name);
      if (!preconditionResult.passed) {
        return this.buildErrorResult(
          parsed.name,
          new PreconditionFailedError(preconditionResult.errors)
        );
      }

      // 3. 加载上下文
      const context = await this.contextIntegrator.loadContext(parsed.name, parsed.args);

      // 4. 执行命令
      return await this.executeCommand(parsed, context);

    } catch (error) {
      return this.handleError(error, input);
    }
  }

  private handleError(error: unknown, input: string): ExecutionResult {
    const commandName = this.extractCommandName(input) || 'unknown';

    if (error instanceof InvalidCommandError) {
      return {
        success: false,
        command: commandName,
        message: error.userFriendlyMessage,
        errors: [error.message],
        waitingForApproval: false,
        artifacts: []
      };
    }

    if (error instanceof CommandNotFoundError) {
      return {
        success: false,
        command: commandName,
        message: error.userFriendlyMessage,
        errors: [error.message],
        waitingForApproval: false,
        artifacts: []
      };
    }

    if (error instanceof PreconditionFailedError) {
      return {
        success: false,
        command: commandName,
        message: error.userFriendlyMessage,
        errors: error.conditions.map(c => c.message),
        waitingForApproval: false,
        artifacts: []
      };
    }

    if (error instanceof ContextLoadError) {
      return {
        success: false,
        command: commandName,
        message: error.userFriendlyMessage,
        errors: [error.message],
        waitingForApproval: false,
        artifacts: []
      };
    }

    // 未知错误
    return {
      success: false,
      command: commandName,
      message: `命令执行失败: ${error instanceof Error ? error.message : String(error)}`,
      errors: [error instanceof Error ? error.message : String(error)],
      waitingForApproval: false,
      artifacts: []
    };
  }
}
```

---

## 八、数据流图

### 8.1 阶段命令数据流

```
┌──────────────┐
│   用户输入    │
│ /start-arch  │
└──────┬───────┘
       │ input: string
       ↓
┌──────────────────────────────────────────────────────┐
│                【命令体系模块】                         │
│  ┌─────────────────────────────────────────────────┐ │
│  │ CommandParser                                   │ │
│  │ parse(input) → ParsedCommand                    │ │
│  └───────────────────────┬─────────────────────────┘ │
│                          ↓                           │
│  ┌─────────────────────────────────────────────────┐ │
│  │ PreconditionChecker                             │ │
│  │ check(command) → PreconditionResult             │ │
│  └───────────────────────┬─────────────────────────┘ │
│                          ↓                           │
│  ┌─────────────────────────────────────────────────┐ │
│  │ ContextIntegrator                               │ │
│  │ loadContext() → ExecutionContext                │ │
│  └───────────────────────┬─────────────────────────┘ │
│                          ↓                           │
│  ┌─────────────────────────────────────────────────┐ │
│  │ PhaseCommandExecutor                            │ │
│  │ executeStartCommand() → ExecutionResult         │ │
│  └─────────────────────────────────────────────────┘ │
└────────────┬────────────────────────────┬────────────┘
             │                            │
             ↓                            ↓
┌────────────────────┐          ┌────────────────────┐
│  【状态管理模块】    │          │  【核心流程模型】   │
│  ─────────────────  │          │  ────────────────  │
│  · readState()     │          │  · getPhaseDefn() │
│  · getContext...() │          │  · validate...()  │
│  · transitionPhase()│          └────────────────────┘
│  · approvePhase()  │
└────────────────────┘
```

### 8.2 审批命令数据流

```
┌──────────────┐
│   用户输入    │
│/approve-arch │
└──────┬───────┘
       │
       ↓
┌──────────────────────────────────────────────────────┐
│                【命令体系模块】                         │
│  ┌─────────────────────────────────────────────────┐ │
│  │ CommandParser.parse()                           │ │
│  │ → ParsedCommand { name: 'approve-architecture' }│ │
│  └───────────────────────┬─────────────────────────┘ │
│                          ↓                           │
│  ┌─────────────────────────────────────────────────┐ │
│  │ ApprovalHandler.handleApproval()                │ │
│  │ → ApprovalResult                                │ │
│  └───────────────────────┬─────────────────────────┘ │
└────────────────────────────────────────┬─────────────┘
                                         │
                                         ↓
                          ┌────────────────────┐
                          │  【状态管理模块】    │
                          │  ─────────────────  │
                          │  approvePhase()    │
                          │    ↓                │
                          │  更新 state.json   │
                          │  记录 changeHistory│
                          └─────────┬──────────┘
                                    │
                                    ↓
                          ┌────────────────────┐
                          │   【Git集成模块】   │
                          │  ─────────────────  │
                          │  commitStateChange()│
                          └────────────────────┘
```

---

## 九、测试策略

### 9.1 单元测试

```typescript
describe('CommandParser', () => {
  describe('parse', () => {
    it('should parse simple command', () => {
      const result = parser.parse('/start-architecture');
      expect(result.name).toBe('start-architecture');
      expect(result.args.positional).toHaveLength(0);
    });

    it('should parse command with positional arg', () => {
      const result = parser.parse('/start-architecture 核心流程模型');
      expect(result.name).toBe('start-architecture');
      expect(result.args.positional).toContain('核心流程模型');
    });

    it('should parse command with named args', () => {
      const result = parser.parse('/custom-task --modules=A,B "任务描述"');
      expect(result.name).toBe('custom-task');
      expect(result.args.named['modules']).toBe('A,B');
      expect(result.args.positional).toContain('任务描述');
    });

    it('should throw on invalid command', () => {
      expect(() => parser.parse('start-architecture')).toThrow(InvalidCommandError);
    });
  });
});

describe('PreconditionChecker', () => {
  describe('check', () => {
    it('should pass when requirements approved', async () => {
      mockStateManager.readState.mockResolvedValue({
        iterations: {
          'iteration-1': {
            phases: {
              requirements: { status: 'approved' }
            }
          }
        },
        currentIteration: 'iteration-1'
      });

      const result = await checker.check('start-architecture');
      expect(result.passed).toBe(true);
    });

    it('should fail when requirements not approved', async () => {
      mockStateManager.readState.mockResolvedValue({
        iterations: {
          'iteration-1': {
            phases: {
              requirements: { status: 'in_progress' }
            }
          }
        },
        currentIteration: 'iteration-1'
      });

      const result = await checker.check('start-architecture');
      expect(result.passed).toBe(false);
      expect(result.errors).toHaveLength(1);
    });
  });
});
```

### 9.2 集成测试

```typescript
describe('Command Execution Integration', () => {
  it('should complete full phase transition flow', async () => {
    // 1. 准备初始状态：requirements已审批
    await setupState({
      currentPhase: 'requirements',
      phases: {
        requirements: { status: 'approved' }
      }
    });

    // 2. 执行命令
    const result = await executor.execute('/start-architecture');

    // 3. 验证结果
    expect(result.success).toBe(true);
    expect(result.command).toBe('start-architecture');

    // 4. 验证状态变更
    const state = await stateManager.readState();
    const iteration = state.iterations[state.currentIteration];
    expect(iteration.currentPhase).toBe('architecture');
    expect(iteration.phases.architecture.status).toBe('in_progress');
  });

  it('should handle approval flow correctly', async () => {
    // 1. 准备状态：architecture进行中，所有模块已完成
    await setupState({
      currentPhase: 'architecture',
      phases: {
        architecture: {
          status: 'in_progress',
          modules: {
            '核心流程模型': { status: 'completed' },
            '状态管理模块': { status: 'completed' }
          }
        }
      }
    });

    // 2. 执行审批命令
    const result = await executor.execute('/approve-architecture');

    // 3. 验证结果
    expect(result.success).toBe(true);

    // 4. 验证状态变更
    const state = await stateManager.readState();
    const iteration = state.iterations[state.currentIteration];
    expect(iteration.phases.architecture.status).toBe('approved');
    expect(iteration.phases.architecture.approvedBy).toBe('human');
  });
});
```

---

## 十、总结

### 10.1 集成关系图

```
┌─────────────────────────────────────────────────────────────┐
│                    【命令体系模块】                           │
│  ═══════════════════════════════════════════════════════   │
│  Provides:                                                  │
│  · execute(input): 命令执行入口                             │
│  · getHelp(command): 获取命令帮助                           │
│  · listCommands(): 列出所有命令                             │
│                                                             │
│  Requires (from StateManager):                              │
│  · readState()                                              │
│  · getCurrentPhase()                                        │
│  · getContextForPhase()                                     │
│  · getContextForModule()                                    │
│  · transitionPhase()                                        │
│  · approvePhase()                                           │
│  · updateModuleStatus()                                     │
│                                                             │
│  Requires (from CoreProcessModel):                          │
│  · getPhaseDefinition()                                     │
│                                                             │
│  Requires (from TemplateModule):                            │
│  · readTemplate()                                           │
│  · fillTemplate()                                           │
│  · validateReferences()                                     │
│                                                             │
│  Requires (from GitModule):                                 │
│  · commitStateChange()                                      │
│  · commitDocuments()                                        │
└─────────────────────────────────────────────────────────────┘
```

### 10.2 关键成功因素

1. **清晰的依赖关系**: 单向依赖，无循环
2. **统一的错误处理**: 所有下游错误转换为用户友好消息
3. **完整的数据流**: 从命令输入到状态更新的完整链路
4. **可测试性**: 依赖注入，便于Mock测试
5. **松耦合**: 通过接口调用，不直接访问其他模块内部

### 10.3 集成检查清单

- [ ] 状态管理模块接口调用正确
- [ ] 核心流程模型接口调用正确
- [ ] 文档模板模块接口调用正确
- [ ] Git集成模块接口调用正确
- [ ] 错误处理覆盖所有下游错误
- [ ] 单元测试覆盖率100%
- [ ] 集成测试覆盖主要流程
