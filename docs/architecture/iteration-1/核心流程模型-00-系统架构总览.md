# 核心流程模型 - 系统架构总览

<!--
章节ID规范说明：
- 格式：{#arch-核心流程-[章节标识]}
- 必须标注ID的章节：模块划分、核心流程、对外接口
- 示例：{#arch-核心流程-模块划分} 表示核心流程模型系统架构的模块划分章节
-->

> **项目**: AI超级个体开发助手
> **版本**: v1.0.0
> **迭代**: Iteration 1
> **模块**: 核心流程模型
> **日期**: 2025-12-14

---

## 一、架构概述

### 1.1 模块定位

核心流程模型不是传统的"业务模块",而是整个系统的**元模型层(Meta-Model Layer)**:

```
┌─────────────────────────────────────────────────────┐
│              用户交互层(User Interface)              │
│  ───────────────────────────────────────────────── │
│  Slash Commands: /start-requirements, /approve ...  │
└───────────────────────┬─────────────────────────────┘
                        ↓ 触发命令
┌─────────────────────────────────────────────────────┐
│           命令体系模块(Command System)               │
│  ───────────────────────────────────────────────── │
│  解析命令 → 调用状态管理模块 → 执行业务逻辑         │
└───────────────────────┬─────────────────────────────┘
                        ↓ 读写状态
┌─────────────────────────────────────────────────────┐
│          状态管理模块(State Management)              │
│  ───────────────────────────────────────────────── │
│  读取/更新 state.json,执行状态流转                  │
└───────────────────────┬─────────────────────────────┘
                        ↓ 依赖规则
┌─────────────────────────────────────────────────────┐
│      【核心流程模型】(Core Process Model)           │
│  ═══════════════════════════════════════════════   │
│  ┌─────────────────────────────────────────────┐   │
│  │  元模型定义层(Meta-Model Definition)        │   │
│  │  ─────────────────────────────────────────  │   │
│  │  · Schema定义: Phase/Iteration/Module类型   │   │
│  │  · 规则配置: 阶段流转规则、审批点定义      │   │
│  │  · 约束定义: 状态流转约束、依赖关系约束    │   │
│  └─────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────┐   │
│  │  核心算法层(Core Algorithms)                │   │
│  │  ─────────────────────────────────────────  │   │
│  │  · 依赖解析: 拓扑排序、模块调度算法        │   │
│  │  · 影响分析: 变更传播分析、影响范围计算    │   │
│  │  · 状态验证: 一致性检查、约束验证          │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
                        ↓ 数据持久化
┌─────────────────────────────────────────────────────┐
│            数据持久化层(Data Persistence)            │
│  ───────────────────────────────────────────────── │
│  state.json, state_his.json, Git Repository         │
└─────────────────────────────────────────────────────┘
```

### 1.2 核心职责

**核心流程模型是"规范定义者",不是"业务执行者"**:

| 职责类别 | 具体内容 | 非职责(由其他模块负责) |
|---------|---------|----------------------|
| **Schema定义** | 定义Phase、Iteration、Module的数据结构 | ❌ 不负责读写state.json |
| **规则配置** | 定义五阶段流转规则、审批点规则 | ❌ 不负责执行命令 |
| **算法实现** | 提供依赖解析、影响分析算法 | ❌ 不负责Git操作 |
| **约束验证** | 提供状态一致性、依赖关系验证器 | ❌ 不负责文档生成 |

### 1.3 架构特点

#### 特点1: 声明式 over 过程式

**设计理念**: 阶段流转规则作为配置,通用引擎解释执行

```typescript
// ❌ 过程式设计(硬编码)
function moveToNextPhase(currentPhase: string) {
  if (currentPhase === 'requirements') {
    return 'architecture';
  } else if (currentPhase === 'architecture') {
    return 'implementation';
  }
  // ...
}

// ✅ 声明式设计(配置驱动)
const phaseTransitionRules = {
  requirements: { nextPhase: 'architecture', needsApproval: true },
  architecture: { nextPhase: 'implementation', needsApproval: true },
  implementation: { nextPhase: 'testing', needsApproval: false },
  testing: { nextPhase: 'deployment', needsApproval: true },
  deployment: { nextPhase: null, needsApproval: true }
};

function getNextPhase(currentPhase: string): string | null {
  return phaseTransitionRules[currentPhase]?.nextPhase;
}
```

**优势**:
- 新增阶段只需修改配置,无需修改代码
- 规则清晰可见,易于理解和审查
- 便于测试和验证

#### 特点2: 纯函数算法

**设计理念**: 核心算法为纯函数,无副作用

```typescript
// 依赖解析算法 - 纯函数
function topologicalSort(dependencies: ModuleDependencies): string[] {
  // 输入: 依赖关系图
  // 输出: 拓扑排序结果
  // 无副作用: 不修改输入,不访问外部状态
}

// 影响分析算法 - 纯函数
function analyzeImpact(
  moduleName: string,
  changeType: ChangeType,
  dependencies: ModuleDependencies
): ImpactReport {
  // 输入: 模块名、变更类型、依赖关系
  // 输出: 影响报告
  // 无副作用
}
```

**优势**:
- 易于单元测试(无需Mock)
- 可并行计算(无竞态条件)
- 结果可缓存

#### 特点3: 可扩展配置

**设计理念**: 未来扩展新阶段只需修改配置

```typescript
// 当前版本: 五阶段
const phaseDefinitions = {
  requirements: { /* ... */ },
  architecture: { /* ... */ },
  implementation: { /* ... */ },
  testing: { /* ... */ },
  deployment: { /* ... */ }
};

// 未来版本: 新增"安全审计"阶段
const phaseDefinitions_v2 = {
  requirements: { /* ... */ },
  architecture: { /* ... */ },
  security_audit: {  // 新增阶段
    order: 3,
    needsApproval: true,
    artifactTypes: ['Security Report'],
    nextPhase: 'implementation'
  },
  implementation: { /* ... */ },
  testing: { /* ... */ },
  deployment: { /* ... */ }
};
```

### 1.4 关键设计决策

| 决策点 | 选择 | 理由 | 替代方案 |
|--------|------|------|---------|
| **模块定位** | 元模型层(Meta-Model) | 核心流程模型定义规则,不执行业务逻辑 | 业务模块(会导致职责不清) |
| **规则定义方式** | 声明式配置 | 易扩展、易测试、规则清晰 | 硬编码if-else(难以扩展) |
| **算法设计原则** | 纯函数 | 无副作用、易测试、可并行 | 有状态对象(难以测试) |
| **依赖解析算法** | 拓扑排序(Kahn算法) | O(V+E)复杂度,适合DAG | DFS(复杂度相同,但实现更复杂) |
| **状态流转模型** | 单向流转+回滚 | 符合敏捷开发流程 | 双向自由流转(难以追溯) |
| **模块间通信** | 函数调用(同步) | 简单直接,无需消息队列 | 事件驱动(过度设计) |

---

## 二、模块内部结构

### 2.1 模块划分 {#arch-核心流程-模块划分}

核心流程模型内部分为**三层 + 一个配置中心**:

```
核心流程模型
├── config/                      # 配置中心
│   ├── phase-definitions.ts     # 阶段定义配置
│   └── validation-rules.ts      # 验证规则配置
│
├── types/                       # 类型定义层
│   ├── phase.ts                 # Phase相关类型
│   ├── iteration.ts             # Iteration相关类型
│   ├── module.ts                # Module相关类型
│   └── transition.ts            # 状态流转相关类型
│
├── algorithms/                  # 核心算法层
│   ├── dependency-resolver.ts   # 依赖解析算法
│   ├── impact-analyzer.ts       # 影响分析算法
│   └── topological-sort.ts      # 拓扑排序算法
│
└── validators/                  # 验证器层
    ├── state-validator.ts       # 状态一致性验证
    ├── dependency-validator.ts  # 依赖关系验证
    └── transition-validator.ts  # 状态流转验证
```

### 2.2 详细模块设计

#### 模块1: 配置中心(config/)

**职责**:
- 定义五阶段的元数据(order、nextPhase、needsApproval等)
- 定义状态流转的验证规则
- 提供配置访问接口

**核心接口**:
```typescript
interface ConfigProvider {
  getPhaseDefinition(phaseName: string): PhaseDefinition;
  getAllPhaseDefinitions(): Record<string, PhaseDefinition>;
  getTransitionRules(): TransitionRules;
  getValidationRules(): ValidationRules;
}
```

**实现要点**:
- 使用TypeScript const assertion保证类型安全
- 配置作为单例,启动时加载一次
- 支持配置热更新(v2.0考虑)

---

#### 模块2: 类型定义层(types/)

**职责**:
- 定义Phase、Iteration、Module的TypeScript类型
- 定义状态枚举(PhaseStatus、IterationStatus等)
- 定义状态流转相关类型

**核心类型**:
```typescript
// types/phase.ts
type PhaseStatus = 'pending' | 'in_progress' | 'approved' | 'blocked' | 'completed';

interface PhaseDefinition {
  name: string;
  order: number;
  needsApproval: boolean;
  artifactTypes: string[];
  nextPhase: string | null;
  canRollbackTo: string[];
  validators: string[];  // 验证器名称列表
}

interface PhaseState {
  status: PhaseStatus;
  startedAt?: string;
  approvedAt?: string;
  approvedBy?: string;
  modules: Record<string, ModuleState>;
}

// types/iteration.ts
type IterationStatus = 'pending' | 'in_progress' | 'completed';

interface Iteration {
  id: string;
  version: string;
  goal: string;
  status: IterationStatus;
  startedAt: string;
  completedAt?: string;
  deployedAt?: string;
  currentPhase: string;
  phases: Record<string, PhaseState>;
}

// types/module.ts
interface ModuleDependency {
  moduleName: string;
  dependsOn: string[];
  dependedBy: string[];
  isFoundation: boolean;
  integrationPoints?: IntegrationPoint[];
}

interface IntegrationPoint {
  targetModule: string;
  interface: string;
  purpose: string;
  dataFlow: string;
  errorHandling: string;
  complexity: 'simple' | 'complex';
  integrationDoc?: string;
}

// types/transition.ts
interface TransitionRequest {
  from: string;
  to: string;
  reason?: string;
}

interface TransitionResult {
  success: boolean;
  newPhase: string;
  errors?: string[];
  warnings?: string[];
}
```

**实现要点**:
- 使用TypeScript严格模式(strict: true)
- 所有枚举使用联合类型(union types)而非enum
- 提供类型守卫(type guards)辅助函数

---

#### 模块3: 核心算法层(algorithms/)

**职责**:
- 实现依赖解析算法(拓扑排序)
- 实现影响分析算法(逆向依赖遍历)
- 实现模块调度算法

**核心算法1: 拓扑排序(Topological Sort)**

```typescript
/**
 * 拓扑排序 - 计算模块的实现顺序
 * 使用Kahn算法: O(V+E)复杂度
 */
function topologicalSort(dependencies: ModuleDependencies): string[] {
  // 1. 计算每个模块的入度
  const inDegree = new Map<string, number>();
  const graph = new Map<string, string[]>();

  // 2. 初始化入度为0的模块队列
  const queue: string[] = [];

  // 3. Kahn算法主循环
  const result: string[] = [];
  while (queue.length > 0) {
    const module = queue.shift()!;
    result.push(module);

    // 减少依赖此模块的其他模块的入度
    for (const dependent of graph.get(module) || []) {
      inDegree.set(dependent, inDegree.get(dependent)! - 1);
      if (inDegree.get(dependent) === 0) {
        queue.push(dependent);
      }
    }
  }

  // 4. 检测循环依赖
  if (result.length !== inDegree.size) {
    throw new Error('Circular dependency detected');
  }

  return result;
}
```

**核心算法2: 影响分析(Impact Analysis)**

```typescript
/**
 * 影响分析 - 计算模块变更的影响范围
 * 使用BFS逆向遍历依赖图
 */
function analyzeImpact(
  moduleName: string,
  changeType: 'requirements' | 'architecture' | 'implementation',
  dependencies: ModuleDependencies
): ImpactReport {
  const affected: Set<string> = new Set([moduleName]);
  const queue: string[] = [moduleName];

  // BFS遍历所有依赖此模块的其他模块
  while (queue.length > 0) {
    const current = queue.shift()!;
    const dependedBy = dependencies[current]?.dependedBy || [];

    for (const module of dependedBy) {
      if (!affected.has(module)) {
        affected.add(module);
        queue.push(module);
      }
    }
  }

  // 根据变更类型确定影响的阶段
  const impactedPhases = determineImpactedPhases(changeType);

  return {
    sourceModule: moduleName,
    changeType,
    affectedModules: Array.from(affected),
    impactedPhases,
    estimatedEffort: calculateEffort(affected.size, changeType)
  };
}
```

**核心算法3: 并行调度(Parallel Scheduling)**

```typescript
/**
 * 并行调度 - 计算可以并行执行的模块批次
 * 返回: [[batch1_modules], [batch2_modules], ...]
 */
function scheduleParallelExecution(
  dependencies: ModuleDependencies
): string[][] {
  const sorted = topologicalSort(dependencies);
  const batches: string[][] = [];
  const processed = new Set<string>();

  while (processed.size < sorted.length) {
    const batch: string[] = [];

    for (const module of sorted) {
      if (processed.has(module)) continue;

      // 检查此模块的所有依赖是否已处理
      const deps = dependencies[module]?.dependsOn || [];
      const allDepsProcessed = deps.every(dep => processed.has(dep));

      if (allDepsProcessed) {
        batch.push(module);
      }
    }

    if (batch.length === 0) {
      throw new Error('Scheduling deadlock detected');
    }

    batches.push(batch);
    batch.forEach(m => processed.add(m));
  }

  return batches;
}
```

**实现要点**:
- 所有算法为纯函数,无副作用
- 提供详细的JSDoc注释,包含算法复杂度
- 提供单元测试,覆盖率100%

---

#### 模块4: 验证器层(validators/)

**职责**:
- 验证state.json的一致性
- 验证依赖关系的合法性
- 验证状态流转的合法性

**核心验证器1: 状态一致性验证**

```typescript
/**
 * 验证state.json的一致性
 */
function validateStateIntegrity(state: State): ValidationResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  // 约束1: currentIteration必须存在于iterations中
  if (!state.iterations[state.currentIteration]) {
    errors.push(`currentIteration "${state.currentIteration}" not found in iterations`);
  }

  // 约束2: currentPhase必须存在于当前迭代的phases中
  const currentIter = state.iterations[state.currentIteration];
  if (currentIter && !currentIter.phases[currentIter.currentPhase]) {
    errors.push(`currentPhase "${currentIter.currentPhase}" not found in phases`);
  }

  // 约束3: 已完成的阶段不应该有pending状态的模块
  for (const [phaseName, phaseState] of Object.entries(currentIter.phases)) {
    if (phaseState.status === 'completed') {
      const pendingModules = Object.entries(phaseState.modules)
        .filter(([_, m]) => m.status === 'pending')
        .map(([name]) => name);

      if (pendingModules.length > 0) {
        warnings.push(
          `Phase "${phaseName}" is completed but has pending modules: ${pendingModules.join(', ')}`
        );
      }
    }
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}
```

**核心验证器2: 依赖关系验证**

```typescript
/**
 * 验证依赖关系的合法性
 */
function validateDependencies(dependencies: ModuleDependencies): ValidationResult {
  const errors: string[] = [];

  // 约束1: 依赖图必须是DAG(有向无环图)
  try {
    topologicalSort(dependencies);
  } catch (error) {
    errors.push('Circular dependency detected in module dependencies');
  }

  // 约束2: 依赖关系必须双向一致
  for (const [moduleName, dep] of Object.entries(dependencies)) {
    for (const depModule of dep.dependsOn) {
      const targetDep = dependencies[depModule];
      if (!targetDep?.dependedBy.includes(moduleName)) {
        errors.push(
          `Inconsistent dependency: ${moduleName} depends on ${depModule}, ` +
          `but ${depModule}.dependedBy does not include ${moduleName}`
        );
      }
    }
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings: []
  };
}
```

**核心验证器3: 状态流转验证**

```typescript
/**
 * 验证阶段流转是否合法
 */
function validatePhaseTransition(
  currentPhase: string,
  targetPhase: string,
  phaseDefinitions: Record<string, PhaseDefinition>
): ValidationResult {
  const errors: string[] = [];

  const currentDef = phaseDefinitions[currentPhase];
  const targetDef = phaseDefinitions[targetPhase];

  if (!currentDef) {
    errors.push(`Unknown current phase: ${currentPhase}`);
  }

  if (!targetDef) {
    errors.push(`Unknown target phase: ${targetPhase}`);
  }

  if (errors.length > 0) {
    return { isValid: false, errors, warnings: [] };
  }

  // 正向流转: 检查nextPhase
  if (currentDef.nextPhase === targetPhase) {
    return { isValid: true, errors: [], warnings: [] };
  }

  // 回滚: 检查canRollbackTo
  if (currentDef.canRollbackTo.includes(targetPhase)) {
    return {
      isValid: true,
      errors: [],
      warnings: [`Rollback detected: ${currentPhase} → ${targetPhase}`]
    };
  }

  errors.push(
    `Invalid phase transition: ${currentPhase} → ${targetPhase}. ` +
    `Allowed: ${currentDef.nextPhase || 'none'}, rollback to: ${currentDef.canRollbackTo.join(', ')}`
  );

  return { isValid: false, errors, warnings: [] };
}
```

**实现要点**:
- 提供丰富的错误信息,包含上下文
- 区分errors(阻止操作)和warnings(提示但不阻止)
- 所有验证器可独立使用

---

## 三、核心流程

### 3.1 主要业务流程 {#arch-核心流程-业务流程}

#### 流程1: 阶段流转流程

```
用户执行命令(/approve, /start-next-phase)
  ↓
【命令体系模块】解析命令
  ↓
【命令体系模块】调用【状态管理模块】
  ↓
【状态管理模块】调用【核心流程模型】验证阶段流转
  ↓
【核心流程模型】.validators.validatePhaseTransition()
  ├─ 检查: currentPhase → targetPhase 是否合法
  ├─ 检查: 当前阶段是否满足完成条件
  └─ 返回: ValidationResult
  ↓
【状态管理模块】根据验证结果更新state.json
  ├─ phases[currentPhase].status = 'completed'
  └─ currentPhase = targetPhase
  ↓
【Git集成模块】创建commit记录状态变更
  ↓
返回成功/失败结果给用户
```

**涉及模块**: 核心流程模型(validators)、状态管理模块、命令体系模块、Git集成模块

---

#### 流程2: 依赖解析与模块调度流程

```
用户开始某个阶段(architecture/implementation)
  ↓
【状态管理模块】读取moduleDependencies
  ↓
【状态管理模块】调用【核心流程模型】计算执行顺序
  ↓
【核心流程模型】.algorithms.topologicalSort(dependencies)
  ├─ 计算模块的拓扑排序
  └─ 返回: ['基础模块A', '模块B', '模块C']
  ↓
【核心流程模型】.algorithms.scheduleParallelExecution(dependencies)
  ├─ 计算可并行的批次
  └─ 返回: [['模块A'], ['模块B', '模块C'], ['模块D']]
  ↓
【命令体系模块】按批次执行模块
  ├─ Batch 1: 并行处理 ['模块A']
  ├─ Batch 2: 并行处理 ['模块B', '模块C']
  └─ Batch 3: 并行处理 ['模块D']
```

**涉及模块**: 核心流程模型(algorithms)、状态管理模块、命令体系模块

---

#### 流程3: 变更影响分析流程

```
测试阶段发现问题,需要回滚
  ↓
用户执行命令(/report-issue [模块名] "问题描述")
  ↓
【影响分析模块】调用【核心流程模型】分析影响范围
  ↓
【核心流程模型】.algorithms.analyzeImpact(moduleName, changeType, dependencies)
  ├─ BFS遍历dependedBy,找到所有受影响模块
  ├─ 根据changeType确定影响的阶段
  └─ 返回: ImpactReport
  ↓
【影响分析模块】生成待办任务列表
  ├─ 任务1: 重新澄清[模块A]需求
  ├─ 任务2: 更新[模块A]架构设计
  ├─ 任务3: 更新[模块B]架构设计(受依赖影响)
  └─ ...
  ↓
【影响分析模块】展示影响报告给用户
  ↓
用户确认后,【状态管理模块】回滚相关模块状态
  ↓
【Git集成模块】创建commit记录回滚操作
```

**涉及模块**: 核心流程模型(algorithms)、影响分析模块、状态管理模块、Git集成模块

---

## 四、对外接口 {#arch-核心流程-对外接口}

核心流程模型对外暴露的接口分为四类:

### 4.1 配置访问接口

```typescript
// 获取阶段定义
function getPhaseDefinition(phaseName: string): PhaseDefinition;

// 获取所有阶段定义
function getAllPhaseDefinitions(): Record<string, PhaseDefinition>;

// 获取阶段流转规则
function getPhaseTransitionRules(): TransitionRules;
```

### 4.2 算法接口

```typescript
// 拓扑排序
function topologicalSort(dependencies: ModuleDependencies): string[];

// 并行调度
function scheduleParallelExecution(dependencies: ModuleDependencies): string[][];

// 影响分析
function analyzeImpact(
  moduleName: string,
  changeType: ChangeType,
  dependencies: ModuleDependencies
): ImpactReport;
```

### 4.3 验证接口

```typescript
// 状态一致性验证
function validateStateIntegrity(state: State): ValidationResult;

// 依赖关系验证
function validateDependencies(dependencies: ModuleDependencies): ValidationResult;

// 阶段流转验证
function validatePhaseTransition(
  currentPhase: string,
  targetPhase: string
): ValidationResult;
```

### 4.4 类型导出

```typescript
export type {
  Phase, PhaseStatus, PhaseDefinition, PhaseState,
  Iteration, IterationStatus,
  Module, ModuleDependency, IntegrationPoint,
  TransitionRequest, TransitionResult,
  ValidationResult, ImpactReport
};
```

---

## 五、非功能性设计

### 5.1 性能设计

**响应时间目标**:
- 拓扑排序: < 10ms (模块数 < 100)
- 影响分析: < 20ms (模块数 < 100)
- 状态验证: < 5ms

**优化策略**:
- 拓扑排序结果缓存(依赖关系未变时复用)
- 影响分析结果缓存(依赖关系未变时复用)
- 使用Map/Set优化图算法查找性能

### 5.2 可靠性设计

**容错机制**:
- 所有算法提供输入验证,拒绝非法输入
- 检测循环依赖,抛出清晰的错误信息
- 提供fallback机制(如拓扑排序失败时返回字母序)

**数据一致性**:
- 验证器在每次状态变更前执行
- 双向依赖关系自动校验
- state.json schema验证

### 5.3 可维护性设计

**日志策略**:
- INFO: 算法执行开始/结束
- WARN: 验证发现的警告(非阻塞)
- ERROR: 验证失败、循环依赖检测

**测试策略**:
- 单元测试覆盖率100%(强制)
- 提供测试用例集:
  - 正常场景: 线性依赖、DAG依赖
  - 异常场景: 循环依赖、孤立模块
  - 边界场景: 空依赖、单模块

---

## 六、架构演进计划

### 6.1 当前迭代范围(Iteration 1)

**已实现**:
- ✅ 五阶段定义(requirements → deployment)
- ✅ 阶段流转规则(单向流转 + 回滚)
- ✅ 依赖解析算法(拓扑排序)
- ✅ 影响分析算法(BFS遍历)

**未实现(计划外)**:
- ⏳ 配置热更新(v2.0)
- ⏳ 自定义阶段(v2.0)
- ⏳ 并行执行优化(v1.1)

### 6.2 未来迭代规划

**Iteration 2 (v1.1)**:
- 新增: 并行执行性能优化(使用Worker Pool)
- 新增: 影响分析的精细化(区分直接依赖和间接依赖)
- 优化: 拓扑排序缓存机制

**Iteration 3 (v2.0)**:
- 新增: 自定义阶段支持(用户可配置阶段)
- 新增: 动态规则引擎(支持复杂条件表达式)
- 新增: 配置热更新(无需重启)

### 6.3 技术债务

| 债务描述 | 影响 | 计划解决时间 |
|---------|------|------------|
| 当前验证器为同步执行,可能阻塞 | 性能: 验证大型state.json时可能慢 | Iteration 2 |
| 算法缓存未实现,每次重复计算 | 性能: 频繁调用时性能下降 | Iteration 2 |
| 配置为硬编码,无法动态修改 | 扩展性: 新增阶段需要发版 | Iteration 3 |

---

## 七、总结

### 核心设计理念

**核心流程模型是"规范",不是"实现"**:
- 定义What(阶段是什么、规则是什么),不定义How(如何执行)
- 提供纯函数算法,不执行有副作用的操作
- 作为元模型层,被其他模块依赖

### 关键成功因素

1. **声明式设计**: 规则作为配置,易扩展
2. **纯函数算法**: 无副作用,易测试
3. **清晰的职责边界**: 不越权,不冗余
4. **完备的验证体系**: 保证一致性
5. **可演进的架构**: 为未来扩展预留空间

### 下一步行动

1. ✅ 完成系统架构总览(当前文档)
2. ⏳ 完成数据模型设计文档
3. ⏳ 完成集成点设计文档
4. ⏳ 更新state.json记录架构设计进度
5. ⏳ Git commit架构文档
