# 核心流程模型 - 数据模型设计

> **项目**: AI超级个体开发助手
> **版本**: v1.0.0
> **迭代**: Iteration 1
> **模块**: 核心流程模型
> **日期**: 2025-12-14

---

## 一、数据模型概述

### 1.1 设计理念

核心流程模型的数据模型遵循以下设计理念:

**理念1: 状态机驱动**
- 所有实体(Iteration、Phase、Module)都是状态机
- 状态转换有明确的规则和约束
- 状态历史可追溯

**理念2: 声明式优于过程式**
- 数据结构本身描述"是什么",不描述"怎么做"
- 状态流转规则作为配置,而非硬编码

**理念3: 单一数据源**
- state.json是唯一的状态真相来源(Single Source of Truth)
- 所有其他模块从state.json读取状态
- 避免状态分散导致的不一致

### 1.2 核心数据文件

| 文件路径 | 用途 | 大小预估 | 更新频率 |
|---------|------|---------|---------|
| `.solodev/state.json` | 当前迭代的状态 | < 100KB | 高频(每次状态变更) |
| `.solodev/state_his.json` | 历史迭代归档 | < 1MB | 低频(迭代完成时) |

---

## 二、核心类型定义

### 2.1 Phase(阶段)相关类型

#### PhaseStatus - 阶段状态枚举

```typescript
/**
 * 阶段状态
 *
 * 状态流转:
 * pending → in_progress → approved → completed
 *                          ↓
 *                       blocked (如果发现问题)
 */
type PhaseStatus =
  | 'pending'      // 待开始
  | 'in_progress'  // 进行中
  | 'approved'     // 已审批(可进入下一阶段)
  | 'blocked'      // 阻塞(发现问题,需回滚)
  | 'completed';   // 已完成
```

**状态说明**:
- `pending`: 阶段尚未开始,等待前置阶段完成
- `in_progress`: 阶段正在执行,模块澄清/设计/实现中
- `approved`: 阶段产物已审批通过,可进入下一阶段
- `blocked`: 阶段被阻塞(如发现需求问题,需要回滚)
- `completed`: 阶段已完成并进入下一阶段

#### PhaseDefinition - 阶段元定义

```typescript
/**
 * 阶段定义 - 描述阶段的元信息和规则
 * 存储位置: config/phase-definitions.ts
 */
interface PhaseDefinition {
  /** 阶段名称 */
  name: string;

  /** 阶段顺序 (1-5) */
  order: number;

  /** 是否需要人类审批 */
  needsApproval: boolean;

  /** 此阶段生成的产物类型 */
  artifactTypes: string[];

  /** 下一个阶段名称 (null表示最后一个阶段) */
  nextPhase: string | null;

  /** 可以回滚到的阶段列表 */
  canRollbackTo: string[];

  /** 此阶段需要执行的验证器列表 */
  validators: string[];

  /** 阶段完成条件 */
  completionCriteria: {
    /** 所有模块必须达到的最低状态 */
    minModuleStatus: ModuleStatus;

    /** 是否需要所有模块都完成 */
    requireAllModules: boolean;

    /** 自定义验证函数名称 */
    customValidator?: string;
  };
}
```

**示例配置**:
```typescript
const requirementsPhase: PhaseDefinition = {
  name: 'requirements',
  order: 1,
  needsApproval: true,
  artifactTypes: ['PRD.md', 'module-PRD.md'],
  nextPhase: 'architecture',
  canRollbackTo: [],
  validators: ['validateAllModulesHavePRD', 'validateNoConflicts'],
  completionCriteria: {
    minModuleStatus: 'approved',
    requireAllModules: true
  }
};

const architecturePhase: PhaseDefinition = {
  name: 'architecture',
  order: 2,
  needsApproval: true,
  artifactTypes: ['architecture/*.md'],
  nextPhase: 'implementation',
  canRollbackTo: ['requirements'],
  validators: ['validateArchitectureConsistency', 'validateIntegrationPoints'],
  completionCriteria: {
    minModuleStatus: 'approved',
    requireAllModules: true
  }
};
```

#### PhaseState - 阶段运行时状态

```typescript
/**
 * 阶段状态 - 记录阶段的运行时状态
 * 存储位置: state.json → iterations[id].phases[phaseName]
 */
interface PhaseState {
  /** 当前状态 */
  status: PhaseStatus;

  /** 开始时间 */
  startedAt?: string;  // ISO8601 timestamp

  /** 审批通过时间 */
  approvedAt?: string;

  /** 审批人 */
  approvedBy?: string;  // 'human' | 'ai-auto'

  /** 完成时间 */
  completedAt?: string;

  /** 此阶段包含的模块状态 */
  modules: Record<string, ModuleState>;

  /** 当前处理进度 */
  currentProcess?: {
    /** 当前正在处理的模块 */
    currentModule: string | null;

    /** 已完成的模块列表 */
    completedModules: string[];

    /** 剩余待处理模块列表 */
    remainingModules: string[];

    /** 下一步建议操作 */
    nextAction: string;
  };
}
```

---

### 2.2 Iteration(迭代)相关类型

#### IterationStatus - 迭代状态枚举

```typescript
/**
 * 迭代状态
 *
 * 状态流转:
 * pending → in_progress → completed
 */
type IterationStatus =
  | 'pending'      // 待开始
  | 'in_progress'  // 进行中
  | 'completed';   // 已完成
```

#### Iteration - 迭代完整定义

```typescript
/**
 * 迭代 - 一个完整的开发周期
 * 存储位置: state.json → iterations[iterationId]
 */
interface Iteration {
  /** 迭代唯一标识 */
  id: string;  // 'iteration-1', 'iteration-2', ...

  /** 版本号 (语义化版本) */
  version: string;  // 'v1.0.0', 'v1.1.0', ...

  /** 迭代目标描述 */
  goal: string;

  /** 迭代状态 */
  status: IterationStatus;

  /** 开始时间 */
  startedAt: string;

  /** 完成时间 */
  completedAt?: string;

  /** 部署时间 */
  deployedAt?: string;

  /** 当前所处阶段 */
  currentPhase: string;  // 'requirements' | 'architecture' | ...

  /** 所有阶段的状态 */
  phases: {
    requirements: PhaseState;
    architecture: PhaseState;
    implementation: PhaseState;
    testing: PhaseState;
    deployment: PhaseState;
  };

  /** 迭代级别的Git信息 */
  git?: {
    /** 迭代开始时的commit */
    startCommit: string;

    /** 迭代完成时的commit */
    endCommit?: string;

    /** Git tag */
    tag?: string;  // 'v1.0.0'
  };
}
```

---

### 2.3 Module(模块)相关类型

#### ModuleStatus - 模块状态枚举

```typescript
/**
 * 模块状态
 *
 * 状态流转:
 * pending → in_progress → approved → completed
 *            ↓
 *    partially_clarified (仅在requirements阶段)
 */
type ModuleStatus =
  | 'pending'               // 待开始
  | 'in_progress'           // 进行中
  | 'partially_clarified'   // 部分完成(仅requirements阶段)
  | 'approved'              // 已审批
  | 'completed';            // 已完成
```

#### ModuleState - 模块运行时状态

```typescript
/**
 * 模块状态 - 记录模块在某个阶段的状态
 * 存储位置: state.json → iterations[id].phases[phase].modules[moduleName]
 */
interface ModuleState {
  /** 当前状态 */
  status: ModuleStatus;

  /** 优先级 */
  priority: 'P0' | 'P1' | 'P2';

  /** 开始时间 */
  startedAt?: string;

  /** 审批通过时间 */
  approvedAt?: string;

  /** 审批人 */
  approvedBy?: string;

  /** 完成时间 */
  completedAt?: string;

  /** 此阶段生成的产物 */
  artifacts: string[];  // 文件路径列表

  /** 审核人 */
  reviewer?: string;

  /** 待解决问题列表 (仅requirements阶段) */
  pendingQuestions?: string[];

  /** 已澄清的方面 (仅requirements阶段) */
  clarifiedAspects?: string[];
}
```

#### ModuleDependency - 模块依赖关系

```typescript
/**
 * 模块依赖关系
 * 存储位置: state.json → moduleDependencies[moduleName]
 */
interface ModuleDependency {
  /** 模块名称 */
  moduleName: string;

  /** 依赖的模块列表 */
  dependsOn: string[];

  /** 被哪些模块依赖 */
  dependedBy: string[];

  /** 是否为基础模块(无依赖) */
  isFoundation: boolean;

  /** 模块描述 */
  description: string;

  /** 集成点详情 (可选,仅复杂集成时填写) */
  integrationPoints?: IntegrationPoint[];
}
```

#### IntegrationPoint - 集成点

```typescript
/**
 * 集成点 - 描述模块间的具体集成关系
 */
interface IntegrationPoint {
  /** 目标模块名称 */
  targetModule: string;

  /** 调用的接口名称 */
  interface: string;

  /** 调用目的 */
  purpose: string;

  /** 数据流向 */
  dataFlow: string;  // 'input -> output' 格式

  /** 错误处理方式 */
  errorHandling: string;

  /** 集成复杂度 */
  complexity: 'simple' | 'complex';

  /** 集成文档路径 (仅complex时需要) */
  integrationDoc?: string;
}
```

---

### 2.4 StateTransition(状态转换)相关类型

#### TransitionRequest - 状态转换请求

```typescript
/**
 * 状态转换请求
 */
interface TransitionRequest {
  /** 转换类型 */
  type: 'phase' | 'module';

  /** 当前状态 */
  from: string;

  /** 目标状态 */
  to: string;

  /** 转换原因 */
  reason?: string;

  /** 转换上下文 */
  context?: {
    iterationId?: string;
    phaseName?: string;
    moduleName?: string;
  };
}
```

#### TransitionResult - 状态转换结果

```typescript
/**
 * 状态转换结果
 */
interface TransitionResult {
  /** 是否成功 */
  success: boolean;

  /** 新状态 */
  newState: string;

  /** 错误信息 */
  errors?: string[];

  /** 警告信息 */
  warnings?: string[];

  /** 受影响的其他实体 */
  affected?: {
    modules?: string[];
    phases?: string[];
  };
}
```

---

### 2.5 Validation(验证)相关类型

#### ValidationResult - 验证结果

```typescript
/**
 * 验证结果
 */
interface ValidationResult {
  /** 是否通过验证 */
  isValid: boolean;

  /** 错误列表 (阻塞性问题) */
  errors: string[];

  /** 警告列表 (非阻塞性问题) */
  warnings: string[];

  /** 详细信息 */
  details?: Record<string, any>;
}
```

---

### 2.6 ImpactAnalysis(影响分析)相关类型

#### ChangeType - 变更类型

```typescript
/**
 * 变更类型
 */
type ChangeType =
  | 'requirements'     // 需求变更
  | 'architecture'     // 架构变更
  | 'implementation'   // 实现变更
  | 'testing'          // 测试发现问题
  | 'hotfix';          // 紧急修复
```

#### ImpactReport - 影响报告

```typescript
/**
 * 影响分析报告
 */
interface ImpactReport {
  /** 变更源模块 */
  sourceModule: string;

  /** 变更类型 */
  changeType: ChangeType;

  /** 受影响的模块列表 */
  affectedModules: string[];

  /** 受影响的阶段列表 */
  impactedPhases: string[];

  /** 预估工作量 (人天) */
  estimatedEffort: number;

  /** 影响传播路径 */
  propagationPath?: Array<{
    module: string;
    reason: string;
    depth: number;  // 依赖深度
  }>;

  /** 建议的回滚目标阶段 */
  suggestedRollbackPhase: string;
}
```

---

## 三、state.json完整Schema

### 3.1 顶层结构

```json
{
  "schema_version": "1.0.0",
  "project": { /* 项目信息 */ },
  "bootstrap": { /* 自举信息(仅当前项目) */ },
  "currentIteration": "string",
  "iterations": { /* 迭代列表 */ },
  "moduleDependencies": { /* 模块依赖关系 */ },
  "globalTasks": { /* 全局任务 */ },
  "changeHistory": [ /* 变更历史 */ ],
  "settings": { /* 设置 */ },
  "metadata": { /* 元数据 */ },
  "templateVersions": { /* 模板版本 */ }
}
```

### 3.2 核心流程模型相关部分

**核心流程模型主要关注以下部分**:

#### iterations.phases结构

```typescript
{
  "iterations": {
    "iteration-1": {
      "phases": {
        "requirements": {
          "status": "approved",
          "startedAt": "2025-12-14T00:00:00Z",
          "approvedAt": "2025-12-14T11:00:00Z",
          "approvedBy": "human",
          "modules": {
            "核心流程模型": {
              "status": "approved",
              "priority": "P0",
              "approvedAt": "2025-12-14T00:00:00Z",
              "artifacts": ["docs/PRD/modules/核心流程模型-PRD.md"],
              "reviewer": "human"
            },
            "状态管理模块": {
              "status": "approved",
              "priority": "P0",
              "approvedAt": "2025-12-14T00:00:00Z",
              "artifacts": ["docs/PRD/modules/状态管理模块-PRD.md"],
              "reviewer": "human"
            }
            // ... 其他模块
          },
          "currentProcess": {
            "currentModule": null,
            "completedModules": ["核心流程模型", "状态管理模块", "..."],
            "remainingModules": [],
            "nextAction": "所有模块需求澄清已完成,建议进入architecture阶段"
          }
        },
        "architecture": {
          "status": "in_progress",
          "startedAt": "2025-12-14T11:00:00Z",
          "modules": {
            "核心流程模型": {
              "status": "in_progress",  // 当前正在设计
              "priority": "P0"
            },
            "状态管理模块": {
              "status": "pending",
              "priority": "P0"
            }
            // ... 其他模块
          },
          "currentProcess": {
            "currentModule": "核心流程模型",
            "completedModules": [],
            "remainingModules": ["核心流程模型", "状态管理模块", "..."],
            "nextAction": "设计核心流程模型架构(无依赖,优先设计)"
          }
        },
        "implementation": {
          "status": "pending",
          "modules": {}
        },
        "testing": {
          "status": "pending",
          "testPhases": {}
        },
        "deployment": {
          "status": "pending"
        }
      }
    }
  }
}
```

#### moduleDependencies结构

```typescript
{
  "moduleDependencies": {
    "核心流程模型": {
      "dependsOn": [],
      "dependedBy": ["状态管理模块", "命令体系模块", "影响分析模块"],
      "isFoundation": true,
      "description": "定义五阶段流转模型和依赖解析算法",
      "integrationPoints": [
        {
          "targetModule": "状态管理模块",
          "interface": "getPhaseDefinition(phaseName: string): PhaseDefinition",
          "purpose": "状态管理模块需要获取阶段定义以执行状态流转",
          "dataFlow": "phaseName -> PhaseDefinition",
          "errorHandling": "throw PhaseNotFoundError",
          "complexity": "simple"
        },
        {
          "targetModule": "影响分析模块",
          "interface": "analyzeImpact(module, changeType, deps): ImpactReport",
          "purpose": "影响分析模块调用核心流程模型的影响分析算法",
          "dataFlow": "module + changeType + deps -> ImpactReport",
          "errorHandling": "throw InvalidInputError",
          "complexity": "simple"
        }
      ]
    },
    "状态管理模块": {
      "dependsOn": ["核心流程模型"],
      "dependedBy": ["命令体系模块", "影响分析模块"],
      "isFoundation": false,
      "description": "读取/更新state.json,执行状态流转",
      "integrationPoints": []
    }
  }
}
```

---

## 四、状态流转规则

### 4.1 Phase状态流转

#### 状态机图

```
                   ┌──────────┐
                   │ pending  │
                   └────┬─────┘
                        │ /start-phase
                        ↓
              ┌──────────────────┐
              │   in_progress    │
              └────┬────────┬────┘
                   │        │
    /approve       │        │ /block
                   ↓        ↓
           ┌──────────┐  ┌─────────┐
           │ approved │  │ blocked │
           └────┬─────┘  └────┬────┘
                │             │ /rollback
/start-next-   │             │
   phase       ↓             ↓
           ┌──────────┐  ┌──────────┐
           │completed │  │(回滚到其他阶段)│
           └──────────┘  └──────────┘
```

#### 流转规则表

| 当前状态 | 允许转换 | 触发条件 | 执行操作 |
|---------|---------|---------|---------|
| `pending` | `in_progress` | 用户执行/start-phase | 设置startedAt,初始化modules |
| `in_progress` | `approved` | 所有模块approved + 通过验证 | 设置approvedAt, approvedBy |
| `in_progress` | `blocked` | 发现需求/架构问题 | 标记问题,等待人工确认回滚 |
| `approved` | `completed` | 用户执行/start-next-phase | 设置completedAt,转到下一阶段 |
| `blocked` | `in_progress` | 问题解决 | 清除blocked标记 |

### 4.2 Module状态流转

#### 状态机图

```
         ┌──────────┐
         │ pending  │
         └────┬─────┘
              │ /start-clarify (requirements)
              │ /start-design (architecture)
              │ /start-implement (implementation)
              ↓
    ┌───────────────────┐
    │   in_progress     │
    └────┬──────────┬───┘
         │          │
         │          │ (仅requirements阶段)
         │          ↓
         │   ┌──────────────────────┐
         │   │ partially_clarified  │
         │   └──────────┬───────────┘
         │              │
/approve │              │ /approve
         ↓              ↓
    ┌──────────┐   ┌──────────┐
    │ approved │   │ approved │
    └────┬─────┘   └────┬─────┘
         │               │
         └───────┬───────┘
                 │ (进入下一阶段)
                 ↓
          ┌──────────┐
          │completed │
          └──────────┘
```

### 4.3 Iteration状态流转

#### 状态机图

```
    ┌──────────┐
    │ pending  │
    └────┬─────┘
         │ /start-iteration
         ↓
┌───────────────────┐
│   in_progress     │
└────┬──────────────┘
     │ 所有阶段完成
     │ + 部署成功
     ↓
┌──────────┐
│completed │
└──────────┘
```

---

## 五、数据完整性约束

### 5.1 引用完整性约束

#### 约束1: currentIteration必须存在

```typescript
/**
 * 约束: state.currentIteration 必须存在于 state.iterations 中
 */
function validateCurrentIterationExists(state: State): ValidationResult {
  const exists = state.iterations[state.currentIteration] !== undefined;

  return {
    isValid: exists,
    errors: exists ? [] : [
      `currentIteration "${state.currentIteration}" not found in iterations`
    ],
    warnings: []
  };
}
```

#### 约束2: currentPhase必须存在

```typescript
/**
 * 约束: currentPhase 必须存在于当前迭代的 phases 中
 */
function validateCurrentPhaseExists(state: State): ValidationResult {
  const iteration = state.iterations[state.currentIteration];
  if (!iteration) {
    return { isValid: false, errors: ['Invalid iteration'], warnings: [] };
  }

  const exists = iteration.phases[iteration.currentPhase] !== undefined;

  return {
    isValid: exists,
    errors: exists ? [] : [
      `currentPhase "${iteration.currentPhase}" not found in phases`
    ],
    warnings: []
  };
}
```

#### 约束3: 模块名称一致性

```typescript
/**
 * 约束: phases.modules中的模块名必须存在于moduleDependencies中
 */
function validateModuleNameConsistency(state: State): ValidationResult {
  const errors: string[] = [];
  const iteration = state.iterations[state.currentIteration];

  for (const [phaseName, phaseState] of Object.entries(iteration.phases)) {
    for (const moduleName of Object.keys(phaseState.modules)) {
      if (!state.moduleDependencies[moduleName]) {
        errors.push(
          `Module "${moduleName}" in phase "${phaseName}" not found in moduleDependencies`
        );
      }
    }
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings: []
  };
}
```

### 5.2 状态一致性约束

#### 约束4: 已完成阶段不应有pending模块

```typescript
/**
 * 约束: 状态为completed的阶段不应该有pending状态的模块
 */
function validateCompletedPhaseModules(state: State): ValidationResult {
  const warnings: string[] = [];
  const iteration = state.iterations[state.currentIteration];

  for (const [phaseName, phaseState] of Object.entries(iteration.phases)) {
    if (phaseState.status === 'completed') {
      const pendingModules = Object.entries(phaseState.modules)
        .filter(([_, module]) => module.status === 'pending')
        .map(([name]) => name);

      if (pendingModules.length > 0) {
        warnings.push(
          `Phase "${phaseName}" is completed but has pending modules: ${pendingModules.join(', ')}`
        );
      }
    }
  }

  return {
    isValid: true,  // warning不影响validity
    errors: [],
    warnings
  };
}
```

#### 约束5: 阶段顺序一致性

```typescript
/**
 * 约束: currentPhase必须是正在进行或已完成的阶段
 */
function validatePhaseOrder(state: State): ValidationResult {
  const iteration = state.iterations[state.currentIteration];
  const currentPhaseState = iteration.phases[iteration.currentPhase];

  if (!currentPhaseState) {
    return {
      isValid: false,
      errors: [`Current phase "${iteration.currentPhase}" state not found`],
      warnings: []
    };
  }

  const validStatuses: PhaseStatus[] = ['in_progress', 'approved', 'blocked'];
  const isValid = validStatuses.includes(currentPhaseState.status);

  return {
    isValid,
    errors: isValid ? [] : [
      `Current phase "${iteration.currentPhase}" has invalid status: ${currentPhaseState.status}. ` +
      `Expected one of: ${validStatuses.join(', ')}`
    ],
    warnings: []
  };
}
```

### 5.3 依赖关系约束

#### 约束6: 依赖关系必须是DAG

```typescript
/**
 * 约束: moduleDependencies必须是有向无环图(DAG)
 */
function validateDependenciesAreDAG(dependencies: ModuleDependencies): ValidationResult {
  try {
    // 尝试拓扑排序,如果有环会抛出异常
    topologicalSort(dependencies);

    return {
      isValid: true,
      errors: [],
      warnings: []
    };
  } catch (error) {
    return {
      isValid: false,
      errors: [`Circular dependency detected: ${error.message}`],
      warnings: []
    };
  }
}
```

#### 约束7: 依赖关系双向一致

```typescript
/**
 * 约束: 如果A依赖B,则B的dependedBy必须包含A
 */
function validateDependencyBidirectional(dependencies: ModuleDependencies): ValidationResult {
  const errors: string[] = [];

  for (const [moduleName, dep] of Object.entries(dependencies)) {
    // 检查dependsOn的双向一致性
    for (const depModule of dep.dependsOn) {
      const targetDep = dependencies[depModule];
      if (!targetDep) {
        errors.push(`Module "${moduleName}" depends on non-existent module "${depModule}"`);
        continue;
      }

      if (!targetDep.dependedBy.includes(moduleName)) {
        errors.push(
          `Inconsistent dependency: ${moduleName} depends on ${depModule}, ` +
          `but ${depModule}.dependedBy does not include ${moduleName}`
        );
      }
    }

    // 检查dependedBy的双向一致性
    for (const dependentModule of dep.dependedBy) {
      const dependentDep = dependencies[dependentModule];
      if (!dependentDep) {
        errors.push(`Module "${moduleName}" is depended by non-existent module "${dependentModule}"`);
        continue;
      }

      if (!dependentDep.dependsOn.includes(moduleName)) {
        errors.push(
          `Inconsistent dependency: ${dependentModule}.dependsOn does not include ${moduleName}, ` +
          `but ${moduleName}.dependedBy includes ${dependentModule}`
        );
      }
    }
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings: []
  };
}
```

---

## 六、核心实体状态机详解

### 6.1 Phase状态机

**完整状态转换表**:

| 当前状态 | 事件 | 前置条件 | 后置状态 | 副作用 |
|---------|------|---------|---------|--------|
| pending | START_PHASE | 前一阶段completed | in_progress | 设置startedAt,初始化modules |
| in_progress | APPROVE_PHASE | 所有模块approved | approved | 设置approvedAt, approvedBy |
| in_progress | BLOCK_PHASE | 发现问题 | blocked | 记录问题到changeHistory |
| approved | START_NEXT_PHASE | - | completed | 设置completedAt,currentPhase切换 |
| blocked | RESOLVE_ISSUE | 问题解决 | in_progress | 清除blocked标记 |

**不允许的状态转换**:
- ❌ `pending` → `approved` (跳过in_progress)
- ❌ `completed` → `in_progress` (不允许重新激活,只能回滚)
- ❌ `approved` → `blocked` (已审批不能直接阻塞)

### 6.2 Module状态机

**完整状态转换表**:

| 当前状态 | 事件 | 前置条件 | 后置状态 | 副作用 |
|---------|------|---------|---------|--------|
| pending | START_MODULE | 依赖模块已完成当前阶段 | in_progress | 设置startedAt |
| in_progress | PARTIAL_COMPLETE | 部分澄清完成(仅requirements) | partially_clarified | 记录clarifiedAspects |
| in_progress | APPROVE_MODULE | 工作完成+通过验证 | approved | 设置approvedAt,记录artifacts |
| partially_clarified | APPROVE_MODULE | 剩余部分完成 | approved | 设置approvedAt |
| approved | ENTER_NEXT_PHASE | 阶段切换 | completed | 标记completed,保留artifacts |

### 6.3 Iteration状态机

**完整状态转换表**:

| 当前状态 | 事件 | 前置条件 | 后置状态 | 副作用 |
|---------|------|---------|---------|--------|
| pending | START_ITERATION | - | in_progress | 设置startedAt, currentPhase='requirements' |
| in_progress | COMPLETE_ITERATION | deployment阶段完成+部署成功 | completed | 设置completedAt, deployedAt,创建Git tag |

---

## 七、数据操作接口设计

### 7.1 只读接口(Getters)

```typescript
interface PhaseDataReader {
  /** 获取阶段定义 */
  getPhaseDefinition(phaseName: string): PhaseDefinition;

  /** 获取所有阶段定义 */
  getAllPhaseDefinitions(): Record<string, PhaseDefinition>;

  /** 获取阶段状态 */
  getPhaseState(iterationId: string, phaseName: string): PhaseState;

  /** 获取当前阶段 */
  getCurrentPhase(iterationId: string): PhaseState;
}

interface ModuleDataReader {
  /** 获取模块状态 */
  getModuleState(
    iterationId: string,
    phaseName: string,
    moduleName: string
  ): ModuleState;

  /** 获取模块依赖关系 */
  getModuleDependency(moduleName: string): ModuleDependency;

  /** 获取所有模块依赖关系 */
  getAllModuleDependencies(): Record<string, ModuleDependency>;
}

interface IterationDataReader {
  /** 获取迭代 */
  getIteration(iterationId: string): Iteration;

  /** 获取当前迭代 */
  getCurrentIteration(): Iteration;
}
```

### 7.2 写入接口(Setters)

**注意**: 核心流程模型本身不实现写入接口,写入由状态管理模块负责

```typescript
// 这些接口由状态管理模块实现,核心流程模型只定义类型
interface PhaseDataWriter {
  /** 更新阶段状态 */
  updatePhaseStatus(
    iterationId: string,
    phaseName: string,
    status: PhaseStatus
  ): void;

  /** 开始阶段 */
  startPhase(iterationId: string, phaseName: string): void;

  /** 审批阶段 */
  approvePhase(
    iterationId: string,
    phaseName: string,
    approvedBy: string
  ): void;
}

interface ModuleDataWriter {
  /** 更新模块状态 */
  updateModuleStatus(
    iterationId: string,
    phaseName: string,
    moduleName: string,
    status: ModuleStatus
  ): void;

  /** 添加产物 */
  addArtifact(
    iterationId: string,
    phaseName: string,
    moduleName: string,
    artifactPath: string
  ): void;
}
```

### 7.3 验证接口

```typescript
interface DataValidator {
  /** 验证state.json完整性 */
  validateStateIntegrity(state: State): ValidationResult;

  /** 验证依赖关系 */
  validateDependencies(dependencies: ModuleDependencies): ValidationResult;

  /** 验证阶段流转 */
  validatePhaseTransition(
    currentPhase: string,
    targetPhase: string
  ): ValidationResult;

  /** 验证模块状态流转 */
  validateModuleTransition(
    currentStatus: ModuleStatus,
    targetStatus: ModuleStatus
  ): ValidationResult;
}
```

---

## 八、数据迁移与演进

### 8.1 Schema版本管理

**当前版本**: `1.0.0`

**版本历史**:
| 版本 | 日期 | 变更说明 |
|------|------|---------|
| 1.0.0 | 2025-12-14 | 初始版本,定义五阶段模型 |

### 8.2 未来版本规划

**v1.1.0 (预计)**:
- 新增: `phases[].metrics` - 记录阶段级别的指标(耗时、返工次数)
- 新增: `modules[].estimatedEffort` - 记录模块估算工作量

**v2.0.0 (预计)**:
- 变更: 支持自定义阶段(phaseDefinitions作为配置而非硬编码)
- 变更: 支持子阶段(sub-phases)

### 8.3 迁移策略

**向后兼容原则**:
- 新增字段使用可选类型(optional)
- 不删除已有字段,使用deprecated标记
- 提供迁移脚本

**迁移脚本示例(v1.0 → v1.1)**:
```typescript
function migrateState_1_0_to_1_1(state: State_v1_0): State_v1_1 {
  const newState = { ...state };

  // 为每个阶段添加metrics字段
  for (const iteration of Object.values(newState.iterations)) {
    for (const [phaseName, phaseState] of Object.entries(iteration.phases)) {
      phaseState.metrics = {
        duration: calculateDuration(phaseState),
        reworkCount: 0
      };
    }
  }

  return newState;
}
```

---

## 九、性能优化考虑

### 9.1 数据访问优化

**缓存策略**:
```typescript
// 阶段定义为静态配置,启动时加载一次,全局复用
const phaseDefinitionsCache = new Map<string, PhaseDefinition>();

function getPhaseDefinition(phaseName: string): PhaseDefinition {
  if (!phaseDefinitionsCache.has(phaseName)) {
    phaseDefinitionsCache.set(phaseName, loadPhaseDefinition(phaseName));
  }
  return phaseDefinitionsCache.get(phaseName)!;
}
```

**拓扑排序结果缓存**:
```typescript
// 依赖关系未变时复用拓扑排序结果
const sortCache = new WeakMap<ModuleDependencies, string[]>();

function topologicalSort(dependencies: ModuleDependencies): string[] {
  if (sortCache.has(dependencies)) {
    return sortCache.get(dependencies)!;
  }

  const result = doTopologicalSort(dependencies);
  sortCache.set(dependencies, result);
  return result;
}
```

### 9.2 文件大小控制

**state.json大小预估**:
- 单模块数据: ~500 bytes
- 10个模块,5个阶段: ~25KB
- 50个模块,5个阶段: ~125KB
- **目标**: < 100KB

**超限处理策略**:
- 达到80KB时,警告用户考虑拆分迭代
- 达到150KB时,强制迁移历史迭代到state_his.json

---

## 十、总结

### 核心设计要点

1. **状态机驱动**: 所有实体都是状态机,状态流转有明确规则
2. **数据完整性**: 7类约束保证state.json始终一致
3. **纯类型定义**: 核心流程模型只定义类型,不实现状态读写
4. **可演进设计**: Schema版本管理 + 迁移策略支持未来扩展

### 关键数据结构

- **Phase**: 5个阶段,4个状态,需人工审批
- **Module**: 按依赖顺序执行,支持并行调度
- **Iteration**: 对应版本号,完成后部署+打tag

### 数据操作原则

- **读**: 核心流程模型提供类型定义和验证接口
- **写**: 由状态管理模块负责,核心流程模型不涉及
- **验证**: 7类约束 + 3类验证器保证一致性

---

## 十一、补充设计(评审后新增)

> 本节基于架构评审反馈,补充以下5个问题的设计

### 11.1 Testing阶段子阶段设计

#### 问题背景

PRD要求Testing阶段有3个子阶段(E2E、性能、混沌),各有独立审批点。

#### TestingPhaseState扩展

```typescript
/**
 * Testing阶段专用状态
 * 继承自PhaseState,增加testPhases结构
 */
interface TestingPhaseState extends PhaseState {
  /** Testing子阶段状态 */
  testPhases: {
    e2e: TestSubPhaseState;
    performance: TestSubPhaseState;
    chaos: TestSubPhaseState;
  };
}

/**
 * Testing子阶段状态
 */
interface TestSubPhaseState {
  /** 子阶段状态 */
  status: TestSubPhaseStatus;

  /** 测试计划审批时间 */
  planApprovedAt?: string;

  /** 测试计划审批人 */
  planApprovedBy?: string;

  /** 测试执行开始时间 */
  executedAt?: string;

  /** 测试通过时间 */
  passedAt?: string;

  /** 测试失败时间(如果失败) */
  failedAt?: string;

  /** 失败原因(如果失败) */
  failureReason?: string;

  /** 产物路径 */
  artifacts: {
    plan: string;    // 测试计划文档路径
    code?: string;   // 测试代码路径
    report?: string; // 测试报告路径
  };
}

/**
 * Testing子阶段状态枚举
 */
type TestSubPhaseStatus =
  | 'pending'           // 待开始
  | 'plan_in_progress'  // 计划编写中
  | 'plan_approved'     // 计划已审批
  | 'executing'         // 测试执行中
  | 'passed'            // 测试通过
  | 'failed';           // 测试失败
```

#### Testing子阶段状态机

```
┌──────────┐
│ pending  │
└────┬─────┘
     │ AI生成测试计划
     ↓
┌──────────────────┐
│ plan_in_progress │
└────┬─────────────┘
     │ 人工审批通过
     ↓
┌───────────────┐
│ plan_approved │
└────┬──────────┘
     │ AI生成测试代码并执行
     ↓
┌───────────┐
│ executing │
└────┬──────┴────┐
     │           │
     ↓           ↓
┌────────┐  ┌────────┐
│ passed │  │ failed │
└────────┘  └───┬────┘
                │ 分层分析 + 回滚
                ↓
           (触发反馈循环)
```

#### state.json中的结构示例

```json
{
  "phases": {
    "testing": {
      "status": "in_progress",
      "startedAt": "2025-12-14T15:00:00Z",
      "testPhases": {
        "e2e": {
          "status": "passed",
          "planApprovedAt": "2025-12-14T15:30:00Z",
          "planApprovedBy": "human",
          "executedAt": "2025-12-14T16:00:00Z",
          "passedAt": "2025-12-14T16:30:00Z",
          "artifacts": {
            "plan": "docs/testing/iteration-1/E2E测试计划.md",
            "code": "tests/e2e/",
            "report": "docs/testing/iteration-1/E2E测试报告.md"
          }
        },
        "performance": {
          "status": "plan_approved",
          "planApprovedAt": "2025-12-14T17:00:00Z",
          "planApprovedBy": "human",
          "artifacts": {
            "plan": "docs/testing/iteration-1/性能测试方案.md"
          }
        },
        "chaos": {
          "status": "pending",
          "artifacts": {
            "plan": ""
          }
        }
      },
      "modules": {}
    }
  }
}
```

---

### 11.2 回滚状态设计

#### 问题背景

模块回滚后的状态处理不明确:artifacts是否保留?status变为什么?依赖模块如何处理?

#### 设计决策

| 问题 | 决策 | 理由 |
|------|------|------|
| artifacts是否保留 | **保留** | 历史记录有参考价值,Git历史也可追溯 |
| status变为什么 | **新增`rolled_back`状态** | 区别于`pending`(从未开始) |
| 依赖模块如何处理 | **联动回滚** | 由影响分析计算范围,状态管理执行 |

#### 扩展ModuleStatus

```typescript
/**
 * 模块状态 - 扩展回滚状态
 */
type ModuleStatus =
  | 'pending'               // 待开始(从未开始)
  | 'in_progress'           // 进行中
  | 'partially_clarified'   // 部分完成(仅requirements阶段)
  | 'approved'              // 已审批
  | 'completed'             // 已完成
  | 'rolled_back';          // 已回滚(曾经完成但被回滚)
```

#### RollbackRule定义

```typescript
/**
 * 回滚规则
 */
interface RollbackRule {
  /** 回滚时保留的字段 */
  preserveFields: [
    'artifacts',           // 保留产物记录(历史参考)
    'previousApprovedAt',  // 保留之前的审批时间(新增字段)
    'rollbackHistory'      // 保留回滚历史(新增字段)
  ];

  /** 回滚时清除的字段 */
  clearFields: [
    'approvedAt',          // 清除当前审批时间
    'approvedBy',          // 清除审批人
    'completedAt'          // 清除完成时间
  ];

  /** 依赖模块联动规则 */
  cascadeRule: CascadeRollbackRule;
}

/**
 * 联动回滚规则
 */
type CascadeRollbackRule =
  | 'rollback_dependents_to_same_phase'      // 依赖模块回滚到相同阶段
  | 'rollback_dependents_to_earlier_phase'   // 依赖模块回滚到更早阶段
  | 'block_dependents';                       // 阻塞依赖模块,不自动回滚
```

#### 回滚后的ModuleState示例

```typescript
// 回滚前
{
  "status": "approved",
  "approvedAt": "2025-12-14T10:00:00Z",
  "approvedBy": "human",
  "artifacts": ["docs/architecture/模块A-架构.md"]
}

// 回滚后
{
  "status": "rolled_back",
  "approvedAt": null,           // 清除
  "approvedBy": null,           // 清除
  "artifacts": ["docs/architecture/模块A-架构.md"],  // 保留
  "previousApprovedAt": "2025-12-14T10:00:00Z",      // 新增:记录之前的审批时间
  "rollbackHistory": [                               // 新增:回滚历史
    {
      "rolledBackAt": "2025-12-14T14:00:00Z",
      "reason": "测试发现需求问题",
      "fromPhase": "architecture",
      "toPhase": "requirements"
    }
  ]
}
```

#### 回滚状态流转

```
┌──────────┐     ┌─────────────┐     ┌──────────┐
│ approved │ ──→ │ rolled_back │ ──→ │in_progress│
└──────────┘     └─────────────┘     └──────────┘
     ↑                                     │
     └─────────────────────────────────────┘
                   (重新完成后)
```

---

### 11.3 分层分析框架定义

#### 问题背景

PRD要求AI能执行分层分析(测试用例问题 vs 代码问题 vs 设计问题 vs 需求问题)。

#### 设计决策

- **核心流程模型**: 提供分层分析框架(定义分析层次和回滚映射)
- **影响分析模块**: 实现具体的分析逻辑(调用AI推理能力)

#### RootCauseAnalysisFramework定义

```typescript
/**
 * 分层分析框架 - 由核心流程模型提供
 */
interface RootCauseAnalysisFramework {
  /** 分析层次定义 */
  layers: AnalysisLayer[];

  /** 根因到回滚阶段的映射 */
  rollbackMapping: Record<RootCauseType, string>;

  /** 分析提示模板 */
  analysisPrompts: Record<number, string>;
}

/**
 * 分析层次
 */
interface AnalysisLayer {
  /** 层级(1-3) */
  level: number;

  /** 层级名称 */
  name: string;

  /** 分析问题 */
  question: string;

  /** 可能的结论 */
  possibleConclusions: string[];
}

/**
 * 根因类型
 */
type RootCauseType =
  | 'test_case_issue'      // 测试用例问题
  | 'code_bug'             // 代码Bug
  | 'design_issue'         // 设计问题
  | 'requirements_issue';  // 需求问题
```

#### 分层分析框架配置

```typescript
const rootCauseAnalysisFramework: RootCauseAnalysisFramework = {
  layers: [
    {
      level: 1,
      name: '测试层分析',
      question: '测试失败是测试用例问题还是代码问题?',
      possibleConclusions: ['测试用例问题', '代码问题']
    },
    {
      level: 2,
      name: '代码层分析',
      question: '代码问题是Bug还是设计问题?',
      possibleConclusions: ['代码Bug', '设计问题']
    },
    {
      level: 3,
      name: '设计层分析',
      question: '设计问题是架构问题还是需求问题?',
      possibleConclusions: ['架构问题', '需求问题']
    }
  ],

  rollbackMapping: {
    'test_case_issue': 'testing',
    'code_bug': 'implementation',
    'design_issue': 'architecture',
    'requirements_issue': 'requirements'
  },

  analysisPrompts: {
    1: '请分析测试失败原因:\n1. 测试用例是否正确?\n2. 测试数据是否合理?\n3. 代码逻辑是否有问题?',
    2: '请分析代码问题:\n1. 是否是简单的Bug(逻辑错误、边界条件)?'\n2. 还是设计层面的问题(接口设计、数据结构)?',
    3: '请分析设计问题:\n1. 是架构设计问题(模块划分、依赖关系)?\n2. 还是需求定义问题(需求不清晰、需求遗漏)?'
  }
};
```

#### 分层分析结果

```typescript
/**
 * 分层分析结果 - 由影响分析模块生成
 */
interface RootCauseAnalysisResult {
  /** 分析的测试失败 */
  testFailure: {
    testName: string;
    errorMessage: string;
  };

  /** 每层的分析结论 */
  layerConclusions: Array<{
    level: number;
    question: string;
    conclusion: string;
    evidence: string;
  }>;

  /** 最终根因 */
  rootCause: RootCauseType;

  /** 建议回滚阶段 */
  suggestedRollbackPhase: string;

  /** 受影响模块 */
  affectedModules: string[];

  /** 生成的待办任务 */
  generatedTasks: Task[];
}
```

---

### 11.4 职责归属说明

#### changeHistory维护职责

**决策**: **状态管理模块负责维护changeHistory**

**职责分配**:

| 操作 | 执行模块 | changeHistory记录 |
|------|---------|------------------|
| 阶段状态更新 | 状态管理模块 | 自动记录 |
| 模块状态更新 | 状态管理模块 | 自动记录 |
| 回滚操作 | 状态管理模块 | 自动记录(type: 'rollback') |
| 迭代完成 | 状态管理模块 | 自动记录(type: 'iteration_completed') |

**实现方式**:

```typescript
// 状态管理模块内部实现
class StateManager {
  private appendChangeHistory(change: Change): void {
    this.state.changeHistory.push({
      ...change,
      timestamp: new Date().toISOString()
    });
  }

  // 所有写入操作内部调用appendChangeHistory
  updateModuleStatus(moduleName: string, newStatus: ModuleStatus): void {
    const oldStatus = this.getModuleStatus(moduleName);

    // 更新状态
    this.state.phases[...].modules[moduleName].status = newStatus;

    // 自动记录changeHistory
    this.appendChangeHistory({
      type: 'module_status_change',
      description: `模块${moduleName}状态从${oldStatus}变更为${newStatus}`,
      changedBy: 'ai',
      changes: [
        { field: `modules.${moduleName}.status`, from: oldStatus, to: newStatus }
      ]
    });
  }
}
```

---

### 11.5 影响阶段确定和工作量预估算法

#### determineImpactedPhases算法

```typescript
/**
 * 确定影响的阶段
 * @param changeType - 变更类型
 * @returns 受影响的阶段列表(从变更点到后续所有阶段)
 */
function determineImpactedPhases(changeType: ChangeType): string[] {
  const impactMap: Record<ChangeType, string[]> = {
    // 需求变更: 影响所有后续阶段
    'requirements': ['requirements', 'architecture', 'implementation', 'testing'],

    // 架构变更: 影响实现和测试
    'architecture': ['architecture', 'implementation', 'testing'],

    // 实现变更: 影响测试
    'implementation': ['implementation', 'testing'],

    // 测试发现问题: 只影响测试阶段(除非分析后发现是其他阶段问题)
    'testing': ['testing'],

    // 紧急修复: 影响实现、测试、部署
    'hotfix': ['implementation', 'testing', 'deployment']
  };

  return impactMap[changeType] || [];
}
```

#### calculateEffort算法

```typescript
/**
 * 预估工作量
 * @param affectedModuleCount - 受影响的模块数量
 * @param changeType - 变更类型
 * @returns 预估工作量(人天)
 */
function calculateEffort(
  affectedModuleCount: number,
  changeType: ChangeType
): number {
  // 基础工作量系数 (人天/模块)
  const baseEffortMap: Record<ChangeType, number> = {
    'requirements': 0.5,      // 需求澄清相对快
    'architecture': 1.0,      // 架构设计中等
    'implementation': 2.0,    // 代码实现最耗时
    'testing': 1.0,           // 测试修复中等
    'hotfix': 0.5             // 紧急修复通常范围小
  };

  // 影响阶段数量系数(每多影响一个阶段,增加30%工作量)
  const impactedPhases = determineImpactedPhases(changeType);
  const phaseMultiplier = 1 + (impactedPhases.length - 1) * 0.3;

  // 模块数量边际递减系数(模块越多,单模块工作量略有下降)
  const scaleMultiplier = affectedModuleCount <= 3
    ? 1.0
    : 1.0 - Math.min(0.2, (affectedModuleCount - 3) * 0.05);

  // 总工作量 = 模块数 × 基础系数 × 阶段系数 × 规模系数
  const effort = affectedModuleCount
    * baseEffortMap[changeType]
    * phaseMultiplier
    * scaleMultiplier;

  // 四舍五入到0.5人天
  return Math.round(effort * 2) / 2;
}
```

#### 示例计算

```typescript
// 示例1: 1个模块的需求变更
calculateEffort(1, 'requirements')
// = 1 × 0.5 × (1 + 3×0.3) × 1.0
// = 1 × 0.5 × 1.9 × 1.0
// = 0.95 → 1.0人天

// 示例2: 3个模块的架构变更
calculateEffort(3, 'architecture')
// = 3 × 1.0 × (1 + 2×0.3) × 1.0
// = 3 × 1.0 × 1.6 × 1.0
// = 4.8 → 5.0人天

// 示例3: 5个模块的实现变更
calculateEffort(5, 'implementation')
// = 5 × 2.0 × (1 + 1×0.3) × 0.9
// = 5 × 2.0 × 1.3 × 0.9
// = 11.7 → 11.5人天
```

---

## 十二、评审问题解决总结

| 问题编号 | 问题描述 | 解决方案 | 所在章节 |
|---------|---------|---------|---------|
| 问题1 | 分层分析算法缺失 | 定义RootCauseAnalysisFramework,具体分析由影响分析模块实现 | 11.3 |
| 问题2 | Testing子阶段未体现 | 定义TestingPhaseState和TestSubPhaseState | 11.1 |
| 问题3 | 回滚状态处理不明确 | 新增rolled_back状态,定义RollbackRule | 11.2 |
| 问题4 | changeHistory职责归属 | 明确由状态管理模块负责维护 | 11.4 |
| 问题5 | 算法实现缺失 | 补充determineImpactedPhases和calculateEffort | 11.5 |

---

**下一步**: 完成集成点设计文档补充
