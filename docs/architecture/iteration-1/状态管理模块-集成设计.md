# 状态管理模块 - 集成设计

<!--
章节ID规范说明：
- 格式：{#arch-集成-状态管理-[章节标识]}
- 必须标注ID的章节：调用序列、接口定义、集成点
- 示例：{#arch-集成-状态管理-公开接口} 表示状态管理模块集成设计的公开接口章节
-->

> **项目**: AI超级个体开发助手
> **版本**: v1.0.0
> **迭代**: Iteration 1
> **模块**: 状态管理模块
> **日期**: 2025-12-14
> **集成复杂度**: simple

---

## 一、集成概述

### 1.1 依赖关系

状态管理模块是系统的**数据中枢**，依赖核心流程模型，并被其他所有模块依赖：

```
                    ┌───────────────────────┐
                    │  【核心流程模型】      │
                    │  · 阶段定义           │
                    │  · 验证规则           │
                    │  · 算法接口           │
                    └───────────┬───────────┘
                                ↓ 依赖
┌───────────────────────────────────────────────────────┐
│               【状态管理模块】                          │
│  · 状态读写 · 迁移 · 历史访问 · 变更记录              │
└───────────────────────────────────────────────────────┘
                                ↑ 被依赖
    ┌───────────────┬───────────┼───────────┬───────────┐
    │               │           │           │           │
┌───┴────┐   ┌─────┴─────┐  ┌──┴────┐  ┌───┴────┐  ┌───┴────┐
│命令体系│   │影响分析   │  │文档模板│  │测试验证│  │Git集成 │
│模块    │   │模块       │  │模块    │  │模块    │  │模块    │
└────────┘   └───────────┘  └────────┘  └────────┘  └────────┘
```

### 1.2 集成目标

**作为依赖方（依赖核心流程模型）**：
- 获取阶段定义、验证规则
- 调用验证接口确保状态一致性
- 获取分层分析框架（回滚场景）

**作为被依赖方（被其他模块依赖）**：
- 提供统一的状态读写接口
- 提供进度摘要和下一步建议
- 提供历史数据访问能力

### 1.3 集成复杂度说明

**为何标记为"simple"**：
- ✅ 接口清晰，参数简单
- ✅ 无复杂数据转换
- ✅ 单向依赖，无循环
- ✅ 同步调用，无异步复杂性

---

## 二、上游集成：核心流程模型 → 状态管理模块

### 2.1 集成点列表

| 接口 | 用途 | 调用时机 |
|------|------|---------|
| `getPhaseDefinition()` | 获取阶段定义 | 阶段操作前 |
| `validatePhaseTransition()` | 验证阶段流转 | 阶段流转时 |
| `validateModuleTransition()` | 验证模块状态流转 | 模块状态更新时 |
| `validateStateIntegrity()` | 验证状态完整性 | 每次写入前 |
| `validateDependencies()` | 验证依赖关系 | 依赖变更时 |
| `getRootCauseAnalysisFramework()` | 获取分层分析框架 | 回滚时 |

### 2.2 详细集成设计

#### 接口1：getPhaseDefinition

**调用场景**：获取阶段元信息

```typescript
// 状态管理模块中的使用
class StateService {
  async approvePhase(phaseName: string, approvedBy: string): Promise<ApproveResult> {
    // 获取阶段定义
    const definition = this.coreProcess.getPhaseDefinition(phaseName);

    // 检查是否需要审批
    if (!definition.needsApproval) {
      return {
        success: false,
        errors: [`Phase "${phaseName}" does not require approval`]
      };
    }

    // 检查完成条件
    const state = await this.getState();
    const phaseState = state.iterations[state.currentIteration].phases[phaseName];

    const allModulesApproved = Object.values(phaseState.modules)
      .every(m => m.status === definition.completionCriteria.minModuleStatus);

    if (!allModulesApproved) {
      return {
        success: false,
        errors: ['Not all modules meet completion criteria']
      };
    }

    // 执行审批
    phaseState.status = 'approved';
    phaseState.approvedAt = new Date().toISOString();
    phaseState.approvedBy = approvedBy;

    // 记录变更
    this.changeRecorder.record(state, {
      type: 'approval',
      description: `阶段${phaseName}审批通过`,
      changes: [
        { field: `phases.${phaseName}.status`, from: 'in_progress', to: 'approved' }
      ]
    });

    await this.repository.write(state);

    return { success: true, approvedAt: phaseState.approvedAt };
  }
}
```

---

#### 接口2：validatePhaseTransition

**调用场景**：阶段流转验证

```typescript
// 状态管理模块中的使用
class StateService {
  async transitionPhase(targetPhase: string): Promise<TransitionResult> {
    const state = await this.getState();
    const currentPhase = state.iterations[state.currentIteration].currentPhase;

    // 验证流转合法性
    const validation = this.coreProcess.validatePhaseTransition(
      currentPhase,
      targetPhase
    );

    if (!validation.isValid) {
      return {
        success: false,
        errors: validation.errors
      };
    }

    // 如果有警告（如回滚），记录
    if (validation.warnings.length > 0) {
      console.warn('Phase transition warnings:', validation.warnings);
    }

    // 执行流转
    const iteration = state.iterations[state.currentIteration];
    iteration.phases[currentPhase].status = 'completed';
    iteration.phases[currentPhase].completedAt = new Date().toISOString();
    iteration.phases[targetPhase].status = 'in_progress';
    iteration.phases[targetPhase].startedAt = new Date().toISOString();
    iteration.currentPhase = targetPhase;

    // 记录变更
    this.changeRecorder.record(state, {
      type: 'phase_transition',
      description: `阶段从${currentPhase}流转到${targetPhase}`,
      changes: [
        { field: 'currentPhase', from: currentPhase, to: targetPhase }
      ]
    });

    await this.repository.write(state);

    return {
      success: true,
      newPhase: targetPhase,
      warnings: validation.warnings
    };
  }
}
```

---

#### 接口3：validateModuleTransition

**调用场景**：模块状态更新验证

```typescript
// 状态管理模块中的使用
class StateService {
  async updateModuleStatus(
    phaseName: string,
    moduleName: string,
    newStatus: ModuleStatus,
    artifacts?: string[]
  ): Promise<UpdateResult> {
    const state = await this.getState();
    const moduleState = state.iterations[state.currentIteration]
      .phases[phaseName].modules[moduleName];

    if (!moduleState) {
      return {
        success: false,
        errors: [`Module "${moduleName}" not found`]
      };
    }

    const oldStatus = moduleState.status;

    // 验证状态流转
    const validation = this.coreProcess.validateModuleTransition(
      oldStatus,
      newStatus
    );

    if (!validation.isValid) {
      return {
        success: false,
        errors: validation.errors
      };
    }

    // 更新状态
    moduleState.status = newStatus;
    if (newStatus === 'approved') {
      moduleState.approvedAt = new Date().toISOString();
    }
    if (artifacts) {
      moduleState.artifacts = [...(moduleState.artifacts || []), ...artifacts];
    }

    // 记录变更
    this.changeRecorder.record(state, {
      type: 'module_status_change',
      description: `模块${moduleName}状态从${oldStatus}变更为${newStatus}`,
      changes: [
        { field: `phases.${phaseName}.modules.${moduleName}.status`, from: oldStatus, to: newStatus }
      ]
    });

    await this.repository.write(state);

    return { success: true, warnings: validation.warnings };
  }
}
```

---

#### 接口4：validateStateIntegrity

**调用场景**：每次状态写入前

```typescript
// 状态管理模块中的使用
class StateRepository {
  async write(state: State): Promise<void> {
    // 写入前验证状态完整性
    const validation = this.coreProcess.validateStateIntegrity(state);

    if (!validation.isValid) {
      throw new StateValidationError(validation.errors);
    }

    // 如果有警告，记录但不阻止
    if (validation.warnings.length > 0) {
      console.warn('State integrity warnings:', validation.warnings);
    }

    // 更新metadata
    state.metadata.stateFileVersion++;
    state.metadata.totalStateChanges++;
    state.metadata.lastUpdatedAt = new Date().toISOString();
    state.metadata.lastUpdatedBy = 'ai';

    // 写入文件
    await this.fileIO.writeJSON(this.STATE_PATH, state);

    // 更新缓存
    this.updateCache(state);
  }
}
```

---

#### 接口5：validateDependencies

**调用场景**：依赖关系变更时

```typescript
// 状态管理模块中的使用
class StateService {
  async updateModuleDependencies(
    dependencies: ModuleDependencies
  ): Promise<UpdateResult> {
    // 验证依赖关系
    const validation = this.coreProcess.validateDependencies(dependencies);

    if (!validation.isValid) {
      return {
        success: false,
        errors: validation.errors
      };
    }

    const state = await this.getState();
    state.moduleDependencies = dependencies;

    // 记录变更
    this.changeRecorder.record(state, {
      type: 'module_status_change',
      description: '更新模块依赖关系',
      changes: [
        { field: 'moduleDependencies', from: 'previous', to: 'updated' }
      ]
    });

    await this.repository.write(state);

    return { success: true, warnings: validation.warnings };
  }
}
```

---

#### 接口6：getRootCauseAnalysisFramework

**调用场景**：回滚时确定回滚阶段

```typescript
// 状态管理模块中的使用
class StateService {
  async rollbackModule(
    moduleName: string,
    rootCauseType: RootCauseType,
    reason: string
  ): Promise<RollbackResult> {
    // 获取分层分析框架
    const framework = this.coreProcess.getRootCauseAnalysisFramework();

    // 确定回滚目标阶段
    const targetPhase = framework.rollbackMapping[rootCauseType];

    if (!targetPhase) {
      return {
        success: false,
        errors: [`Unknown root cause type: ${rootCauseType}`]
      };
    }

    // 执行回滚
    const state = await this.getState();
    const iteration = state.iterations[state.currentIteration];

    // 更新模块状态为rolled_back
    for (const [phaseName, phaseState] of Object.entries(iteration.phases)) {
      const moduleState = phaseState.modules[moduleName];
      if (moduleState && moduleState.status === 'approved') {
        moduleState.status = 'rolled_back';
        moduleState.previousApprovedAt = moduleState.approvedAt;
        moduleState.approvedAt = undefined;
        moduleState.rollbackHistory = moduleState.rollbackHistory || [];
        moduleState.rollbackHistory.push({
          rolledBackAt: new Date().toISOString(),
          reason,
          fromPhase: phaseName,
          toPhase: targetPhase
        });
      }
    }

    // 记录变更
    this.changeRecorder.record(state, {
      type: 'rollback',
      description: `模块${moduleName}回滚到${targetPhase}阶段，原因：${reason}`,
      changes: [
        { field: `modules.${moduleName}.status`, from: 'approved', to: 'rolled_back' }
      ]
    });

    await this.repository.write(state);

    return {
      success: true,
      rolledBackModule: moduleName,
      targetPhase
    };
  }
}
```

---

## 三、下游集成：状态管理模块 → 其他模块

### 3.1 被依赖模块列表

| 模块 | 依赖的接口 | 用途 |
|------|----------|------|
| 命令体系模块 | readState, updateModuleStatus, transitionPhase | 命令执行时读写状态 |
| 影响分析模块 | readState, getModuleDependencies | 读取依赖关系进行影响分析 |
| 文档模板模块 | readState, getCurrentIteration | 读取状态填充模板变量 |
| 测试验证模块 | updateTestSubPhaseStatus, readState | 更新测试阶段状态 |
| Git集成模块 | readState, updateMetadata | 读取状态，更新Git相关元数据 |

### 3.2 公开接口设计 {#arch-集成-状态管理-公开接口}

#### 3.2.1 读取接口

```typescript
/**
 * StateReader - 状态读取接口
 * 被所有模块使用
 */
export interface StateReader {
  /**
   * 读取完整状态
   * @returns 完整的State对象
   */
  readState(): Promise<State>;

  /**
   * 获取当前迭代
   * @returns 当前迭代对象
   */
  getCurrentIteration(): Promise<Iteration>;

  /**
   * 获取当前阶段
   * @returns 当前阶段状态
   */
  getCurrentPhase(): Promise<PhaseState>;

  /**
   * 获取模块状态
   * @param phaseName - 阶段名称
   * @param moduleName - 模块名称
   * @returns 模块状态
   */
  getModuleStatus(phaseName: string, moduleName: string): Promise<ModuleState>;

  /**
   * 获取模块依赖关系
   * @returns 所有模块的依赖关系
   */
  getModuleDependencies(): Promise<ModuleDependencies>;

  /**
   * 获取进度摘要
   * @returns 进度摘要（用于会话恢复）
   */
  getProgressSummary(): Promise<ProgressSummary>;
}
```

---

#### 3.2.2 写入接口

```typescript
/**
 * StateWriter - 状态写入接口
 * 被命令体系模块、测试验证模块使用
 */
export interface StateWriter {
  /**
   * 更新模块状态
   */
  updateModuleStatus(
    phaseName: string,
    moduleName: string,
    newStatus: ModuleStatus,
    artifacts?: string[]
  ): Promise<UpdateResult>;

  /**
   * 阶段流转
   */
  transitionPhase(targetPhase: string): Promise<TransitionResult>;

  /**
   * 审批阶段
   */
  approvePhase(phaseName: string, approvedBy: string): Promise<ApproveResult>;

  /**
   * 审批模块
   */
  approveModule(
    phaseName: string,
    moduleName: string,
    approvedBy: string,
    artifacts: string[]
  ): Promise<ApproveResult>;

  /**
   * 回滚模块
   */
  rollbackModule(
    moduleName: string,
    rootCauseType: RootCauseType,
    reason: string
  ): Promise<RollbackResult>;

  /**
   * 更新Testing子阶段状态
   */
  updateTestSubPhaseStatus(
    subPhase: 'e2e' | 'performance' | 'chaos',
    newStatus: TestSubPhaseStatus,
    artifacts?: TestSubPhaseArtifacts
  ): Promise<UpdateResult>;

  /**
   * 添加任务
   */
  addTask(task: Omit<Task, 'id' | 'createdAt'>): Promise<Task>;

  /**
   * 完成任务
   */
  completeTask(taskId: string, resolution: string): Promise<UpdateResult>;
}
```

---

#### 3.2.3 迁移接口

```typescript
/**
 * MigrationAPI - 迁移接口
 * 被Git集成模块使用
 */
export interface MigrationAPI {
  /**
   * 迁移迭代到历史
   */
  migrateIterationToHistory(iterationId: string): Promise<MigrationResult>;

  /**
   * 检查是否可以迁移
   */
  canMigrate(iterationId: string): Promise<MigrationCheck>;

  /**
   * 创建新迭代
   */
  createNewIteration(version: string, goal: string): Promise<Iteration>;
}
```

---

#### 3.2.4 历史访问接口

```typescript
/**
 * HistoryAPI - 历史访问接口
 * 被影响分析模块使用
 */
export interface HistoryAPI {
  /**
   * 分析是否需要历史数据
   */
  analyzeHistoryNeed(query: string): Promise<HistoryNeedAnalysis>;

  /**
   * 读取历史迭代
   */
  readHistoryIteration(iterationId: string): Promise<HistoricalIteration>;

  /**
   * 跨迭代对比
   */
  compareIterations(
    iterationId1: string,
    iterationId2: string
  ): Promise<IterationComparison>;

  /**
   * 获取模块变更频率
   */
  getModuleChangeFrequency(): Promise<ModuleChangeStats>;
}
```

---

#### 3.2.5 工具接口

```typescript
/**
 * StateUtils - 工具接口
 * 被所有模块使用
 */
export interface StateUtils {
  /**
   * 检查state.json文件大小
   */
  checkFileSize(): Promise<FileSizeCheck>;

  /**
   * 建议下一步操作
   */
  suggestNextAction(): Promise<ActionSuggestion>;

  /**
   * 恢复state.json到指定Git版本
   */
  restoreFromGit(commitHash: string): Promise<RestoreResult>;

  /**
   * 更新Git相关元数据
   */
  updateGitMetadata(
    commitHash: string,
    commitMessage: string
  ): Promise<void>;
}
```

---

## 四、与各模块的详细集成

### 4.1 与命令体系模块的集成

**集成场景**：命令执行时读写状态

```typescript
// 命令体系模块中的使用示例
class StartArchitectureCommand {
  constructor(private stateManager: StateManager) {}

  async execute(): Promise<void> {
    // 1. 读取当前状态
    const state = await this.stateManager.readState();
    const currentPhase = state.iterations[state.currentIteration].currentPhase;

    // 2. 检查前置条件
    if (currentPhase !== 'requirements') {
      throw new Error('Must complete requirements phase first');
    }

    const reqPhase = state.iterations[state.currentIteration].phases.requirements;
    if (reqPhase.status !== 'approved') {
      throw new Error('Requirements phase must be approved');
    }

    // 3. 执行阶段流转
    const result = await this.stateManager.transitionPhase('architecture');

    if (!result.success) {
      throw new Error(`Phase transition failed: ${result.errors?.join(', ')}`);
    }

    console.log('Architecture phase started');
  }
}
```

**调用序列**：

```
用户执行 /start-architecture
  ↓
【命令体系模块】StartArchitectureCommand.execute()
  ↓
  步骤1: 调用 stateManager.readState()
    → 获取当前状态
  ↓
  步骤2: 检查前置条件（当前阶段、审批状态）
  ↓
  步骤3: 调用 stateManager.transitionPhase('architecture')
    → 执行阶段流转（内部调用核心流程模型验证）
  ↓
  返回结果
```

---

### 4.2 与影响分析模块的集成

**集成场景**：读取依赖关系进行影响分析

```typescript
// 影响分析模块中的使用示例
class ImpactAnalyzer {
  constructor(
    private stateManager: StateManager,
    private coreProcess: CoreProcessAlgorithms
  ) {}

  async analyzeModuleChange(
    moduleName: string,
    changeType: ChangeType
  ): Promise<ImpactReport> {
    // 1. 读取模块依赖关系
    const dependencies = await this.stateManager.getModuleDependencies();

    // 2. 调用核心流程模型的影响分析算法
    const report = this.coreProcess.analyzeImpact(
      moduleName,
      changeType,
      dependencies
    );

    // 3. 如果需要历史数据，分析历史
    if (this.needHistoricalContext(changeType)) {
      const historyNeed = await this.stateManager.analyzeHistoryNeed(
        `分析${moduleName}的历史变更`
      );

      if (historyNeed.needHistory) {
        const changeFrequency = await this.stateManager.getModuleChangeFrequency();
        report.historicalContext = changeFrequency[moduleName];
      }
    }

    return report;
  }
}
```

**调用序列**：

```
用户执行 /report-issue "支付模块" "退款逻辑错误"
  ↓
【影响分析模块】ImpactAnalyzer.analyzeModuleChange()
  ↓
  步骤1: 调用 stateManager.getModuleDependencies()
    → 获取模块依赖关系
  ↓
  步骤2: 调用 coreProcess.analyzeImpact()
    → 计算影响范围
  ↓
  步骤3: (可选) 调用 stateManager.analyzeHistoryNeed()
    → 判断是否需要历史数据
  ↓
  步骤4: (可选) 调用 stateManager.getModuleChangeFrequency()
    → 获取历史变更频率
  ↓
  返回影响报告
```

---

### 4.3 与文档模板模块的集成

**集成场景**：读取状态填充模板变量

```typescript
// 文档模板模块中的使用示例
class TemplateEngine {
  constructor(private stateManager: StateManager) {}

  async fillTemplate(
    templatePath: string,
    moduleName: string
  ): Promise<string> {
    // 1. 读取当前状态
    const state = await this.stateManager.readState();
    const iteration = state.iterations[state.currentIteration];

    // 2. 构建变量映射
    const variables: Record<string, string> = {
      '[项目名称]': state.project.name,
      '[版本号]': iteration.version,
      '[迭代]': iteration.id,
      '[日期]': new Date().toISOString().split('T')[0],
      '[模块名称]': moduleName,
      '[当前阶段]': iteration.currentPhase
    };

    // 3. 读取模板
    const template = await fs.readFile(templatePath, 'utf-8');

    // 4. 填充变量
    let result = template;
    for (const [key, value] of Object.entries(variables)) {
      result = result.replace(new RegExp(key.replace(/[[\]]/g, '\\$&'), 'g'), value);
    }

    return result;
  }
}
```

---

### 4.4 与测试验证模块的集成

**集成场景**：更新测试阶段状态

```typescript
// 测试验证模块中的使用示例
class TestRunner {
  constructor(private stateManager: StateManager) {}

  async runE2ETests(): Promise<TestResult> {
    // 1. 更新状态为executing
    await this.stateManager.updateTestSubPhaseStatus(
      'e2e',
      'executing'
    );

    // 2. 执行测试
    const testResult = await this.executeTests();

    // 3. 根据结果更新状态
    if (testResult.passed) {
      await this.stateManager.updateTestSubPhaseStatus(
        'e2e',
        'passed',
        {
          plan: 'docs/testing/iteration-1/E2E测试计划.md',
          code: 'tests/e2e/',
          report: 'docs/testing/iteration-1/E2E测试报告.md'
        }
      );
    } else {
      await this.stateManager.updateTestSubPhaseStatus(
        'e2e',
        'failed',
        {
          plan: 'docs/testing/iteration-1/E2E测试计划.md',
          code: 'tests/e2e/'
        }
      );
    }

    return testResult;
  }
}
```

---

### 4.5 与Git集成模块的集成

**集成场景**：更新Git相关元数据

```typescript
// Git集成模块中的使用示例
class GitIntegration {
  constructor(private stateManager: StateManager) {}

  async commitStateChange(message: string): Promise<void> {
    // 1. 执行git add和commit
    await exec('git add .solodev/state.json');
    const result = await exec(`git commit -m "${message}"`);

    // 2. 获取commit hash
    const hashResult = await exec('git rev-parse HEAD');
    const commitHash = hashResult.stdout.trim().substring(0, 7);

    // 3. 更新状态管理模块中的Git元数据
    await this.stateManager.updateGitMetadata(commitHash, message);
  }

  async createTag(version: string): Promise<void> {
    // 1. 创建tag
    await exec(`git tag ${version}`);

    // 2. 读取当前状态
    const state = await this.stateManager.readState();
    const iteration = state.iterations[state.currentIteration];

    // 3. 更新迭代的git信息
    iteration.git = {
      ...iteration.git,
      tag: version
    };

    // 这里需要直接写入，因为是更新git信息
    // 实际实现中可能需要更细粒度的接口
  }
}
```

---

## 五、集成协议

### 5.1 错误处理协议

| 错误类型 | 处理策略 | 调用方行为 |
|---------|---------|----------|
| `StateFileNotFoundError` | 返回错误，提示初始化 | 提示用户运行初始化命令 |
| `StateFileCorruptedError` | 返回错误，提供修复建议 | 展示修复建议给用户 |
| `StateValidationError` | 返回错误，阻止操作 | 展示具体验证错误 |
| `HistoryNotFoundError` | 返回错误 | 提示历史迭代不存在 |

### 5.2 返回值协议

所有写入操作返回统一的结果结构：

```typescript
interface OperationResult {
  /** 是否成功 */
  success: boolean;

  /** 错误信息（失败时） */
  errors?: string[];

  /** 警告信息（成功时可能有） */
  warnings?: string[];
}
```

### 5.3 日志协议

```typescript
// 状态管理模块的日志级别
interface LogProtocol {
  // INFO: 正常操作
  info(message: string, context?: object): void;

  // WARN: 警告但不阻塞
  warn(message: string, context?: object): void;

  // ERROR: 错误
  error(message: string, context?: object): void;

  // DEBUG: 调试信息（仅开发环境）
  debug(message: string, context?: object): void;
}

// 使用示例
logger.info('Module status updated', {
  module: 'UserModule',
  from: 'in_progress',
  to: 'approved'
});

logger.warn('State file approaching size limit', {
  currentSize: '85KB',
  limit: '100KB'
});

logger.error('State validation failed', {
  errors: ['currentPhase not found']
});
```

---

## 六、数据流图

### 6.1 状态读取流程

```
┌──────────────┐     readState()      ┌───────────────────┐
│  命令体系模块  │ ─────────────────→ │   状态管理模块     │
│  影响分析模块  │                     │  ─────────────── │
│  文档模板模块  │                     │  StateManager     │
│  测试验证模块  │                     │      ↓            │
│  Git集成模块  │                     │  StateService     │
└──────────────┘                     │      ↓            │
        ↑                             │  StateRepository  │
        │                             │      ↓            │
        │ State                       │  FileIO           │
        │                             │      ↓            │
        └───────────────────────────  │  state.json      │
                                      └───────────────────┘
```

### 6.2 状态写入流程

```
┌──────────────┐  updateModuleStatus()  ┌───────────────────┐
│  命令体系模块  │ ─────────────────────→ │   状态管理模块     │
└──────────────┘                        │  ─────────────── │
                                        │  StateManager     │
                                        │      ↓            │
                                        │  StateService     │
                                        │      │            │
              ┌─────────────────────────│      ↓            │
              │                         │  ChangeRecorder   │
              │  validateModuleTransition()  ↓            │
              ↓                         │  核心流程模型检查  │
     ┌────────────────┐                │      ↓            │
     │  核心流程模型    │                │  StateRepository  │
     └────────────────┘                │      │            │
              │                         │      ↓            │
              │  ValidationResult       │  validateState    │
              └────────────────────────→ Integrity()       │
                                        │      ↓            │
                                        │  FileIO.write()   │
                                        │      ↓            │
                                        │  state.json      │
                                        └───────────────────┘
```

---

## 七、性能考虑

### 7.1 缓存策略

| 数据 | 缓存策略 | TTL |
|------|---------|-----|
| state.json内容 | 读时缓存 | 5秒 |
| 阶段定义 | 启动时加载 | 永久 |
| 模块依赖 | 首次读取时缓存 | 写入时失效 |

### 7.2 批量操作

```typescript
// 推荐：批量更新后一次写入
await stateManager.batchUpdate([
  { type: 'moduleStatus', module: 'A', status: 'approved' },
  { type: 'moduleStatus', module: 'B', status: 'approved' },
  { type: 'phaseTransition', target: 'implementation' }
]);

// 不推荐：多次独立写入
await stateManager.updateModuleStatus('A', 'approved');
await stateManager.updateModuleStatus('B', 'approved');
await stateManager.transitionPhase('implementation');
```

---

## 八、测试策略

### 8.1 单元测试

```typescript
describe('StateManager', () => {
  describe('updateModuleStatus', () => {
    it('should update module status successfully', async () => {
      const mockCoreProcess = {
        validateModuleTransition: jest.fn().mockReturnValue({ isValid: true }),
        validateStateIntegrity: jest.fn().mockReturnValue({ isValid: true })
      };

      const stateManager = new StateManager(mockCoreProcess);
      const result = await stateManager.updateModuleStatus(
        'requirements',
        'UserModule',
        'approved'
      );

      expect(result.success).toBe(true);
      expect(mockCoreProcess.validateModuleTransition).toHaveBeenCalled();
    });

    it('should reject invalid status transition', async () => {
      const mockCoreProcess = {
        validateModuleTransition: jest.fn().mockReturnValue({
          isValid: false,
          errors: ['Invalid transition from pending to completed']
        })
      };

      const stateManager = new StateManager(mockCoreProcess);
      const result = await stateManager.updateModuleStatus(
        'requirements',
        'UserModule',
        'completed'
      );

      expect(result.success).toBe(false);
      expect(result.errors).toContain('Invalid transition from pending to completed');
    });
  });
});
```

### 8.2 集成测试

```typescript
describe('StateManager Integration', () => {
  it('should complete full phase transition flow', async () => {
    // 1. 初始化状态
    const stateManager = createRealStateManager();

    // 2. 更新所有模块为approved
    await stateManager.updateModuleStatus('requirements', 'ModuleA', 'approved');
    await stateManager.updateModuleStatus('requirements', 'ModuleB', 'approved');

    // 3. 审批阶段
    await stateManager.approvePhase('requirements', 'human');

    // 4. 执行阶段流转
    const result = await stateManager.transitionPhase('architecture');

    expect(result.success).toBe(true);
    expect(result.newPhase).toBe('architecture');

    // 5. 验证状态
    const state = await stateManager.readState();
    expect(state.iterations[state.currentIteration].currentPhase).toBe('architecture');
  });
});
```

---

## 九、总结

### 9.1 集成关系图

```
┌─────────────────────────────────────────────────────────────┐
│                    【状态管理模块】                           │
│  ═══════════════════════════════════════════════════════   │
│  Provides:                                                  │
│  · readState() / getCurrentIteration()                      │
│  · updateModuleStatus() / transitionPhase()                 │
│  · approvePhase() / approveModule()                         │
│  · rollbackModule()                                         │
│  · updateTestSubPhaseStatus()                               │
│  · migrateIterationToHistory()                              │
│  · analyzeHistoryNeed() / readHistoryIteration()            │
│  · getProgressSummary() / suggestNextAction()               │
│                                                             │
│  Requires (from CoreProcessModel):                          │
│  · getPhaseDefinition()                                     │
│  · validatePhaseTransition()                                │
│  · validateModuleTransition()                               │
│  · validateStateIntegrity()                                 │
│  · validateDependencies()                                   │
│  · getRootCauseAnalysisFramework()                          │
└──────────────────────────┬──────────────────────────────────┘
                           ↑ 被依赖
    ┌──────────────┬───────┼───────┬──────────────┬───────────┐
    │              │       │       │              │           │
┌───┴────┐  ┌─────┴───┐  ┌┴────┐  ┌┴───────┐  ┌──┴────┐  ┌───┴────┐
│命令体系│  │影响分析 │  │文档 │  │测试验证│  │Git集成│  │其他    │
│模块    │  │模块     │  │模板 │  │模块    │  │模块   │  │模块    │
└────────┘  └─────────┘  └─────┘  └────────┘  └───────┘  └────────┘
```

### 9.2 关键成功因素

1. **统一入口**: StateManager作为唯一对外接口
2. **验证前置**: 所有写入操作前调用核心流程模型验证
3. **自动记录**: 变更历史自动维护，不遗漏
4. **清晰协议**: 统一的错误处理和返回值格式
5. **可测试性**: 依赖注入，便于Mock测试
