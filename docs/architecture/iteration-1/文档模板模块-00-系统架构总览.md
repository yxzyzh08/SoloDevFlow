# 文档模板模块 - 系统架构总览

<!--
章节ID规范说明：
- 格式：{#arch-文档模板-[章节标识]}
- 必须标注ID的章节：模块划分、核心流程、对外接口
- 示例：{#arch-文档模板-目录结构} 表示文档模板模块系统架构的目录结构章节
-->

> **项目**: AI超级个体开发助手
> **版本**: v1.0.0
> **迭代**: Iteration 1
> **模块**: 文档模板模块
> **日期**: 2025-12-15

---

## 一、架构概述

### 1.1 模块定位

文档模板模块是整个系统的**文档工厂(Document Factory)**，负责管理模板、填充变量、生成文档，并验证文档间引用关系的有效性：

```
┌─────────────────────────────────────────────────────┐
│              用户交互层(User Interface)              │
│  ───────────────────────────────────────────────── │
│  Slash Commands: /start-requirements, /validate-docs│
└───────────────────────┬─────────────────────────────┘
                        ↓ 触发命令
┌─────────────────────────────────────────────────────┐
│           命令体系模块(Command System)               │
│  ───────────────────────────────────────────────── │
│  解析命令 → 调用文档模板模块 → 生成/验证文档        │
└───────────────────────┬─────────────────────────────┘
                        ↓ 调用
┌─────────────────────────────────────────────────────┐
│     【文档模板模块】(Document Template Module)       │
│  ═══════════════════════════════════════════════   │
│  ┌─────────────────────────────────────────────┐   │
│  │  API层(Public Interface)                    │   │
│  │  ─────────────────────────────────────────  │   │
│  │  · getTemplate() / fillTemplate()           │   │
│  │  · validateReferences() / scanReferences()  │   │
│  └─────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────┐   │
│  │  Service层(Business Logic)                  │   │
│  │  ─────────────────────────────────────────  │   │
│  │  · TemplateService: 模板加载与填充          │   │
│  │  · VariableService: 变量解析与填充          │   │
│  │  · ValidationService: 文档引用验证 ⭐       │   │
│  └─────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────┐   │
│  │  Repository层(Data Access)                  │   │
│  │  ─────────────────────────────────────────  │   │
│  │  · TemplateRepository: 模板文件访问         │   │
│  │  · DocumentRepository: 生成文档访问         │   │
│  └─────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────┐   │
│  │  Parser层(Content Parsing)                  │   │
│  │  ─────────────────────────────────────────  │   │
│  │  · MarkdownParser: Markdown解析             │   │
│  │  · ReferenceParser: 引用解析 ⭐             │   │
│  │  · SectionIdParser: 章节ID解析 ⭐           │   │
│  └─────────────────────────────────────────────┘   │
└───────────────────────┬─────────────────────────────┘
                        ↓ 依赖数据
┌─────────────────────────────────────────────────────┐
│          状态管理模块(State Management)             │
│  ───────────────────────────────────────────────── │
│  提供: state.json变量值、templateVersions           │
└─────────────────────────────────────────────────────┘
                        ↓ 模板存储
┌─────────────────────────────────────────────────────┐
│            模板存储(.solodev/templates/)            │
│  ───────────────────────────────────────────────── │
│  PRD模板、架构模板、测试模板、部署模板             │
└─────────────────────────────────────────────────────┘
```

> ⭐ 标记的是 **stage1 必需功能**（PRD 4.4 文档引用验证）

### 1.2 核心职责

**文档模板模块是"文档守护者"，负责文档生成和验证**：

| 职责类别 | 具体内容 | 非职责(由其他模块负责) |
|---------|---------|----------------------|
| **模板管理** | 加载、解析、版本管理模板文件 | ❌ 不负责模板内容设计 |
| **变量填充** | 从多数据源填充模板变量 | ❌ 不负责管理state.json |
| **文档生成** | 基于模板生成完整文档 | ❌ 不负责AI内容推理 |
| **引用验证** ⭐ | 验证文档间引用关系有效性 | ❌ 不负责修复断链 |
| **章节ID管理** ⭐ | 扫描和验证章节ID | ❌ 不负责定义ID规范 |

### 1.3 架构特点

#### 特点1：分层架构(Layered Architecture)

**设计理念**：职责分离，解析与业务逻辑分开

```typescript
// 层次关系
API层 → 对外暴露统一接口
  ↓
Service层 → 业务逻辑，编排解析器
  ↓
Repository层 → 文件访问抽象
  ↓
Parser层 → 内容解析（Markdown、引用、章节ID）
```

**优势**：
- Parser层可独立测试（纯函数）
- 易于扩展新的解析器
- 关注点分离，代码清晰

#### 特点2：声明式验证规则

**设计理念**：验证规则配置化，易于扩展

```typescript
// 验证规则配置
const validationRules: ValidationRule[] = [
  {
    id: 'file_exists',
    name: '文件存在性检查',
    severity: 'error',
    check: (ref) => fs.existsSync(ref.targetFile)
  },
  {
    id: 'section_exists',
    name: '章节ID存在性检查',
    severity: 'error',
    check: (ref) => sectionIdExists(ref.targetFile, ref.targetSection)
  },
  {
    id: 'id_uniqueness',
    name: 'ID唯一性检查',
    severity: 'error',
    check: (allIds) => !hasDuplicates(allIds)
  }
];
```

**优势**：
- 规则可配置、可扩展
- 验证逻辑清晰
- 便于添加新规则

#### 特点3：正则驱动的解析

**设计理念**：使用正则表达式精确匹配Markdown语法

```typescript
// 章节ID匹配
const SECTION_ID_PATTERN = /^(#{1,6})\s+(.+?)\s+\{#([^}]+)\}\s*$/gm;
// 示例：### 4.1 命令清单 {#prd-命令体系-命令清单}

// 引用匹配
const REFERENCE_PATTERN = /\[([^\]]+)\]\(([^)#]+)(?:#([^)]+))?\)/g;
// 示例：[文档名](路径#章节ID)

// 变量占位符匹配
const VARIABLE_PATTERN = /\[([^\]]+)\]/g;
// 示例：[项目名称]
```

**优势**：
- 精确匹配Markdown语法
- 性能高效
- 易于维护和测试

### 1.4 关键设计决策

| 决策点 | 选择 | 理由 | 替代方案 |
|--------|------|------|---------|
| **解析方式** | 正则表达式 | 简单、高效、精确 | AST解析（复杂度高） |
| **验证规则** | 声明式配置 | 可扩展、易测试 | 硬编码（难以维护） |
| **引用存储** | state.json.documentReferences | 便于影响分析 | 单独文件（增加复杂度） |
| **缓存策略** | 按需加载+LRU缓存 | 平衡内存和性能 | 全量缓存（内存占用大） |
| **错误分级** | error/warning | 区分阻断与提示 | 单一级别（不够灵活） |

---

## 二、模块内部结构

### 2.1 目录结构 {#arch-文档模板-目录结构}

```
src/document-template/
├── index.ts                    # 模块入口，导出公共API
│
├── api/                        # API层(对外接口)
│   ├── template-manager.ts     # 主API类
│   └── types.ts                # API层类型定义
│
├── services/                   # Service层(业务逻辑)
│   ├── template-service.ts     # 模板加载与填充服务
│   ├── variable-service.ts     # 变量解析与填充服务
│   └── validation-service.ts   # 文档引用验证服务 ⭐
│
├── repositories/               # Repository层(数据访问)
│   ├── template-repository.ts  # 模板文件访问
│   └── document-repository.ts  # 生成文档访问
│
├── parsers/                    # Parser层(内容解析)
│   ├── markdown-parser.ts      # Markdown解析
│   ├── reference-parser.ts     # 引用解析 ⭐
│   ├── section-id-parser.ts    # 章节ID解析 ⭐
│   └── variable-parser.ts      # 变量占位符解析
│
├── validators/                 # 验证器(stage1核心) ⭐
│   ├── file-validator.ts       # 文件存在性验证
│   ├── section-validator.ts    # 章节ID存在性验证
│   ├── uniqueness-validator.ts # ID唯一性验证
│   └── consistency-validator.ts# 内容一致性验证
│
├── utils/                      # 工具函数
│   ├── anchor-normalizer.ts    # 锚点规范化
│   └── path-resolver.ts        # 路径解析
│
└── __tests__/                  # 测试
    ├── unit/                   # 单元测试
    ├── integration/            # 集成测试
    └── fixtures/               # 测试数据
```

### 2.2 详细模块设计

#### 模块1：API层(api/)

**职责**：
- 对外暴露统一接口
- 参数校验
- 结果格式化

**核心接口**：

```typescript
/**
 * TemplateManager - 文档模板模块的唯一对外入口
 */
export class TemplateManager {
  constructor(
    private templateService: TemplateService,
    private variableService: VariableService,
    private validationService: ValidationService
  ) {}

  // ===== 模板接口 =====

  /**
   * 获取模板
   */
  async getTemplate(templateType: TemplateType, templateName: string): Promise<Template> {
    return this.templateService.load(templateType, templateName);
  }

  /**
   * 填充模板
   */
  async fillTemplate(
    template: Template,
    variables: Record<string, string>
  ): Promise<FilledTemplate> {
    return this.templateService.fill(template, variables);
  }

  /**
   * 获取变量值（从多数据源）
   */
  async resolveVariables(variableNames: string[]): Promise<Record<string, string>> {
    return this.variableService.resolve(variableNames);
  }

  // ===== 验证接口（stage1核心）⭐ =====

  /**
   * 验证文档引用
   * PRD 4.4.4 接口定义
   */
  async validateDocumentReferences(): Promise<ReferenceValidationResult> {
    return this.validationService.validateAll();
  }

  /**
   * 扫描所有引用
   * PRD 4.4.4 接口定义
   */
  async scanAllReferences(): Promise<DocumentReference[]> {
    return this.validationService.scanAll();
  }

  /**
   * 检查章节ID覆盖
   * PRD 4.4.4 接口定义
   */
  async checkSectionIdCoverage(): Promise<SectionInfo[]> {
    return this.validationService.checkIdCoverage();
  }

  /**
   * 验证单个文档
   */
  async validateDocument(filePath: string): Promise<DocumentValidationResult> {
    return this.validationService.validateDocument(filePath);
  }

  // ===== 版本管理接口 =====

  /**
   * 获取模板版本
   */
  async getTemplateVersions(): Promise<TemplateVersions> {
    return this.templateService.getVersions();
  }

  /**
   * 检查模板升级
   */
  async checkTemplateUpgrade(): Promise<UpgradeCheck> {
    return this.templateService.checkUpgrade();
  }
}
```

---

#### 模块2：Service层(services/)

**职责**：
- 实现业务逻辑
- 编排Parser和Repository
- 结果聚合

**ValidationService核心实现（stage1重点）**：

```typescript
/**
 * ValidationService - 文档引用验证服务
 * 实现 PRD 4.4 文档引用验证功能
 */
export class ValidationService {
  constructor(
    private documentRepo: DocumentRepository,
    private referenceParser: ReferenceParser,
    private sectionIdParser: SectionIdParser,
    private validators: Validator[]
  ) {}

  /**
   * 验证所有文档引用
   * 实现 PRD 4.4.5 的5条验证规则
   */
  async validateAll(): Promise<ReferenceValidationResult> {
    // 1. 扫描所有文档
    const documentPaths = await this.documentRepo.getAllDocuments();

    // 2. 收集所有引用
    const allReferences: DocumentReference[] = [];
    for (const docPath of documentPaths) {
      const content = await this.documentRepo.read(docPath);
      const refs = this.referenceParser.parse(content, docPath);
      allReferences.push(...refs);
    }

    // 3. 收集所有章节ID
    const allSectionIds: SectionIdInfo[] = [];
    for (const docPath of documentPaths) {
      const content = await this.documentRepo.read(docPath);
      const ids = this.sectionIdParser.parse(content, docPath);
      allSectionIds.push(...ids);
    }

    // 4. 执行验证规则
    const result: ReferenceValidationResult = {
      valid: [],
      brokenFile: [],
      brokenSection: [],
      missingId: [],
      duplicateId: [],
      inconsistent: []
    };

    // 规则1: 文件存在性检查
    for (const ref of allReferences) {
      const fileExists = await this.documentRepo.exists(ref.targetFile);
      if (!fileExists) {
        result.brokenFile.push(ref);
      } else if (ref.targetSection) {
        // 规则2: 章节ID存在性检查
        const sectionExists = allSectionIds.some(
          s => s.file === ref.targetFile && s.id === ref.targetSection
        );
        if (!sectionExists) {
          result.brokenSection.push(ref);
        } else {
          result.valid.push(ref);
        }
      } else {
        result.valid.push(ref);
      }
    }

    // 规则3: 必须章节ID检查
    result.missingId = await this.checkRequiredIds(documentPaths);

    // 规则4: 内容一致性检查（v1.0简化版：仅检查数量匹配）
    result.inconsistent = await this.checkConsistency();

    // 规则5: ID唯一性检查
    result.duplicateId = this.checkDuplicateIds(allSectionIds);

    return result;
  }

  /**
   * 扫描所有引用
   */
  async scanAll(): Promise<DocumentReference[]> {
    const documentPaths = await this.documentRepo.getAllDocuments();
    const allReferences: DocumentReference[] = [];

    for (const docPath of documentPaths) {
      const content = await this.documentRepo.read(docPath);
      const refs = this.referenceParser.parse(content, docPath);
      allReferences.push(...refs);
    }

    return allReferences;
  }

  /**
   * 检查章节ID覆盖
   */
  async checkIdCoverage(): Promise<SectionInfo[]> {
    return this.checkRequiredIds(await this.documentRepo.getAllDocuments());
  }

  /**
   * 检查必须标注ID的章节
   */
  private async checkRequiredIds(documentPaths: string[]): Promise<SectionInfo[]> {
    const missingIds: SectionInfo[] = [];

    for (const docPath of documentPaths) {
      const docType = this.inferDocumentType(docPath);
      const requiredSections = this.getRequiredSections(docType);
      const content = await this.documentRepo.read(docPath);
      const existingIds = this.sectionIdParser.parse(content, docPath);

      for (const required of requiredSections) {
        const found = existingIds.some(id =>
          id.sectionName.includes(required.sectionPattern)
        );
        if (!found) {
          missingIds.push({
            file: docPath,
            sectionName: required.sectionPattern,
            lineNumber: 0, // 需要实际定位
            requiredId: this.generateExpectedId(docType, docPath, required.sectionPattern)
          });
        }
      }
    }

    return missingIds;
  }

  /**
   * 检查重复ID
   */
  private checkDuplicateIds(allIds: SectionIdInfo[]): DuplicateIdInfo[] {
    const idMap = new Map<string, SectionIdInfo[]>();

    // 按ID分组
    for (const idInfo of allIds) {
      const existing = idMap.get(idInfo.id) || [];
      existing.push(idInfo);
      idMap.set(idInfo.id, existing);
    }

    // 找出重复的
    const duplicates: DuplicateIdInfo[] = [];
    for (const [id, occurrences] of idMap) {
      if (occurrences.length > 1) {
        duplicates.push({
          id,
          occurrences: occurrences.map(o => ({
            file: o.file,
            lineNumber: o.lineNumber,
            sectionName: o.sectionName
          }))
        });
      }
    }

    return duplicates;
  }

  /**
   * 推断文档类型
   */
  private inferDocumentType(filePath: string): DocumentType {
    if (filePath.includes('/PRD/')) return 'prd';
    if (filePath.includes('/architecture/')) return 'architecture';
    if (filePath.includes('/testing/')) return 'testing';
    if (filePath.includes('/deployment/')) return 'deployment';
    return 'unknown';
  }

  /**
   * 获取必须标注ID的章节（根据PRD 4.4.2）
   */
  private getRequiredSections(docType: DocumentType): RequiredSection[] {
    const requirements: Record<DocumentType, RequiredSection[]> = {
      'prd': [
        { sectionPattern: '命令清单', category: '功能清单' },
        { sectionPattern: '功能清单', category: '功能清单' },
        { sectionPattern: '数据模型', category: '数据模型' },
        { sectionPattern: '验收标准', category: '验收标准' }
      ],
      'architecture': [
        { sectionPattern: '技术架构', category: '技术架构' },
        { sectionPattern: 'Schema', category: 'Schema定义' },
        { sectionPattern: '接口定义', category: '接口定义' },
        { sectionPattern: '对外接口', category: '接口定义' }
      ],
      'testing': [
        { sectionPattern: '用例清单', category: '用例清单' },
        { sectionPattern: '测试结果', category: '测试结果' }
      ],
      'deployment': [
        { sectionPattern: '前置条件', category: '前置条件' },
        { sectionPattern: '部署步骤', category: '部署步骤' },
        { sectionPattern: '回滚步骤', category: '回滚步骤' }
      ],
      'unknown': []
    };
    return requirements[docType];
  }
}
```

---

#### 模块3：Parser层(parsers/)

**职责**：
- 解析Markdown内容
- 提取结构化信息
- 纯函数实现

**ReferenceParser实现**：

```typescript
/**
 * ReferenceParser - 引用解析器
 */
export class ReferenceParser {
  // Markdown链接引用：[文本](路径) 或 [文本](路径#锚点)
  private readonly REFERENCE_PATTERN = /\[([^\]]+)\]\(([^)#\s]+)(?:#([^)\s]+))?\)/g;

  /**
   * 解析文档中的所有引用
   */
  parse(content: string, sourceFile: string): DocumentReference[] {
    const references: DocumentReference[] = [];
    const lines = content.split('\n');

    for (let lineNum = 0; lineNum < lines.length; lineNum++) {
      const line = lines[lineNum];
      let match: RegExpExecArray | null;

      // 重置正则状态
      this.REFERENCE_PATTERN.lastIndex = 0;

      while ((match = this.REFERENCE_PATTERN.exec(line)) !== null) {
        const [fullMatch, text, path, section] = match;

        // 过滤外部链接
        if (path.startsWith('http://') || path.startsWith('https://')) {
          continue;
        }

        references.push({
          sourceFile,
          sourceLine: lineNum + 1,
          targetFile: this.resolvePath(sourceFile, path),
          targetSection: section || undefined,
          referenceText: text
        });
      }
    }

    return references;
  }

  /**
   * 解析相对路径为绝对路径
   */
  private resolvePath(sourceFile: string, relativePath: string): string {
    const sourceDir = path.dirname(sourceFile);
    return path.resolve(sourceDir, relativePath);
  }
}

/**
 * SectionIdParser - 章节ID解析器
 */
export class SectionIdParser {
  // 章节ID：### 标题 {#id}
  private readonly SECTION_ID_PATTERN = /^(#{1,6})\s+(.+?)\s+\{#([^}]+)\}\s*$/;

  /**
   * 解析文档中的所有章节ID
   */
  parse(content: string, sourceFile: string): SectionIdInfo[] {
    const sectionIds: SectionIdInfo[] = [];
    const lines = content.split('\n');

    for (let lineNum = 0; lineNum < lines.length; lineNum++) {
      const line = lines[lineNum];
      const match = line.match(this.SECTION_ID_PATTERN);

      if (match) {
        const [, hashes, title, id] = match;
        sectionIds.push({
          file: sourceFile,
          lineNumber: lineNum + 1,
          level: hashes.length,
          sectionName: title.trim(),
          id: id.trim()
        });
      }
    }

    return sectionIds;
  }

  /**
   * 检查章节ID是否存在于文档中
   */
  exists(content: string, sectionId: string): boolean {
    const normalizedId = this.normalizeAnchor(sectionId);
    const ids = this.parse(content, '');
    return ids.some(info => this.normalizeAnchor(info.id) === normalizedId);
  }

  /**
   * 规范化锚点（PRD 4.4.2 中文锚点处理）
   */
  normalizeAnchor(id: string): string {
    return id
      .replace(/\s+/g, '-')                    // 空格转连字符
      .replace(/[()[\]{}]/g, '')               // 去除括号
      .replace(/[^\w\u4e00-\u9fa5-]/g, '');    // 只保留字母数字中文连字符
  }
}
```

---

## 三、核心流程

### 3.1 文档引用验证流程（stage1核心）⭐

```
用户执行 /validate-docs 或 文档生成后自动触发
  ↓
【API层】TemplateManager.validateDocumentReferences()
  ↓
【Service层】ValidationService.validateAll()
  ↓
  步骤1: 获取所有文档路径
    DocumentRepository.getAllDocuments()
      → docs/PRD/*.md
      → docs/architecture/**/*.md
      → docs/testing/**/*.md
      → docs/deployment/**/*.md
  ↓
  步骤2: 解析所有引用
    FOR EACH document:
      ReferenceParser.parse(content, filePath)
        → 收集所有 [text](path#section) 格式的引用
  ↓
  步骤3: 解析所有章节ID
    FOR EACH document:
      SectionIdParser.parse(content, filePath)
        → 收集所有 ### Title {#id} 格式的章节ID
  ↓
  步骤4: 执行验证规则
    ├─ 规则1: 文件存在性 → brokenFile[]
    ├─ 规则2: 章节ID存在性 → brokenSection[]
    ├─ 规则3: 必须章节ID → missingId[]
    ├─ 规则4: 内容一致性 → inconsistent[]
    └─ 规则5: ID唯一性 → duplicateId[]
  ↓
  步骤5: 返回验证结果
    ReferenceValidationResult {
      valid: [...],
      brokenFile: [...],
      brokenSection: [...],
      missingId: [...],
      duplicateId: [...],
      inconsistent: [...]
    }
  ↓
【调用方】根据结果处理
  ├─ brokenFile/brokenSection/duplicateId → 错误，阻止提交
  └─ missingId/inconsistent → 警告，允许提交但提示
```

### 3.2 模板填充流程

```
用户执行 /start-requirements 等命令
  ↓
【API层】TemplateManager.getTemplate('prd', 'PRD-backend-template')
  ↓
【Service层】TemplateService.load()
  ↓
  步骤1: 从.solodev/templates/读取模板文件
  ↓
  步骤2: 解析模板变量
    VariableParser.parse(template)
      → 识别 [项目名称], [版本号] 等占位符
  ↓
【API层】TemplateManager.resolveVariables(['项目名称', '版本号', ...])
  ↓
【Service层】VariableService.resolve()
  ↓
  步骤3: 按优先级填充变量
    优先级1: state.json → project.name, iterations[current].version
    优先级2: 上下文推断 → 当前日期, 模块名
    优先级3: 询问用户 → 无法推断的信息
  ↓
【API层】TemplateManager.fillTemplate(template, variables)
  ↓
【Service层】TemplateService.fill()
  ↓
  步骤4: 替换变量占位符
    content.replace(/\[项目名称\]/g, variables['项目名称'])
  ↓
  步骤5: 返回填充后的模板
    → AI继续填充内容章节
```

---

## 四、对外接口 {#arch-文档模板-对外接口}

### 4.1 验证接口（stage1核心）⭐

```typescript
export interface DocumentValidator {
  /** 验证所有文档引用（PRD 4.4.4） */
  validateDocumentReferences(): Promise<ReferenceValidationResult>;

  /** 扫描所有引用（PRD 4.4.4） */
  scanAllReferences(): Promise<DocumentReference[]>;

  /** 检查章节ID覆盖（PRD 4.4.4） */
  checkSectionIdCoverage(): Promise<SectionInfo[]>;

  /** 验证单个文档 */
  validateDocument(filePath: string): Promise<DocumentValidationResult>;

  /** 验证引用图谱（PRD 4.4.7） */
  validateReferenceGraph(): Promise<ReferenceGraphValidation>;
}
```

### 4.2 模板接口

```typescript
export interface TemplateAPI {
  /** 获取模板 */
  getTemplate(type: TemplateType, name: string): Promise<Template>;

  /** 列出模板 */
  listTemplates(type?: TemplateType): Promise<TemplateInfo[]>;

  /** 获取模板版本 */
  getTemplateVersions(): Promise<TemplateVersions>;

  /** 检查模板升级 */
  checkTemplateUpgrade(): Promise<UpgradeCheck>;
}
```

### 4.3 变量接口

```typescript
export interface VariableAPI {
  /** 解析变量值 */
  resolveVariables(names: string[]): Promise<Record<string, string>>;

  /** 填充模板 */
  fillTemplate(template: Template, variables: Record<string, string>): Promise<FilledTemplate>;

  /** 检查未填充变量 */
  checkUnfilledVariables(content: string): Promise<string[]>;
}
```

---

## 五、非功能性设计

### 5.1 性能设计

**响应时间目标**：
- 单文档验证: < 100ms
- 全量验证(50个文档): < 2s
- 模板加载: < 50ms
- 变量填充: < 100ms

**优化策略**：

| 优化点 | 策略 | 预期效果 |
|-------|------|---------|
| 文档缓存 | LRU缓存最近读取的10个文档 | 减少重复IO |
| 并行扫描 | Promise.all并行读取多个文档 | 全量验证提速50% |
| 增量验证 | 只验证变更的文档及其引用方 | 日常验证提速80% |
| 正则预编译 | 正则表达式在模块加载时编译 | 解析提速20% |

### 5.2 可靠性设计

**错误处理**：

| 错误场景 | 处理策略 | 用户提示 |
|---------|---------|---------|
| 模板文件不存在 | 抛出TemplateNotFoundError | "模板文件不存在：[路径]" |
| 模板格式错误 | 抛出TemplateParseError | "模板格式错误：[行号] [原因]" |
| 引用解析失败 | 跳过该引用，记录警告 | "引用解析失败：[行号]" |
| 文档读取失败 | 跳过该文档，记录错误 | "文档读取失败：[路径]" |

### 5.3 可扩展性设计

**验证规则扩展**：
- 新规则只需实现Validator接口
- 注册到ValidationService即可生效

**模板类型扩展**：
- 新模板类型添加到TemplateType枚举
- 配置对应的必须章节规则

**变量来源扩展**：
- 实现VariableSource接口
- 注册到VariableService的优先级队列

---

## 六、与其他模块的集成

### 6.1 依赖关系

```
【文档模板模块】 ──依赖──→ 【状态管理模块】
     │
     ├── readState()                    # 读取变量值
     └── getTemplateVersions()          # 读取模板版本
```

### 6.2 被依赖关系

```
【命令体系模块】 ──调用──→ 【文档模板模块】
     │
     ├── /start-* 命令触发模板填充
     └── /validate-docs 命令触发验证

【影响分析模块】 ──调用──→ 【文档模板模块】
     │
     └── 获取文档引用图谱用于影响分析
```

### 6.3 集成接口

详见：[集成设计文档](./文档模板模块-集成设计.md#arch-文档模板-集成接口)

---

## 七、架构演进计划

### 7.1 当前迭代范围(Iteration 1)

**stage1必需功能**（PRD 4.4）：
- ✅ 文档引用验证
- ✅ 章节ID解析
- ✅ 5条验证规则
- ✅ 验证结果分类

**其他功能**：
- ✅ 模板加载与解析
- ✅ 变量填充机制
- ✅ 模板版本管理

**未实现(计划外)**：
- ⏳ 增量验证(v1.1)
- ⏳ 引用图谱可视化(v2.0)
- ⏳ 模板继承机制(v2.0)

### 7.2 技术债务

| 债务描述 | 影响 | 计划解决时间 |
|---------|------|------------|
| 全量验证性能 | 文档多时可能慢 | Iteration 2(增量验证) |
| 一致性检查简化 | 只检查数量匹配 | Iteration 2(深度比对) |
| 无缓存失效机制 | 文件变更后需手动刷新 | Iteration 2 |

---

## 八、总结

### 核心设计理念

**文档模板模块是"文档守护者"**：
- 提供统一的模板管理接口
- 自动验证文档间引用关系
- 确保文档结构一致性

### stage1关键功能

**PRD 4.4 文档引用验证**是stage1必需功能：
1. 5条验证规则完整实现
2. 正则驱动的解析器
3. 声明式的验证配置
4. 清晰的错误分级

### 架构图示

```
┌─────────────────────────────────────────────────────┐
│              【文档模板模块】                        │
│  ═══════════════════════════════════════════════   │
│  ┌─────────────────────────────────────────────┐   │
│  │  API层: TemplateManager                     │   │
│  │  · getTemplate() / fillTemplate()           │   │
│  │  · validateDocumentReferences() ⭐          │   │
│  └────────────────────┬────────────────────────┘   │
│                       ↓                             │
│  ┌─────────────────────────────────────────────┐   │
│  │  Service层: ValidationService ⭐            │   │
│  │  · validateAll() · checkIdCoverage()        │   │
│  └────────────────────┬────────────────────────┘   │
│                       ↓                             │
│  ┌─────────────────────────────────────────────┐   │
│  │  Parser层: ReferenceParser / SectionIdParser│   │
│  │  · parse() · normalizeAnchor() ⭐           │   │
│  └─────────────────────────────────────────────┘   │
└───────────────────────┬─────────────────────────────┘
                        ↓ 依赖
            ┌───────────────────────┐
            │  【状态管理模块】      │
            │  · readState()        │
            └───────────────────────┘
```

> ⭐ 标记的是 stage1 必需功能
