# 运维手册

> **项目**: [项目名称]
> **版本**: [版本号]
> **迭代**: Iteration X
> **日期**: YYYY-MM-DD

---

## 一、运维概述

### 1.1 运维范围

本手册涵盖以下运维内容：
- 日常运维操作（启动/停止/重启服务）
- 健康检查与监控
- 日志管理与分析
- 常见故障排查
- 性能优化
- 备份与恢复
- 扩容与缩容

### 1.2 运维角色

| 角色       | 职责                           |
| ---------- | ------------------------------ |
| **运维AI** | 执行日常运维任务、故障自动恢复 |
| **开发者** | 处理复杂故障、代码修复         |

### 1.3 运维工具

- **进程管理**：PM2 / Docker
- **监控工具**：Prometheus + Grafana
- **日志工具**：ELK / Loki
- **告警工具**：Alertmanager / Email

---

## 二、日常运维操作

### 2.1 服务管理

#### 启动服务

**使用PM2**：
```bash
cd /var/www/[project-name]
pm2 start ecosystem.config.js
```

**使用Docker Compose**：
```bash
cd /var/www/[project-name]
docker-compose up -d
```

**验证服务启动**：
```bash
pm2 list
# 或
docker ps

curl http://localhost:3000/health
```

---

#### 停止服务

**使用PM2**：
```bash
pm2 stop [app-name]
```

**使用Docker Compose**：
```bash
docker-compose stop
```

---

#### 重启服务

**使用PM2**：
```bash
pm2 restart [app-name]
```

**使用Docker Compose**：
```bash
docker-compose restart
```

**平滑重启（无停机）**：
```bash
pm2 reload [app-name]
```

---

#### 查看服务状态

**使用PM2**：
```bash
pm2 list                    # 列表视图
pm2 info [app-name]         # 详细信息
pm2 monit                   # 实时监控
```

**使用Docker**：
```bash
docker ps                   # 查看运行容器
docker stats                # 查看资源使用
docker logs [container]     # 查看日志
```

---

### 2.2 健康检查

#### 应用健康检查

**手动检查**：
```bash
curl http://localhost:3000/health
# 期望输出：{"status":"healthy","uptime":12345}
```

**自动化健康检查脚本**：
```bash
#!/bin/bash
# health-check.sh

HEALTH_URL="http://localhost:3000/health"
RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" $HEALTH_URL)

if [ "$RESPONSE" -eq 200 ]; then
  echo "✓ Service is healthy"
  exit 0
else
  echo "✗ Service is unhealthy (HTTP $RESPONSE)"
  exit 1
fi
```

**定时健康检查（Cron）**：
```bash
# 每5分钟检查一次
*/5 * * * * /path/to/health-check.sh >> /var/log/health-check.log 2>&1
```

---

#### 数据库健康检查

**PostgreSQL**：
```bash
docker exec prod-postgres pg_isready -U ${DB_USER}
# 期望输出：accepting connections
```

**Redis**：
```bash
docker exec prod-redis redis-cli ping
# 期望输出：PONG
```

---

#### 依赖服务健康检查

**检查外部API**：
```bash
curl https://api.external-service.com/health
```

**检查DNS**：
```bash
nslookup example.com
```

---

### 2.3 日志管理

#### 查看实时日志

**使用PM2**：
```bash
pm2 logs [app-name]              # 所有日志
pm2 logs [app-name] --err        # 仅错误日志
pm2 logs [app-name] --lines 100  # 最近100行
```

**使用Docker**：
```bash
docker logs -f [container-name]            # 实时跟踪
docker logs --tail 100 [container-name]    # 最近100行
docker logs --since 1h [container-name]    # 最近1小时
```

---

#### 日志文件位置

**应用日志**：
```
/var/www/[project-name]/logs/
  ├── error.log          # 错误日志
  ├── out.log            # 标准输出
  ├── access.log         # 访问日志
  └── performance.log    # 性能日志
```

**系统日志**：
```
/var/log/
  ├── nginx/
  │   ├── access.log
  │   └── error.log
  ├── pm2/
  └── syslog
```

---

#### 日志轮转配置

**Logrotate配置示例**：
```bash
# /etc/logrotate.d/[project-name]
/var/www/[project-name]/logs/*.log {
  daily                # 每天轮转
  rotate 7             # 保留7天
  compress             # 压缩旧日志
  delaycompress        # 延迟压缩
  missingok            # 日志缺失不报错
  notifempty           # 空日志不轮转
  create 0644 user user
  postrotate
    pm2 reloadLogs
  endscript
}
```

---

#### 日志分析常用命令

**查找错误**：
```bash
grep -i "error" /var/www/[project-name]/logs/error.log
```

**统计错误数量**：
```bash
grep -c "ERROR" /var/www/[project-name]/logs/error.log
```

**查找特定时间段的日志**：
```bash
sed -n '/2025-12-13 10:00/,/2025-12-13 11:00/p' error.log
```

**分析访问日志（Top 10 IP）**：
```bash
awk '{print $1}' access.log | sort | uniq -c | sort -nr | head -10
```

**分析API响应时间**：
```bash
awk '{print $NF}' access.log | sort -n | tail -100  # 最慢100个请求
```

---

## 三、监控与告警

### 3.1 关键监控指标

| 指标类型         | 监控指标                 | 正常范围       | 告警阈值       |
| ---------------- | ------------------------ | -------------- | -------------- |
| **应用性能**     | API响应时间（P95）       | < 500ms        | > 1000ms       |
|                  | 请求吞吐量               | >= 100 req/s   | < 50 req/s     |
|                  | 错误率                   | < 1%           | > 5%           |
| **系统资源**     | CPU使用率                | < 70%          | > 85%          |
|                  | 内存使用率               | < 70%          | > 85%          |
|                  | 磁盘使用率               | < 80%          | > 90%          |
|                  | 磁盘I/O等待              | < 10%          | > 30%          |
| **数据库**       | 数据库连接数             | < 50           | > 80           |
|                  | 慢查询数量               | < 10/min       | > 50/min       |
|                  | 数据库大小               | -              | > 80% quota    |
| **网络**         | 网络带宽使用             | < 70%          | > 85%          |
|                  | TCP连接数                | < 5000         | > 10000        |

### 3.2 监控查看

**查看系统资源**：
```bash
# CPU和内存
htop

# 磁盘使用
df -h

# 磁盘I/O
iostat -x 1

# 网络连接
netstat -an | grep ESTABLISHED | wc -l
```

**查看应用指标**：
```bash
# PM2监控
pm2 monit

# 进程资源使用
ps aux | grep node
```

**查看数据库指标**：
```bash
# PostgreSQL连接数
docker exec prod-postgres psql -U ${DB_USER} -d ${DB_NAME} -c \
  "SELECT count(*) FROM pg_stat_activity;"

# PostgreSQL慢查询
docker exec prod-postgres psql -U ${DB_USER} -d ${DB_NAME} -c \
  "SELECT query, calls, total_time FROM pg_stat_statements ORDER BY total_time DESC LIMIT 10;"
```

---

### 3.3 监控工具配置

#### Prometheus配置（示例）

**prometheus.yml**：
```yaml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'node-app'
    static_configs:
      - targets: ['localhost:3000']
    metrics_path: '/metrics'
```

#### Grafana Dashboard

**推荐Dashboard**：
- Node.js Application Dashboard
- PostgreSQL Database Dashboard
- Nginx Performance Dashboard

---

### 3.4 告警配置

**告警规则示例（Prometheus Alertmanager）**：
```yaml
groups:
  - name: app_alerts
    rules:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.05
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"

      - alert: HighCPU
        expr: cpu_usage_percent > 85
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "CPU usage > 85%"
```

---

## 四、常见故障排查

### 4.1 服务无响应

**症状**：
- 健康检查失败（HTTP 503或超时）
- 用户无法访问服务

**排查步骤**：

```bash
# 1. 检查服务是否运行
pm2 list
# 如果服务停止 → 重启服务

# 2. 检查端口是否监听
lsof -i :3000
# 如果端口未监听 → 检查日志排查启动失败原因

# 3. 检查系统资源
htop
# 如果CPU/内存耗尽 → 重启服务或扩容

# 4. 检查日志
pm2 logs [app-name] --err --lines 50
# 查找错误堆栈

# 5. 检查数据库连接
docker exec prod-postgres pg_isready
# 如果数据库不可用 → 重启数据库容器
```

**常见原因与解决方案**：

| 原因                   | 解决方案                       |
| ---------------------- | ------------------------------ |
| 进程崩溃               | 检查日志，修复bug后重启        |
| 数据库连接失败         | 重启数据库，检查连接配置       |
| 内存泄漏导致OOM        | 重启服务，分析内存泄漏点       |
| 端口被占用             | 杀死占用进程或修改端口配置     |

---

### 4.2 响应时间过长

**症状**：
- API响应时间 > 1秒
- 用户反馈页面加载慢

**排查步骤**：

```bash
# 1. 检查应用负载
pm2 monit
# 查看CPU和内存使用情况

# 2. 检查数据库慢查询
docker exec prod-postgres psql -U ${DB_USER} -d ${DB_NAME} -c \
  "SELECT query, calls, mean_exec_time FROM pg_stat_statements ORDER BY mean_exec_time DESC LIMIT 10;"

# 3. 检查网络延迟
ping [database-host]
# 查看网络RTT

# 4. 检查缓存命中率（如使用Redis）
docker exec prod-redis redis-cli info stats | grep keyspace
```

**常见原因与解决方案**：

| 原因                   | 解决方案                       |
| ---------------------- | ------------------------------ |
| 数据库查询慢           | 添加索引，优化SQL查询          |
| 缓存未命中             | 预热缓存，增加缓存过期时间     |
| 外部API调用慢          | 增加超时设置，启用降级策略     |
| 并发请求过多           | 增加服务实例，启用负载均衡     |

---

### 4.3 数据库连接池耗尽

**症状**：
- 日志显示 "connection pool timeout"
- 新请求无法获取数据库连接

**排查步骤**：

```bash
# 1. 检查当前连接数
docker exec prod-postgres psql -U ${DB_USER} -d ${DB_NAME} -c \
  "SELECT count(*) FROM pg_stat_activity WHERE state = 'active';"

# 2. 查看长时间运行的查询
docker exec prod-postgres psql -U ${DB_USER} -d ${DB_NAME} -c \
  "SELECT pid, now() - query_start AS duration, query FROM pg_stat_activity WHERE state = 'active' ORDER BY duration DESC;"

# 3. 杀死长时间查询（谨慎操作）
docker exec prod-postgres psql -U ${DB_USER} -d ${DB_NAME} -c \
  "SELECT pg_terminate_backend([pid]);"
```

**解决方案**：
- 增加连接池大小（修改配置）
- 优化慢查询
- 设置查询超时时间

---

### 4.4 磁盘空间不足

**症状**：
- 日志显示 "No space left on device"
- 服务无法写入日志或数据

**排查步骤**：

```bash
# 1. 检查磁盘使用情况
df -h

# 2. 查找大文件
du -h /var | sort -rh | head -20

# 3. 查找大日志文件
find /var/log -type f -size +100M -exec ls -lh {} \;
```

**解决方案**：
```bash
# 清理旧日志
find /var/www/[project-name]/logs -name "*.log.*" -mtime +7 -delete

# 清理Docker未使用的镜像和容器
docker system prune -a

# 清理PM2旧日志
pm2 flush

# 紧急情况：临时增加swap
sudo fallocate -l 2G /swapfile
sudo chmod 600 /swapfile
sudo mkswap /swapfile
sudo swapon /swapfile
```

---

### 4.5 内存泄漏

**症状**：
- 内存使用率持续上升
- 服务运行一段时间后变慢或崩溃

**排查步骤**：

```bash
# 1. 监控内存趋势
pm2 monit
# 观察内存是否持续增长

# 2. 生成堆快照（Heap Snapshot）
node --inspect index.js
# 使用Chrome DevTools连接并生成堆快照

# 3. 分析堆快照
# 在Chrome DevTools中查找内存泄漏点
```

**临时解决方案**：
```bash
# 定时重启服务（临时方案）
pm2 start ecosystem.config.js --cron-restart="0 3 * * *"  # 每天凌晨3点重启
```

**长期解决方案**：
- 修复代码中的内存泄漏
- 使用内存分析工具（如clinic.js）

---

## 五、备份与恢复

### 5.1 数据库备份

#### 手动备份

```bash
# 创建备份目录
mkdir -p /var/backups/database

# 备份PostgreSQL
docker exec prod-postgres pg_dump -U ${DB_USER} ${DB_NAME} | \
  gzip > /var/backups/database/backup_$(date +%Y%m%d_%H%M%S).sql.gz

# 验证备份文件
ls -lh /var/backups/database/
```

---

#### 自动化备份（Cron）

**备份脚本**：
```bash
#!/bin/bash
# /usr/local/bin/db-backup.sh

BACKUP_DIR="/var/backups/database"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/backup_$TIMESTAMP.sql.gz"

# 执行备份
docker exec prod-postgres pg_dump -U ${DB_USER} ${DB_NAME} | gzip > $BACKUP_FILE

# 删除7天前的备份
find $BACKUP_DIR -name "backup_*.sql.gz" -mtime +7 -delete

# 记录日志
echo "$(date): Backup completed - $BACKUP_FILE" >> /var/log/db-backup.log
```

**Cron配置**：
```bash
# 每天凌晨2点执行备份
0 2 * * * /usr/local/bin/db-backup.sh
```

---

### 5.2 数据库恢复

#### 恢复到最近备份

```bash
# 1. 停止应用服务
pm2 stop [app-name]

# 2. 删除当前数据库（谨慎操作）
docker exec prod-postgres psql -U ${DB_USER} -c "DROP DATABASE ${DB_NAME};"

# 3. 创建新数据库
docker exec prod-postgres psql -U ${DB_USER} -c "CREATE DATABASE ${DB_NAME};"

# 4. 恢复备份
gunzip < /var/backups/database/backup_YYYYMMDD_HHMMSS.sql.gz | \
  docker exec -i prod-postgres psql -U ${DB_USER} -d ${DB_NAME}

# 5. 重启应用
pm2 restart [app-name]

# 6. 验证
curl http://localhost:3000/health
```

---

#### 恢复到指定时间点（PITR）

**前提**：启用PostgreSQL WAL归档

```bash
# 恢复步骤（具体操作取决于PostgreSQL版本）
# 1. 停止数据库
# 2. 恢复基础备份
# 3. 配置recovery.conf
# 4. 启动数据库自动恢复到指定时间点
```

---

### 5.3 代码备份

**Git作为备份**：
```bash
# 所有代码都在Git仓库中，无需额外备份
git log --oneline  # 查看历史版本
```

**配置文件备份**：
```bash
# 备份环境变量和配置文件（不在Git中的敏感文件）
tar -czf /var/backups/config/config_$(date +%Y%m%d).tar.gz \
  /var/www/[project-name]/.env.production \
  /etc/nginx/sites-available/[project-name]
```

---

## 六、性能优化

### 6.1 应用层优化

**启用缓存**：
```javascript
// 示例：缓存频繁查询的数据
const cachedData = await redis.get(cacheKey);
if (cachedData) return JSON.parse(cachedData);

const data = await db.query(...);
await redis.setex(cacheKey, 300, JSON.stringify(data));  // 缓存5分钟
return data;
```

**启用压缩**：
```javascript
// Express示例
const compression = require('compression');
app.use(compression());
```

**连接池配置**：
```javascript
// PostgreSQL连接池
const pool = new Pool({
  max: 20,           // 最大连接数
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});
```

---

### 6.2 数据库优化

**添加索引**：
```sql
-- 为频繁查询的字段添加索引
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_user_id ON orders(user_id);
```

**分析慢查询**：
```sql
-- 启用慢查询日志
ALTER DATABASE [dbname] SET log_min_duration_statement = 1000;  -- 记录>1s的查询

-- 分析查询计划
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';
```

**定期VACUUM**：
```bash
# 手动VACUUM
docker exec prod-postgres psql -U ${DB_USER} -d ${DB_NAME} -c "VACUUM ANALYZE;"

# 自动VACUUM（PostgreSQL默认启用）
# 查看autovacuum状态
docker exec prod-postgres psql -U ${DB_USER} -d ${DB_NAME} -c \
  "SELECT * FROM pg_stat_user_tables WHERE schemaname = 'public';"
```

---

### 6.3 Nginx优化

**启用缓存**：
```nginx
# /etc/nginx/sites-available/[project-name]
proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=my_cache:10m max_size=1g;

location / {
    proxy_cache my_cache;
    proxy_cache_valid 200 5m;
    proxy_cache_key $scheme$request_method$host$request_uri;
}
```

**启用Gzip**：
```nginx
gzip on;
gzip_types text/plain text/css application/json application/javascript;
gzip_min_length 1000;
```

**增加Worker进程**：
```nginx
# /etc/nginx/nginx.conf
worker_processes auto;  # 自动根据CPU核心数
```

---

## 七、扩容与缩容

### 7.1 垂直扩容（Vertical Scaling）

**增加服务器资源**：
- 升级CPU（2核 → 4核）
- 增加内存（4GB → 8GB）
- 扩展磁盘（50GB → 100GB）

**操作步骤**（云服务器）：
1. 停止服务
2. 在云控制台升级实例配置
3. 启动服务
4. 验证性能提升

---

### 7.2 水平扩容（Horizontal Scaling）

**增加应用实例**：
```bash
# PM2集群模式
pm2 start ecosystem.config.js -i 4  # 启动4个实例

# 或修改配置文件
# ecosystem.config.js
module.exports = {
  apps: [{
    name: 'app',
    script: './dist/index.js',
    instances: 4,  // 从2增加到4
    exec_mode: 'cluster'
  }]
};

pm2 reload ecosystem.config.js
```

**配置负载均衡（Nginx）**：
```nginx
upstream backend {
    server localhost:3000;
    server localhost:3001;
    server localhost:3002;
    server localhost:3003;
}

server {
    location / {
        proxy_pass http://backend;
    }
}
```

---

### 7.3 数据库扩容

**读写分离**：
```
主库（写）
  ↓ 复制
从库1（读）
从库2（读）
```

**分库分表**（数据量极大时）：
- 按用户ID分片
- 按时间分表

---

## 八、安全运维

### 8.1 安全检查清单

- [ ] 服务器SSH密钥登录（禁用密码登录）
- [ ] 防火墙只开放必要端口（80, 443, 22）
- [ ] 定期更新系统和依赖包
- [ ] 数据库不暴露到公网
- [ ] 使用HTTPS（SSL证书有效）
- [ ] 环境变量不包含明文密码
- [ ] 定期审计日志

### 8.2 安全加固

**SSH加固**：
```bash
# /etc/ssh/sshd_config
PermitRootLogin no
PasswordAuthentication no
PubkeyAuthentication yes
```

**防火墙配置（UFW）**：
```bash
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw allow 22/tcp
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw enable
```

**定期更新**：
```bash
# 系统更新
sudo apt update && sudo apt upgrade -y

# 依赖更新（检查安全漏洞）
npm audit
npm audit fix
```

---

## 九、应急预案

### 9.1 紧急联系方式

| 角色       | 联系方式         | 响应时间 |
| ---------- | ---------------- | -------- |
| 开发负责人 | [联系方式]       | < 30min  |
| 运维负责人 | [联系方式]       | < 15min  |
| DBA        | [联系方式]       | < 30min  |

### 9.2 故障响应流程

```
故障发生
  ↓
自动告警（Alertmanager → Email/钉钉）
  ↓
运维AI尝试自动恢复
  ├─ 成功 → 记录日志，通知团队
  └─ 失败 → 升级到人工处理
       ↓
       人工介入排查
         ├─ 快速修复 → 部署修复
         └─ 复杂问题 → 临时回滚 + 后续修复
```

### 9.3 灾难恢复计划（DRP）

**灾难场景**：
- 服务器完全损坏
- 数据中心不可用
- 数据库完全丢失

**恢复步骤**：
1. 启用备用服务器
2. 从异地备份恢复数据库
3. 部署最新代码
4. 切换DNS到新服务器
5. 验证服务恢复

**RTO目标**：< 4小时
**RPO目标**：< 24小时（最多丢失1天数据）

---

## 十、运维最佳实践

### 10.1 预防性运维

- [ ] 定期检查监控指标
- [ ] 定期审查日志（每周）
- [ ] 定期备份验证（每月）
- [ ] 定期演练故障恢复（每季度）
- [ ] 定期更新依赖和系统补丁

### 10.2 文档化

- [ ] 记录所有配置变更
- [ ] 记录故障处理过程
- [ ] 更新运维手册
- [ ] 维护配置管理数据库（CMDB）

### 10.3 自动化

- [ ] 自动化部署（CI/CD）
- [ ] 自动化备份
- [ ] 自动化监控告警
- [ ] 自动化故障恢复（Auto-healing）

---

## 十一、参考资料

**相关文档**：
- 部署手册.md - 部署流程
- CICD配置说明.md - 自动化部署
- 架构文档 - 系统架构说明

**运维工具文档**：
- PM2: https://pm2.keymetrics.io/
- Nginx: https://nginx.org/en/docs/
- PostgreSQL: https://www.postgresql.org/docs/
- Prometheus: https://prometheus.io/docs/
