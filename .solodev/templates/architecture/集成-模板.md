# 集成设计：[模块A] - [模块B/多模块协同]

<!--
章节ID规范说明：
- 格式：{#arch-集成-[集成名]-[章节标识]}
- 必须标注ID的章节：调用序列、接口定义、数据转换
- 示例：{#arch-集成-影响分析-状态管理-调用序列} 表示影响分析与状态管理集成的调用序列
-->

> **项目**: [项目名称]
> **版本**: [版本号]
> **迭代**: Iteration X
> **日期**: YYYY-MM-DD
> **集成复杂度**: 复杂（complex）

---

## 一、集成概述

### 1.1 涉及模块

- **[模块A]**（主调用方）
- **[模块B]**（被调用）
- **[模块C]**（被调用）
- **[模块D]**（被调用）

### 1.2 集成目标

[描述这个集成要实现什么功能，为什么需要多个模块协同工作]

### 1.3 集成复杂度说明

**为何标记为"complex"**：
- [ ] 需要协调调用 3+ 个模块
- [ ] 调用有严格的顺序依赖
- [ ] 涉及复杂的数据转换
- [ ] 需要处理多个模块的状态同步
- [ ] [其他复杂因素]

---

## 二、调用序列

### 2.1 完整调用流程 {#arch-集成-[集成名]-调用序列}

```
[模块A].[主方法](input)
  ↓
  步骤1: 调用 [模块B].[方法1]()
     → 获取 [数据1]
  ↓
  步骤2: 调用 [模块C].[方法2]([数据1])
     → 获取 [数据2]
  ↓
  步骤3: For each item in [数据2]:
     调用 [模块D].[方法3](item)
     → 获取 [数据3]
  ↓
  步骤4: 调用 [模块B].[方法4]([数据3])
     → 生成最终结果
  ↓
  返回结果
```

### 2.2 时序图

```
┌────────┐    ┌────────┐    ┌────────┐    ┌────────┐
│ 模块A  │    │ 模块B  │    │ 模块C  │    │ 模块D  │
└───┬────┘    └───┬────┘    └───┬────┘    └───┬────┘
    │              │              │              │
    ├─ method1() ─>│              │              │
    │<─ 返回数据1 ─┤              │              │
    │              │              │              │
    ├─────────── method2(数据1) ─>│              │
    │<────────────── 返回数据2 ───┤              │
    │              │              │              │
    ├─────────────────────── method3(item) ─────>│
    │<────────────────────────── 返回数据3 ──────┤
    │              │              │              │
    ├─ method4(数据3) ────────>│  │              │
    │<─ 返回最终结果 ─────────┤  │              │
    │              │              │              │
```

### 2.3 数据流图

```
[输入] input: InputType
  ↓
[模块B] → data1: Data1Type
  ↓
[模块C] → data2: Data2Type
  ↓
[模块D] → data3: Data3Type[]
  ↓
[模块B] → result: ResultType
  ↓
[输出] result: ResultType
```

---

## 三、接口定义 {#arch-集成-[集成名]-接口定义}

### 3.1 [模块B] 接口

#### 接口1：[方法1]

**签名**：
```typescript
function method1(): Data1Type
```

**用途**：[描述]

**返回值**：
```typescript
interface Data1Type {
  field1: string;
  field2: number;
}
```

**错误处理**：
- 错误码 E001：[场景] → [处理方式]

---

#### 接口2：[方法4]

**签名**：
```typescript
function method4(data: Data3Type[]): ResultType
```

**用途**：[描述]

**参数**：
- `data`: [参数说明]

**返回值**：
```typescript
interface ResultType {
  success: boolean;
  result: any;
}
```

**错误处理**：
- 错误码 E002：[场景] → [处理方式]

---

### 3.2 [模块C] 接口

#### 接口：[方法2]

**签名**：
```typescript
function method2(input: Data1Type): Data2Type
```

**用途**：[描述]

**参数**：
- `input`: [参数说明]

**返回值**：
```typescript
interface Data2Type {
  items: Item[];
}
```

**错误处理**：
- 错误码 E003：[场景] → [处理方式]

---

### 3.3 [模块D] 接口

#### 接口：[方法3]

**签名**：
```typescript
function method3(item: Item): Data3Type
```

**用途**：[描述]

**参数**：
- `item`: [参数说明]

**返回值**：
```typescript
interface Data3Type {
  processed: boolean;
  data: any;
}
```

**错误处理**：
- 错误码 E004：[场景] → [处理方式]

---

## 四、数据转换

### 4.1 Data1Type → Data2Type

**转换逻辑**：
```
Data1Type.field1 → Data2Type.items[].name
Data1Type.field2 → Data2Type.items[].count
```

**示例**：
```typescript
const data1 = { field1: "test", field2: 5 };
// 转换
const data2 = {
  items: [
    { name: "test", count: 5 }
  ]
};
```

### 4.2 Data2Type → Data3Type[]

**转换逻辑**：
```
For each item in Data2Type.items:
  调用 模块D.method3(item)
  收集结果到 Data3Type[]
```

---

## 五、错误处理

### 5.1 错误分类

| 错误类型         | 处理策略                       | 是否重试 |
| ---------------- | ------------------------------ | -------- |
| **数据不存在**   | 返回空结果，记录警告日志       | 否       |
| **依赖调用失败** | 抛出异常，终止流程             | 是（3次）|
| **数据转换错误** | 跳过错误项，继续处理其他项     | 否       |
| **状态同步失败** | 回滚所有变更，抛出异常         | 否       |

### 5.2 错误传播

```
[模块D] 抛出异常
  ↓
[模块A] 捕获异常
  ├─ 记录错误日志
  ├─ 清理已完成的部分操作
  └─ 向上抛出包装后的异常
```

### 5.3 错误恢复

**场景1：部分失败（允许部分成功）**
```typescript
try {
  results = items.map(item => moduleD.method3(item));
} catch (error) {
  // 跳过失败项，继续处理
  logger.warn(`Failed to process item: ${error}`);
}
```

**场景2：全部失败（需要回滚）**
```typescript
try {
  await beginTransaction();
  // 执行所有操作
  await commitTransaction();
} catch (error) {
  await rollbackTransaction();
  throw error;
}
```

---

## 六、状态同步

### 6.1 状态一致性要求

**场景**：[模块A] 和 [模块B] 需要保持状态一致

**一致性级别**：
- [ ] 强一致性（实时同步）
- [x] 最终一致性（异步同步）
- [ ] 弱一致性（无需同步）

**同步策略**：
```
[模块A] 更新状态
  ↓
触发事件
  ↓
[模块B] ��听事件
  ↓
更新自己的状态
```

### 6.2 并发控制

**锁策略**：
- 使用 [乐观锁 / 悲观锁]
- 锁粒度：[模块级 / 记录级]

**死锁预防**：
- 固定加锁顺序：[模块B] → [模块C] → [模块D]

---

## 七、性能优化

### 7.1 批量处理

**场景**：[模块D] 的 method3 需要被调用多次

**优化策略**：
```typescript
// 优化前：逐个调用
for (const item of items) {
  results.push(await moduleD.method3(item));
}

// 优化后：批量调用
results = await moduleD.method3Batch(items);
```

### 7.2 缓存策略

**缓存位置**：[模块B] 的 method1 结果

**缓存时长**：[5分钟]

**缓存失效策略**：[基于时间 / 基于事件]

### 7.3 并行执行

**可并行的步骤**：
```typescript
// 步骤2 和 步骤3 可以并行
const [data2, data3] = await Promise.all([
  moduleC.method2(data1),
  moduleD.method3(item)
]);
```

---

## 八、示例代码

### 8.1 完整实现示例

```typescript
/**
 * [模块A] 的核心集成逻辑
 */
async function mainMethod(input: InputType): Promise<ResultType> {
  try {
    // 步骤1：获取基础数据
    const data1 = await moduleB.method1();
    logger.info('Step 1 completed', { data1 });

    // 步骤2：数据转换
    const data2 = await moduleC.method2(data1);
    logger.info('Step 2 completed', { itemCount: data2.items.length });

    // 步骤3：批量处理
    const data3: Data3Type[] = [];
    for (const item of data2.items) {
      try {
        const result = await moduleD.method3(item);
        data3.push(result);
      } catch (error) {
        logger.warn(`Failed to process item: ${item}`, error);
        // 跳过失败项，继续处理
      }
    }
    logger.info('Step 3 completed', { processedCount: data3.length });

    // 步骤4：生成最终结果
    const result = await moduleB.method4(data3);
    logger.info('Step 4 completed', { result });

    return result;

  } catch (error) {
    logger.error('Integration failed', error);
    throw new IntegrationError('Failed to complete integration', error);
  }
}
```

### 8.2 错误处理示例

```typescript
class IntegrationError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'IntegrationError';
  }
}

// 使用示例
try {
  await mainMethod(input);
} catch (error) {
  if (error instanceof IntegrationError) {
    // 处理集成错误
    handleIntegrationError(error);
  } else {
    // 处理其他错误
    throw error;
  }
}
```

---

## 九、测试策略

### 9.1 单元测试

**测试范围**：
- 数据转换逻辑
- 错误处理逻辑

**Mock 策略**：
- Mock [模块B], [模块C], [模块D] 的所有接口

### 9.2 集成测试

**测试场景**：
1. 正常流程测试
2. 部分失败测试（[模块D] 部分调用失败）
3. 完全失败测试（[模块B] 调用失败）
4. 并发测试

### 9.3 性能测试

**性能指标**：
- 端到端响应时间：< [200ms]
- 批量处理吞吐量：[1000 items/s]

---

## 十、监控与日志

### 10.1 关键监控指标

| 指标名称             | 监控目标       | 告警阈值       |
| -------------------- | -------------- | -------------- |
| 集成成功率           | > 99%          | < 95%          |
| 平均响应时间         | < 200ms        | > 500ms        |
| 单个模块调用失败率   | < 1%           | > 5%           |

### 10.2 日志规范

**日志级别**：
- INFO：关键步骤完成
- WARN：部分失败但可继续
- ERROR：集成失败

**日志格式**：
```json
{
  "timestamp": "2025-12-13T10:00:00Z",
  "level": "INFO",
  "module": "ModuleA",
  "method": "mainMethod",
  "step": "1",
  "message": "Step 1 completed",
  "data": { "data1": {...} }
}
```
